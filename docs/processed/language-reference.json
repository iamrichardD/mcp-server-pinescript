{
  "functions": {
    "fun_alert": {
      "id": "fun_alert",
      "name": "alert",
      "description": "Creates an alert trigger for an indicator or\n                        strategy, with a specified frequency, when called on the latest realtime bar. To activate alerts\n                        for a script containing calls to this function, open the \"Create Alert\" dialog box, then select\n                        the script name and \"Any alert() function call\" in the \"Condition\" section.",
      "syntax": "alert(message, freq) → void",
      "arguments": [
        {
          "name": "message",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "freq",
          "type": "input string",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"`alert()` example\", \"\", true)ma = ta.sma(close, 14)xUp = ta.crossover(close, ma)if xUp    // Trigger the alert the first time a cross occurs during the real-time bar.    alert(\"Price (\" + str.tostring(close) + \") crossed over MA (\" + str.tostring(ma) + \").\", alert.freq_once_per_bar)plot(ma)plotchar(xUp, \"xUp\", \"▲\", location.top, size = size.tiny)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "alertcondition",
          "href": "fun_alertcondition"
        }
      ]
    },
    "fun_alertcondition": {
      "id": "fun_alertcondition",
      "name": "alertcondition",
      "description": "Creates alert condition, that is available in\n                        Create Alert dialog. Please note, that alertcondition does\n                        NOT create an alert, it just gives you more options in Create Alert dialog. Also, alertcondition\n                        effect is invisible on chart.",
      "syntax": "alertcondition(condition, title, message) → void",
      "arguments": [
        {
          "name": "condition",
          "type": "series bool",
          "description": "Series"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "message",
          "type": "const string",
          "description": "Message"
        }
      ],
      "examples": [
        "//@version=6indicator(\"alertcondition\", overlay=true)alertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "alert",
          "href": "fun_alert"
        }
      ]
    },
    "fun_array.abs": {
      "id": "fun_array.abs",
      "name": "array.abs",
      "description": "Returns an array containing the absolute value of\n                        each element in the original array.",
      "syntax": "array.abs(id) → array<float>",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.avg": {
      "id": "fun_array.avg",
      "name": "array.avg",
      "description": "The function returns the mean of an array's\n                        elements.",
      "syntax": "array.avg(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.avg example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.avg(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.stdev",
          "href": "fun_array.stdev"
        }
      ]
    },
    "fun_array.binary_search": {
      "id": "fun_array.binary_search",
      "name": "array.binary_search",
      "description": "The function returns the index of the value, or -1\n                        if the value is not found. The array to search must be sorted in ascending order.",
      "syntax": "array.binary_search(id, val) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "val",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.binary_search\")a = array.from(5, -2, 0, 9, 1)array.sort(a) // [-2, 0, 1, 5, 9]position = array.binary_search(a, 0) // 1plot(position)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.binary_search_leftmost": {
      "id": "fun_array.binary_search_leftmost",
      "name": "array.binary_search_leftmost",
      "description": "The function returns the index of the value if it\n                        is found. When the value is not found, the function returns the index of the next smallest\n                        element to the left of where the value would lie if it was in the array. The array to search\n                        must be sorted in ascending order.",
      "syntax": "array.binary_search_leftmost(id, val) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "val",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.binary_search_leftmost\")a = array.from(5, -2, 0, 9, 1)array.sort(a) // [-2, 0, 1, 5, 9]position = array.binary_search_leftmost(a, 3) // 2plot(position)",
        "//@version=6indicator(\"array.binary_search_leftmost, repetitive elements\")a = array.from(4, 5, 5, 5)// Returns the index of the first instance.position = array.binary_search_leftmost(a, 5) plot(position) // Plots 1"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.binary_search_rightmost": {
      "id": "fun_array.binary_search_rightmost",
      "name": "array.binary_search_rightmost",
      "description": "The function returns the index of the value if it\n                        is found. When the value is not found, the function returns the index of the element to the\n                        right of where the value would lie if it was in the array. The array must be sorted in ascending\n                        order.",
      "syntax": "array.binary_search_rightmost(id, val) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "val",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.binary_search_rightmost\")a = array.from(5, -2, 0, 9, 1)array.sort(a) // [-2, 0, 1, 5, 9]position = array.binary_search_rightmost(a, 3) // 3plot(position)",
        "//@version=6indicator(\"array.binary_search_rightmost, repetitive elements\")a = array.from(4, 5, 5, 5)// Returns the index of the last instance.position = array.binary_search_rightmost(a, 5) plot(position) // Plots 3"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.clear": {
      "id": "fun_array.clear",
      "name": "array.clear",
      "description": "The function removes all elements from an array.",
      "syntax": "array.clear(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.clear example\")a = array.new_float(5,high)array.clear(a)array.push(a, close)plot(array.get(a,0))plot(array.size(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.pop",
          "href": "fun_array.pop"
        }
      ]
    },
    "fun_array.concat": {
      "id": "fun_array.concat",
      "name": "array.concat",
      "description": "The function is used to merge two arrays. It\n                        pushes all elements from the second array to the first array, and returns the first array.",
      "syntax": "array.concat(id1, id2) → array<type>",
      "arguments": [
        {
          "name": "id1",
          "type": "any array type",
          "description": "The"
        },
        {
          "name": "id2",
          "type": "any array type",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.concat example\")a = array.new_float(0,0)b = array.new_float(0,0)for i = 0 to 4    array.push(a, high[i])    array.push(b, low[i])c = array.concat(a,b)plot(array.size(a))plot(array.size(b))plot(array.size(c))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.copy": {
      "id": "fun_array.copy",
      "name": "array.copy",
      "description": "The function creates a copy of an existing\n                        array.",
      "syntax": "array.copy(id) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.copy example\")length = 5a = array.new_float(length, close)b = array.copy(a)a := array.new_float(length, open)plot(array.sum(a) / length)plot(array.sum(b) / length)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.covariance": {
      "id": "fun_array.covariance",
      "name": "array.covariance",
      "description": "The function returns the covariance of two\n                        arrays.",
      "syntax": "array.covariance(id1, id2, biased) → series float",
      "arguments": [
        {
          "name": "id1",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "id2",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "biased",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.covariance example\")a = array.new_float(0)b = array.new_float(0)for i = 0 to 9    array.push(a, close[i])    array.push(b, open[i])plot(array.covariance(a, b))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.stdev",
          "href": "fun_array.stdev"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        },
        {
          "name": "array.variance",
          "href": "fun_array.variance"
        }
      ]
    },
    "fun_array.every": {
      "id": "fun_array.every",
      "name": "array.every",
      "description": "Returns true if all\n                        elements of the id array are true, false otherwise.",
      "syntax": "array.every(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "array<bool>",
          "description": "An"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.some",
          "href": "fun_array.some"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        }
      ]
    },
    "fun_array.fill": {
      "id": "fun_array.fill",
      "name": "array.fill",
      "description": "The function sets elements of an array to a single\n                        value. If no index is specified, all elements are set. If only a start index (default 0) is\n                        supplied, the elements starting at that index are set. If both index parameters are used, the\n                        elements from the starting index up to but not including the end index (default na) are set.",
      "syntax": "array.fill(id, value, index_from, index_to) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "Value"
        },
        {
          "name": "index_from",
          "type": "series int",
          "description": "Start"
        },
        {
          "name": "index_to",
          "type": "series int",
          "description": "End"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.fill example\")a = array.new_float(10)array.fill(a, close)plot(array.sum(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.first": {
      "id": "fun_array.first",
      "name": "array.first",
      "description": "Returns the array's first element. Throws a\n                        runtime error if the array is empty.",
      "syntax": "array.first(id) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.first example\")arr = array.new_int(3, 10)plot(array.first(arr))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.last",
          "href": "fun_array.last"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        }
      ]
    },
    "fun_array.from": {
      "id": "fun_array.from",
      "name": "array.from",
      "description": "The function takes a variable number of arguments\n                        with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and\n                        returns an array of the corresponding type.",
      "syntax": "array.from(arg0, arg1, ...) → array<type>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"array.from_example\", overlay = false)arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.plot(close)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_array.get": {
      "id": "fun_array.get",
      "name": "array.get",
      "description": "The function returns the value of the element at\n                        the specified index.",
      "syntax": "array.get(id, index) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.get example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i] - open[i])plot(array.get(a, 9))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.includes": {
      "id": "fun_array.includes",
      "name": "array.includes",
      "description": "The function returns true if the value was found\n                        in an array, false otherwise.",
      "syntax": "array.includes(id, value) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.includes example\")a = array.new_float(5,high)p = closeif array.includes(a, high)    p := openplot(p)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.indexof",
          "href": "fun_array.indexof"
        },
        {
          "name": "array.shift",
          "href": "fun_array.shift"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        }
      ]
    },
    "fun_array.indexof": {
      "id": "fun_array.indexof",
      "name": "array.indexof",
      "description": "The function returns the index of the first\n                        occurrence of the value, or -1 if the value is not found.",
      "syntax": "array.indexof(id, value) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.indexof example\")a = array.new_float(5,high)index = array.indexof(a, high)plot(index)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.lastindexof",
          "href": "fun_array.lastindexof"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.lastindexof",
          "href": "fun_array.lastindexof"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        }
      ]
    },
    "fun_array.insert": {
      "id": "fun_array.insert",
      "name": "array.insert",
      "description": "The function changes the contents of an array by\n                        adding new elements in place.",
      "syntax": "array.insert(id, index, value) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.insert example\")a = array.new_float(5, close)array.insert(a, 0, open)plot(array.get(a, 5))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.pop",
          "href": "fun_array.pop"
        },
        {
          "name": "array.unshift",
          "href": "fun_array.unshift"
        }
      ]
    },
    "fun_array.join": {
      "id": "fun_array.join",
      "name": "array.join",
      "description": "The function creates and returns a new string by\n                        concatenating all the elements of an array, separated by the specified separator string.",
      "syntax": "array.join(id, separator) → series string",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float/string>",
          "description": "An"
        },
        {
          "name": "separator",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.join example\")a = array.new_float(5, 5)label.new(bar_index, close, array.join(a, \",\"))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.pop",
          "href": "fun_array.pop"
        },
        {
          "name": "array.unshift",
          "href": "fun_array.unshift"
        }
      ]
    },
    "fun_array.last": {
      "id": "fun_array.last",
      "name": "array.last",
      "description": "Returns the array's last element. Throws a runtime\n                        error if the array is empty.",
      "syntax": "array.last(id) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.last example\")arr = array.new_int(3, 10)plot(array.last(arr))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.first",
          "href": "fun_array.first"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        }
      ]
    },
    "fun_array.lastindexof": {
      "id": "fun_array.lastindexof",
      "name": "array.lastindexof",
      "description": "The function returns the index of the last\n                        occurrence of the value, or -1 if the value is not found.",
      "syntax": "array.lastindexof(id, value) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.lastindexof example\")a = array.new_float(5,high)index = array.lastindexof(a, high)plot(index)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        }
      ]
    },
    "fun_array.max": {
      "id": "fun_array.max",
      "name": "array.max",
      "description": "The function returns the greatest value, or the\n                        nth greatest value in a given array.",
      "syntax": "array.max(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.max\")a = array.from(5, -2, 0, 9, 1)thirdHighest = array.max(a, 2) // 1plot(thirdHighest)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        }
      ]
    },
    "fun_array.median": {
      "id": "fun_array.median",
      "name": "array.median",
      "description": "The function returns the median of an array's\n                        elements.",
      "syntax": "array.median(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.median example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.median(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.median",
          "href": "fun_array.median"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        },
        {
          "name": "array.variance",
          "href": "fun_array.variance"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        }
      ]
    },
    "fun_array.min": {
      "id": "fun_array.min",
      "name": "array.min",
      "description": "The function returns the smallest value, or the\n                        nth smallest value in a given array.",
      "syntax": "array.min(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.min\")a = array.from(5, -2, 0, 9, 1)secondLowest = array.min(a, 1) // 0plot(secondLowest)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        }
      ]
    },
    "fun_array.mode": {
      "id": "fun_array.mode",
      "name": "array.mode",
      "description": "The function returns the mode of an array's\n                        elements. If there are several values with the same frequency, it returns the smallest value.",
      "syntax": "array.mode(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.mode example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.mode(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "ta.mode",
          "href": "fun_ta.mode"
        },
        {
          "name": "matrix.mode",
          "href": "fun_matrix.mode"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        },
        {
          "name": "array.variance",
          "href": "fun_array.variance"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        }
      ]
    },
    "fun_array.new_bool": {
      "id": "fun_array.new_bool",
      "name": "array.new_bool",
      "description": "The function creates a new array object of bool\n                        type elements.",
      "syntax": "array.new_bool(size, initial_value) → array<bool>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series bool",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_bool example\")length = 5a = array.new_bool(length, close > open)plot(array.get(a, 0) ? close : open)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.new_box": {
      "id": "fun_array.new_box",
      "name": "array.new_box",
      "description": "The function creates a new array object of box\n                        type elements.",
      "syntax": "array.new_box(size, initial_value) → array<box>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series box",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_box example\")boxes = array.new_box()array.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))plot(1)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.new_color": {
      "id": "fun_array.new_color",
      "name": "array.new_color",
      "description": "The function creates a new array object of color\n                        type elements.",
      "syntax": "array.new_color(size, initial_value) → array<color>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series color",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_color example\")length = 5a = array.new_color(length, color.red)plot(close, color = array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.new_float": {
      "id": "fun_array.new_float",
      "name": "array.new_float",
      "description": "The function creates a new array object of float\n                        type elements.",
      "syntax": "array.new_float(size, initial_value) → array<float>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series int/float",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_float example\")length = 5a = array.new_float(length, close)plot(array.sum(a) / length)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_color",
          "href": "fun_array.new_color"
        },
        {
          "name": "array.new_bool",
          "href": "fun_array.new_bool"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.new_int": {
      "id": "fun_array.new_int",
      "name": "array.new_int",
      "description": "The function creates a new array object of int\n                        type elements.",
      "syntax": "array.new_int(size, initial_value) → array<int>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series int",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_int example\")length = 5a = array.new_int(length, int(close))plot(array.sum(a) / length)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.new_label": {
      "id": "fun_array.new_label",
      "name": "array.new_label",
      "description": "The function creates a new array object of label\n                        type elements.",
      "syntax": "array.new_label(size, initial_value) → array<label>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series label",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_label example\", overlay = true, max_labels_count = 500)//@variable The number of labels to show on the chart.int labelCount = input.int(50, \"Labels to show\", 1, 500)//@variable An array of `label` objects.var array<label> labelArray = array.new_label()//@variable A `chart.point` for the new label.labelPoint = chart.point.from_index(bar_index, close)//@variable The text in the new label.string labelText = na//@variable The color of the new label.color labelColor = na//@variable The style of the new label.string labelStyle = na// Set the label attributes for rising bars.if close > open    labelText  := \"Rising\"    labelColor := color.green    labelStyle := label.style_label_down// Set the label attributes for falling bars.else if close < open    labelText  := \"Falling\"    labelColor := color.red    labelStyle := label.style_label_up// Add a new label to the `labelArray` when the chart bar closed at a new value.if close != open    labelArray.push(label.new(labelPoint, labelText, color = labelColor, style = labelStyle))// Remove the first element and delete its label when the size of the `labelArray` exceeds the `labelCount`.if labelArray.size() > labelCount    label.delete(labelArray.shift())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.new_line": {
      "id": "fun_array.new_line",
      "name": "array.new_line",
      "description": "The function creates a new array object of line\n                        type elements.",
      "syntax": "array.new_line(size, initial_value) → array<line>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series line",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_line example\")// draw last 15 linesvar a = array.new_line()array.push(a, line.new(bar_index - 1, close[1], bar_index, close))if array.size(a) > 15    ln = array.shift(a)    line.delete(ln)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.new_linefill": {
      "id": "fun_array.new_linefill",
      "name": "array.new_linefill",
      "description": "The function creates a new array object of\n                        linefill type elements.",
      "syntax": "array.new_linefill(size, initial_value) → array<linefill>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series linefill",
          "description": "Initial"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_array.new_string": {
      "id": "fun_array.new_string",
      "name": "array.new_string",
      "description": "The function creates a new array object of string\n                        type elements.",
      "syntax": "array.new_string(size, initial_value) → array<string>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series string",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new_string example\")length = 5a = array.new_string(length, \"text\")label.new(bar_index, close, array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.new_table": {
      "id": "fun_array.new_table",
      "name": "array.new_table",
      "description": "The function creates a new array object of table\n                        type elements.",
      "syntax": "array.new_table(size, initial_value) → array<table>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "series table",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"table array\")tables = array.new_table()array.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))plot(1)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.new<type>": {
      "id": "fun_array.new<type>",
      "name": "array.new<type>",
      "description": "The function creates a new array object of <type>\n                        elements.",
      "syntax": "array.new<type>(size, initial_value) → array<type>",
      "arguments": [
        {
          "name": "size",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "<array_type>",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.new<string> example\")a = array.new<string>(1, \"Hello, World!\")label.new(bar_index, close, array.get(a, 0))",
        "//@version=6indicator(\"array.new<color> example\")a = array.new<color>()array.push(a, color.red)array.push(a, color.green)plot(close, color = array.get(a, close > open ? 1 : 0))",
        "//@version=6indicator(\"array.new<float> example\")length = 5var a = array.new<float>(length, close)if array.size(a) == length    array.remove(a, 0)    array.push(a, close)plot(array.sum(a) / length, \"SMA\")",
        "//@version=6indicator(\"array.new<line> example\")// draw last 15 linesvar a = array.new<line>()array.push(a, line.new(bar_index - 1, close[1], bar_index, close))if array.size(a) > 15    ln = array.shift(a)    line.delete(ln)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.from",
          "href": "fun_array.from"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.size",
          "href": "fun_array.size"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.shift",
          "href": "fun_array.shift"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        }
      ]
    },
    "fun_array.percentile_linear_interpolation": {
      "id": "fun_array.percentile_linear_interpolation",
      "name": "array.percentile_linear_interpolation",
      "description": "Returns the value for which the specified\n                        percentage of array values (percentile) are less than or equal to it, using linear\n                        interpolation.",
      "syntax": "array.percentile_linear_interpolation(id, percentage) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "percentage",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.percentile_nearest_rank": {
      "id": "fun_array.percentile_nearest_rank",
      "name": "array.percentile_nearest_rank",
      "description": "Returns the value for which the specified\n                        percentage of array values (percentile) are less than or equal to it, using the nearest-rank\n                        method.",
      "syntax": "array.percentile_nearest_rank(id, percentage) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "percentage",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.percentrank": {
      "id": "fun_array.percentrank",
      "name": "array.percentrank",
      "description": "Returns the percentile rank of the element at the\n                        specified index.",
      "syntax": "array.percentrank(id, index) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.pop": {
      "id": "fun_array.pop",
      "name": "array.pop",
      "description": "The function removes the last element from an\n                        array and returns its value.",
      "syntax": "array.pop(id) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.pop example\")a = array.new_float(5,high)removedEl = array.pop(a)plot(array.size(a))plot(removedEl)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.shift",
          "href": "fun_array.shift"
        }
      ]
    },
    "fun_array.push": {
      "id": "fun_array.push",
      "name": "array.push",
      "description": "The function appends a value to an array.",
      "syntax": "array.push(id, value) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.push example\")a = array.new_float(5, 0)array.push(a, open)plot(array.get(a, 5))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.pop",
          "href": "fun_array.pop"
        },
        {
          "name": "array.unshift",
          "href": "fun_array.unshift"
        }
      ]
    },
    "fun_array.range": {
      "id": "fun_array.range",
      "name": "array.range",
      "description": "The function returns the difference between the\n                        min and max values from a given array.",
      "syntax": "array.range(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.range example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.range(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        }
      ]
    },
    "fun_array.remove": {
      "id": "fun_array.remove",
      "name": "array.remove",
      "description": "The function changes the contents of an array by\n                        removing the element with the specified index.",
      "syntax": "array.remove(id, index) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.remove example\")a = array.new_float(5,high)removedEl = array.remove(a, 0)plot(array.size(a))plot(removedEl)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.pop",
          "href": "fun_array.pop"
        },
        {
          "name": "array.shift",
          "href": "fun_array.shift"
        }
      ]
    },
    "fun_array.reverse": {
      "id": "fun_array.reverse",
      "name": "array.reverse",
      "description": "The function reverses an array. The first array\n                        element becomes the last, and the last array element becomes the first.",
      "syntax": "array.reverse(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.reverse example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.get(a, 0))array.reverse(a)plot(array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        }
      ]
    },
    "fun_array.set": {
      "id": "fun_array.set",
      "name": "array.set",
      "description": "The function sets the value of the element at the\n                        specified index.",
      "syntax": "array.set(id, index, value) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.set example\")a = array.new_float(10)for i = 0 to 9    array.set(a, i, close[i])plot(array.sum(a) / 10)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        }
      ]
    },
    "fun_array.shift": {
      "id": "fun_array.shift",
      "name": "array.shift",
      "description": "The function removes an array's first element and\n                        returns its value.",
      "syntax": "array.shift(id) → series <type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.shift example\")a = array.new_float(5,high)removedEl = array.shift(a)plot(array.size(a))plot(removedEl)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.unshift",
          "href": "fun_array.unshift"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.push",
          "href": "fun_array.push"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.includes",
          "href": "fun_array.includes"
        }
      ]
    },
    "fun_array.size": {
      "id": "fun_array.size",
      "name": "array.size",
      "description": "The function returns the number of elements in an\n                        array.",
      "syntax": "array.size(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.size example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])// note that changes in slice also modify original arrayslice = array.slice(a, 0, 5)array.push(slice, open)// size was changed in slice and in original arrayplot(array.size(a))plot(array.size(slice))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.slice": {
      "id": "fun_array.slice",
      "name": "array.slice",
      "description": "The function creates a slice from an existing\n                        array. If an object from the slice changes, the changes are applied to both the new and the\n                        original arrays.",
      "syntax": "array.slice(id, index_from, index_to) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "index_from",
          "type": "series int",
          "description": "Zero-based"
        },
        {
          "name": "index_to",
          "type": "series int",
          "description": "Zero-based"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.slice example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])// take elements from 0 to 4// *note that changes in slice also modify original array slice = array.slice(a, 0, 5)plot(array.sum(a) / 10)plot(array.sum(slice) / 5)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "fun_array.some": {
      "id": "fun_array.some",
      "name": "array.some",
      "description": "Returns true if at\n                        least one element of the id array is true, false otherwise.",
      "syntax": "array.some(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "array<bool>",
          "description": "An"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "array.every",
          "href": "fun_array.every"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        }
      ]
    },
    "fun_array.sort": {
      "id": "fun_array.sort",
      "name": "array.sort",
      "description": "The function sorts the elements of an array.",
      "syntax": "array.sort(id, order) → void",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float/string>",
          "description": "An"
        },
        {
          "name": "order",
          "type": "series sort_order",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.sort example\")a = array.new_float(0,0)for i = 0 to 5    array.push(a, high[i])array.sort(a, order.descending)if barstate.islast    label.new(bar_index, close, str.tostring(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.sort_indices": {
      "id": "fun_array.sort_indices",
      "name": "array.sort_indices",
      "description": "Returns an array of indices which, when used to\n                        index the original array, will access its elements in their sorted order. It does not modify the\n                        original array.",
      "syntax": "array.sort_indices(id, order) → array<int>",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float/string>",
          "description": "An"
        },
        {
          "name": "order",
          "type": "series sort_order",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.sort_indices\")a = array.from(5, -2, 0, 9, 1)sortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]indexOfSmallestValue = array.get(sortedIndices, 0) // 1smallestValue = array.get(a, indexOfSmallestValue) // -2plot(smallestValue)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.slice",
          "href": "fun_array.slice"
        },
        {
          "name": "array.reverse",
          "href": "fun_array.reverse"
        },
        {
          "name": "order.ascending",
          "href": "const_order.ascending"
        },
        {
          "name": "order.descending",
          "href": "const_order.descending"
        }
      ]
    },
    "fun_array.standardize": {
      "id": "fun_array.standardize",
      "name": "array.standardize",
      "description": "The function returns the array of standardized\n                        elements.",
      "syntax": "array.standardize(id) → array<float>",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.standardize example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])b = array.standardize(a)plot(array.min(b))plot(array.max(b))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.mode",
          "href": "fun_array.mode"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        },
        {
          "name": "array.variance",
          "href": "fun_array.variance"
        },
        {
          "name": "array.stdev",
          "href": "fun_array.stdev"
        }
      ]
    },
    "fun_array.stdev": {
      "id": "fun_array.stdev",
      "name": "array.stdev",
      "description": "The function returns the standard deviation of an\n                        array's elements.",
      "syntax": "array.stdev(id, biased) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "biased",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.stdev example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.stdev(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        }
      ]
    },
    "fun_array.sum": {
      "id": "fun_array.sum",
      "name": "array.sum",
      "description": "The function returns the sum of an array's\n                        elements.",
      "syntax": "array.sum(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.sum example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.sum(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        }
      ]
    },
    "fun_array.unshift": {
      "id": "fun_array.unshift",
      "name": "array.unshift",
      "description": "The function inserts the value at the beginning of\n                        the array.",
      "syntax": "array.unshift(id, value) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any array type",
          "description": "An"
        },
        {
          "name": "value",
          "type": "series <type of the array's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.unshift example\")a = array.new_float(5, 0)array.unshift(a, open)plot(array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.shift",
          "href": "fun_array.shift"
        },
        {
          "name": "array.set",
          "href": "fun_array.set"
        },
        {
          "name": "array.insert",
          "href": "fun_array.insert"
        },
        {
          "name": "array.remove",
          "href": "fun_array.remove"
        },
        {
          "name": "array.indexof",
          "href": "fun_array.indexof"
        }
      ]
    },
    "fun_array.variance": {
      "id": "fun_array.variance",
      "name": "array.variance",
      "description": "The function returns the variance of an array's\n                        elements.",
      "syntax": "array.variance(id, biased) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "array<int/float>",
          "description": "An"
        },
        {
          "name": "biased",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"array.variance example\")a = array.new_float(0)for i = 0 to 9    array.push(a, close[i])plot(array.variance(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.stdev",
          "href": "fun_array.stdev"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.avg",
          "href": "fun_array.avg"
        },
        {
          "name": "array.covariance",
          "href": "fun_array.covariance"
        }
      ]
    },
    "fun_barcolor": {
      "id": "fun_barcolor",
      "name": "barcolor",
      "description": "Set color of bars.",
      "syntax": "barcolor(color, offset, editable, show_last, title, display) → void",
      "arguments": [
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "display",
          "type": "input plot_simple_display",
          "description": "Controls"
        }
      ],
      "examples": [
        "//@version=6indicator(\"barcolor example\", overlay=true)barcolor(close < open ? color.black : color.white)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        },
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "fill",
          "href": "fun_fill"
        }
      ]
    },
    "fun_bgcolor": {
      "id": "fun_bgcolor",
      "name": "bgcolor",
      "description": "Fill background of bars with specified color.",
      "syntax": "bgcolor(color, offset, editable, show_last, title, display, force_overlay) → void",
      "arguments": [
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "display",
          "type": "input plot_simple_display",
          "description": "Controls"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"bgcolor example\", overlay=true)bgcolor(close < open ? color.new(color.red,70) : color.new(color.green, 70))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "fill",
          "href": "fun_fill"
        }
      ]
    },
    "fun_bool": {
      "id": "fun_bool",
      "name": "bool",
      "description": "Converts the x value to a bool value. Returns false if x\n                        is na, false,\n                        or an int/float value equal to\n                        0. Returns true for all\n                        other possible values.",
      "syntax": "bool(x) → const bool",
      "arguments": [
        {
          "name": "x",
          "type": "simple int/float/bool",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_box": {
      "id": "fun_box",
      "name": "box",
      "description": "Casts na to box.",
      "syntax": "box(x) → series box",
      "arguments": [
        {
          "name": "x",
          "type": "series box",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_box.copy": {
      "id": "fun_box.copy",
      "name": "box.copy",
      "description": "Clones the box object.",
      "syntax": "box.copy(id) → series box",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "Box"
        }
      ],
      "examples": [
        "//@version=6indicator('Last 50 bars price ranges', overlay = true)LOOKBACK = 50highest = ta.highest(LOOKBACK)lowest = ta.lowest(LOOKBACK)if barstate.islastconfirmedhistory    var BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))    var BoxPrev = box.copy(BoxLast)    box.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])    box.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])    box.set_bgcolor(BoxPrev, color.new(color.red, 80))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.delete",
          "href": "fun_box.delete"
        }
      ]
    },
    "fun_box.delete": {
      "id": "fun_box.delete",
      "name": "box.delete",
      "description": "Deletes the specified box object. If it has\n                        already been deleted, does nothing.",
      "syntax": "box.delete(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        }
      ]
    },
    "fun_box.get_bottom": {
      "id": "fun_box.get_bottom",
      "name": "box.get_bottom",
      "description": "Returns the price value of the bottom border of\n                        the box.",
      "syntax": "box.get_bottom(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_bottom",
          "href": "fun_box.set_bottom"
        }
      ]
    },
    "fun_box.get_left": {
      "id": "fun_box.get_left",
      "name": "box.get_left",
      "description": "Returns the bar index or the UNIX time (depending\n                        on the last value used for 'xloc') of the left border of the box.",
      "syntax": "box.get_left(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_left",
          "href": "fun_box.set_left"
        }
      ]
    },
    "fun_box.get_right": {
      "id": "fun_box.get_right",
      "name": "box.get_right",
      "description": "Returns the bar index or the UNIX time (depending\n                        on the last value used for 'xloc') of the right border of the box.",
      "syntax": "box.get_right(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_right",
          "href": "fun_box.set_right"
        }
      ]
    },
    "fun_box.get_top": {
      "id": "fun_box.get_top",
      "name": "box.get_top",
      "description": "Returns the price value of the top border of the\n                        box.",
      "syntax": "box.get_top(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_top",
          "href": "fun_box.set_top"
        }
      ]
    },
    "fun_box.new": {
      "id": "fun_box.new",
      "name": "box.new",
      "description": "Creates a new box object.",
      "syntax": "box.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) → series box",
      "arguments": [
        {
          "name": "top_left",
          "type": "chart.point",
          "description": "A"
        },
        {
          "name": "bottom_right",
          "type": "chart.point",
          "description": "A"
        },
        {
          "name": "border_color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "border_width",
          "type": "series int",
          "description": "Width"
        },
        {
          "name": "border_style",
          "type": "series string",
          "description": "Style"
        },
        {
          "name": "extend",
          "type": "series string",
          "description": "When"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "Determines"
        },
        {
          "name": "bgcolor",
          "type": "series color",
          "description": "Background"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_size",
          "type": "series int/string",
          "description": "Optional."
        },
        {
          "name": "text_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "text_halign",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_valign",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_wrap",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"box.new\")var b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)box.set_lefttop(b, time, 100)box.set_rightbottom(b, time + 60 * 60 * 24, 500)box.set_bgcolor(b, color.green)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "box.delete",
          "href": "fun_box.delete"
        },
        {
          "name": "box.get_left",
          "href": "fun_box.get_left"
        },
        {
          "name": "box.get_top",
          "href": "fun_box.get_top"
        },
        {
          "name": "box.get_right",
          "href": "fun_box.get_right"
        },
        {
          "name": "box.get_bottom",
          "href": "fun_box.get_bottom"
        },
        {
          "name": "box.set_top_left_point",
          "href": "fun_box.set_top_left_point"
        },
        {
          "name": "box.set_left",
          "href": "fun_box.set_left"
        },
        {
          "name": "box.set_top",
          "href": "fun_box.set_top"
        },
        {
          "name": "box.set_bottom_right_point",
          "href": "fun_box.set_bottom_right_point"
        },
        {
          "name": "box.set_right",
          "href": "fun_box.set_right"
        },
        {
          "name": "box.set_bottom",
          "href": "fun_box.set_bottom"
        },
        {
          "name": "box.set_border_color",
          "href": "fun_box.set_border_color"
        },
        {
          "name": "box.set_bgcolor",
          "href": "fun_box.set_bgcolor"
        },
        {
          "name": "box.set_border_width",
          "href": "fun_box.set_border_width"
        },
        {
          "name": "box.set_border_style",
          "href": "fun_box.set_border_style"
        },
        {
          "name": "box.set_extend",
          "href": "fun_box.set_extend"
        },
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_formatting",
          "href": "fun_box.set_text_formatting"
        },
        {
          "name": "box.set_xloc",
          "href": "fun_box.set_xloc"
        }
      ]
    },
    "fun_box.set_bgcolor": {
      "id": "fun_box.set_bgcolor",
      "name": "box.set_bgcolor",
      "description": "Sets the background color of the box.",
      "syntax": "box.set_bgcolor(id, color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        }
      ]
    },
    "fun_box.set_border_color": {
      "id": "fun_box.set_border_color",
      "name": "box.set_border_color",
      "description": "Sets the border color of the box.",
      "syntax": "box.set_border_color(id, color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        }
      ]
    },
    "fun_box.set_border_style": {
      "id": "fun_box.set_border_style",
      "name": "box.set_border_style",
      "description": "Sets the border style of the box.",
      "syntax": "box.set_border_style(id, style) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "style",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        }
      ]
    },
    "fun_box.set_border_width": {
      "id": "fun_box.set_border_width",
      "name": "box.set_border_width",
      "description": "Sets the border width of the box.",
      "syntax": "box.set_border_width(id, width) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "width",
          "type": "series int",
          "description": "Width"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        }
      ]
    },
    "fun_box.set_bottom": {
      "id": "fun_box.set_bottom",
      "name": "box.set_bottom",
      "description": "Sets the bottom coordinate of the box.",
      "syntax": "box.set_bottom(id, bottom) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "bottom",
          "type": "series int/float",
          "description": "Price"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_bottom",
          "href": "fun_box.get_bottom"
        }
      ]
    },
    "fun_box.set_bottom_right_point": {
      "id": "fun_box.set_bottom_right_point",
      "name": "box.set_bottom_right_point",
      "description": "Sets the bottom-right corner location of the\n                        id box to point.",
      "syntax": "box.set_bottom_right_point(id, point) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_box.set_extend": {
      "id": "fun_box.set_extend",
      "name": "box.set_extend",
      "description": "Sets extending type of the border of this box\n                        object. When extend.none\n                        is used, the horizontal borders start at the left border and end at the right border. With extend.left or extend.right,\n                        the horizontal borders are extended indefinitely to the left or right of the box, respectively.\n                        With extend.both, the horizontal borders are extended on\n                        both sides.",
      "syntax": "box.set_extend(id, extend) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "extend",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "extend.none",
          "href": "const_extend.none"
        }
      ]
    },
    "fun_box.set_left": {
      "id": "fun_box.set_left",
      "name": "box.set_left",
      "description": "Sets the left coordinate of the box.",
      "syntax": "box.set_left(id, left) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "left",
          "type": "series int",
          "description": "Bar"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_left",
          "href": "fun_box.get_left"
        }
      ]
    },
    "fun_box.set_lefttop": {
      "id": "fun_box.set_lefttop",
      "name": "box.set_lefttop",
      "description": "Sets the left and top coordinates of the box.",
      "syntax": "box.set_lefttop(id, left, top) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "left",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "top",
          "type": "series int/float",
          "description": "Price"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_left",
          "href": "fun_box.get_left"
        },
        {
          "name": "box.get_top",
          "href": "fun_box.get_top"
        }
      ]
    },
    "fun_box.set_right": {
      "id": "fun_box.set_right",
      "name": "box.set_right",
      "description": "Sets the right coordinate of the box.",
      "syntax": "box.set_right(id, right) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "right",
          "type": "series int",
          "description": "Bar"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_right",
          "href": "fun_box.get_right"
        }
      ]
    },
    "fun_box.set_rightbottom": {
      "id": "fun_box.set_rightbottom",
      "name": "box.set_rightbottom",
      "description": "Sets the right and bottom coordinates of the\n                        box.",
      "syntax": "box.set_rightbottom(id, right, bottom) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "right",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "bottom",
          "type": "series int/float",
          "description": "Price"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_right",
          "href": "fun_box.get_right"
        },
        {
          "name": "box.get_bottom",
          "href": "fun_box.get_bottom"
        }
      ]
    },
    "fun_box.set_text": {
      "id": "fun_box.set_text",
      "name": "box.set_text",
      "description": "The function sets the text in the box.",
      "syntax": "box.set_text(id, text) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        },
        {
          "name": "box.set_text_formatting",
          "href": "fun_box.set_text_formatting"
        }
      ]
    },
    "fun_box.set_text_color": {
      "id": "fun_box.set_text_color",
      "name": "box.set_text_color",
      "description": "The function sets the color of the text inside the\n                        box.",
      "syntax": "box.set_text_color(id, text_color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        }
      ]
    },
    "fun_box.set_text_font_family": {
      "id": "fun_box.set_text_font_family",
      "name": "box.set_text_font_family",
      "description": "The function sets the font family of the text\n                        inside the box.",
      "syntax": "box.set_text_font_family(id, text_font_family) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Example of setting the box font\")if barstate.islastconfirmedhistory    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")    box.set_text_font_family(b, font.family_monospace)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "font.family_default",
          "href": "const_font.family_default"
        },
        {
          "name": "font.family_monospace",
          "href": "const_font.family_monospace"
        }
      ]
    },
    "fun_box.set_text_formatting": {
      "id": "fun_box.set_text_formatting",
      "name": "box.set_text_formatting",
      "description": "Sets the formatting attributes the drawing applies\n                        to displayed text.",
      "syntax": "box.set_text_formatting(id, text_formatting) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        },
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        }
      ]
    },
    "fun_box.set_text_halign": {
      "id": "fun_box.set_text_halign",
      "name": "box.set_text_halign",
      "description": "The function sets the horizontal alignment of the\n                        box's text.",
      "syntax": "box.set_text_halign(id, text_halign) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_halign",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        }
      ]
    },
    "fun_box.set_text_size": {
      "id": "fun_box.set_text_size",
      "name": "box.set_text_size",
      "description": "The function sets the size of the box's text.",
      "syntax": "box.set_text_size(id, text_size) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_size",
          "type": "series int/string",
          "description": "Size"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        }
      ]
    },
    "fun_box.set_text_valign": {
      "id": "fun_box.set_text_valign",
      "name": "box.set_text_valign",
      "description": "The function sets the vertical alignment of a\n                        box's text.",
      "syntax": "box.set_text_valign(id, text_valign) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_valign",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        }
      ]
    },
    "fun_box.set_text_wrap": {
      "id": "fun_box.set_text_wrap",
      "name": "box.set_text_wrap",
      "description": "The function sets the mode of wrapping of the text\n                        inside the box.",
      "syntax": "box.set_text_wrap(id, text_wrap) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "text_wrap",
          "type": "series string",
          "description": "Whether"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_size",
          "href": "fun_box.set_text_size"
        },
        {
          "name": "box.set_text_valign",
          "href": "fun_box.set_text_valign"
        },
        {
          "name": "box.set_text_halign",
          "href": "fun_box.set_text_halign"
        },
        {
          "name": "box.set_text_color",
          "href": "fun_box.set_text_color"
        }
      ]
    },
    "fun_box.set_top": {
      "id": "fun_box.set_top",
      "name": "box.set_top",
      "description": "Sets the top coordinate of the box.",
      "syntax": "box.set_top(id, top) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "top",
          "type": "series int/float",
          "description": "Price"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.get_top",
          "href": "fun_box.get_top"
        }
      ]
    },
    "fun_box.set_top_left_point": {
      "id": "fun_box.set_top_left_point",
      "name": "box.set_top_left_point",
      "description": "Sets the top-left corner location of the\n                        id box to point.",
      "syntax": "box.set_top_left_point(id, point) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "A"
        },
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_box.set_xloc": {
      "id": "fun_box.set_xloc",
      "name": "box.set_xloc",
      "description": "Sets the left and right borders of a box and updates its xloc\n                        property.",
      "syntax": "box.set_xloc(id, left, right, xloc) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series box",
          "description": "The"
        },
        {
          "name": "left",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "right",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "Determines"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "xloc.bar_index",
          "href": "const_xloc.bar_index"
        },
        {
          "name": "xloc.bar_time",
          "href": "const_xloc.bar_time"
        }
      ]
    },
    "fun_chart.point.copy": {
      "id": "fun_chart.point.copy",
      "name": "chart.point.copy",
      "description": "Creates a copy of a chart.point\n                        object with the specified id.",
      "syntax": "chart.point.copy(id) → chart.point",
      "arguments": [
        {
          "name": "id",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_chart.point.from_index": {
      "id": "fun_chart.point.from_index",
      "name": "chart.point.from_index",
      "description": "Returns a chart.point\n                        object with index as its x-coordinate and price as its y-coordinate.",
      "syntax": "chart.point.from_index(index, price) → chart.point",
      "arguments": [
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "price",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_chart.point.from_time": {
      "id": "fun_chart.point.from_time",
      "name": "chart.point.from_time",
      "description": "Returns a chart.point\n                        object with time as its x-coordinate and price as its y-coordinate.",
      "syntax": "chart.point.from_time(time, price) → chart.point",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "price",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_chart.point.new": {
      "id": "fun_chart.point.new",
      "name": "chart.point.new",
      "description": "Creates a new chart.point\n                        object with the specified time, index, and price.",
      "syntax": "chart.point.new(time, index, price) → chart.point",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "price",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "polyline.new",
          "href": "fun_polyline.new"
        }
      ]
    },
    "fun_chart.point.now": {
      "id": "fun_chart.point.now",
      "name": "chart.point.now",
      "description": "Returns a chart.point\n                        object with price as the y-coordinate",
      "syntax": "chart.point.now(price) → chart.point",
      "arguments": [
        {
          "name": "price",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_color": {
      "id": "fun_color",
      "name": "color",
      "description": "Casts na to color",
      "syntax": "color(x) → const color",
      "arguments": [
        {
          "name": "x",
          "type": "const color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_color.b": {
      "id": "fun_color.b",
      "name": "color.b",
      "description": "Retrieves the value of the color's blue\n                        component.",
      "syntax": "color.b(color) → const float",
      "arguments": [
        {
          "name": "color",
          "type": "const color",
          "description": "Color."
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.b\", overlay=true)plot(color.b(color.blue))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.from_gradient": {
      "id": "fun_color.from_gradient",
      "name": "color.from_gradient",
      "description": "Based on the relative position of value in the\n                        bottom_value to top_value range, the function returns a color from the gradient defined by\n                        bottom_color to top_color.",
      "syntax": "color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series color",
      "arguments": [
        {
          "name": "value",
          "type": "series int/float",
          "description": "Value"
        },
        {
          "name": "bottom_value",
          "type": "series int/float",
          "description": "Bottom"
        },
        {
          "name": "top_value",
          "type": "series int/float",
          "description": "Top"
        },
        {
          "name": "bottom_color",
          "type": "series color",
          "description": "Bottom"
        },
        {
          "name": "top_color",
          "type": "series color",
          "description": "Top"
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.from_gradient\", overlay=true)color1 = color.from_gradient(close, low, high, color.yellow, color.lime)color2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))plot(close, color=color1)plot(ta.rsi(close,7), color=color2)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.g": {
      "id": "fun_color.g",
      "name": "color.g",
      "description": "Retrieves the value of the color's green\n                        component.",
      "syntax": "color.g(color) → const float",
      "arguments": [
        {
          "name": "color",
          "type": "const color",
          "description": "Color."
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.g\", overlay=true)plot(color.g(color.green))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.new": {
      "id": "fun_color.new",
      "name": "color.new",
      "description": "Function color applies the specified transparency\n                        to the given color.",
      "syntax": "color.new(color, transp) → const color",
      "arguments": [
        {
          "name": "color",
          "type": "const color",
          "description": "Color"
        },
        {
          "name": "transp",
          "type": "const int/float",
          "description": "Possible"
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.new\", overlay=true)plot(close, color=color.new(color.red, 50))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.r": {
      "id": "fun_color.r",
      "name": "color.r",
      "description": "Retrieves the value of the color's red\n                        component.",
      "syntax": "color.r(color) → const float",
      "arguments": [
        {
          "name": "color",
          "type": "const color",
          "description": "Color."
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.r\", overlay=true)plot(color.r(color.red))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.rgb": {
      "id": "fun_color.rgb",
      "name": "color.rgb",
      "description": "Creates a new color with transparency using the\n                        RGB color model.",
      "syntax": "color.rgb(red, green, blue, transp) → const color",
      "arguments": [
        {
          "name": "red",
          "type": "const int/float",
          "description": "Red"
        },
        {
          "name": "green",
          "type": "const int/float",
          "description": "Green"
        },
        {
          "name": "blue",
          "type": "const int/float",
          "description": "Blue"
        },
        {
          "name": "transp",
          "type": "const int/float",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.rgb\", overlay=true)plot(close, color=color.rgb(255, 0, 0, 50))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_color.t": {
      "id": "fun_color.t",
      "name": "color.t",
      "description": "Retrieves the color's transparency.",
      "syntax": "color.t(color) → const float",
      "arguments": [
        {
          "name": "color",
          "type": "const color",
          "description": "Color."
        }
      ],
      "examples": [
        "//@version=6indicator(\"color.t\", overlay=true)plot(color.t(color.new(color.red, 50)))"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_dayofmonth": {
      "id": "fun_dayofmonth",
      "name": "dayofmonth",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "dayofmonth(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_dayofweek": {
      "id": "fun_dayofweek",
      "name": "dayofweek",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "dayofweek(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_fill": {
      "id": "fun_fill",
      "name": "fill",
      "description": "Fills background between two plots or hlines with\n                        a given color.",
      "syntax": "fill(hline1, hline2, color, title, editable, fillgaps, display) → void",
      "arguments": [
        {
          "name": "hline1",
          "type": "hline",
          "description": "The"
        },
        {
          "name": "hline2",
          "type": "hline",
          "description": "The"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "fillgaps",
          "type": "const bool",
          "description": "Controls"
        },
        {
          "name": "display",
          "type": "input plot_simple_display",
          "description": "Controls"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Fill between hlines\", overlay = false)h1 = hline(20)h2 = hline(10)fill(h1, h2, color = color.new(color.blue, 90))",
        "//@version=6indicator(\"Fill between plots\", overlay = true)p1 = plot(open)p2 = plot(close)fill(p1, p2, color = color.new(color.green, 90))",
        "//@version=6indicator(\"Gradient Fill between hlines\", overlay = false)topVal = input.int(100)botVal = input.int(0)topCol = input.color(color.red)botCol = input.color(color.blue)topLine = hline(100, color = topCol, linestyle = hline.style_solid)botLine = hline(0,   color = botCol, linestyle = hline.style_solid)fill(topLine, botLine, topVal, botVal, topCol, botCol)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        },
        {
          "name": "hline",
          "href": "fun_hline"
        },
        {
          "name": "color.new",
          "href": "fun_color.new"
        }
      ]
    },
    "fun_fixnan": {
      "id": "fun_fixnan",
      "name": "fixnan",
      "description": "For a given series replaces NaN values with\n                        previous nearest non-NaN value.",
      "syntax": "fixnan(source) → series color",
      "arguments": [
        {
          "name": "source",
          "type": "series color",
          "description": "Source"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "na",
          "href": "fun_na"
        },
        {
          "name": "na",
          "href": "var_na"
        },
        {
          "name": "nz",
          "href": "fun_nz"
        }
      ]
    },
    "fun_float": {
      "id": "fun_float",
      "name": "float",
      "description": "Casts na to float",
      "syntax": "float(x) → const float",
      "arguments": [
        {
          "name": "x",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_hline": {
      "id": "fun_hline",
      "name": "hline",
      "description": "Renders a horizontal line at a given fixed price\n                        level.",
      "syntax": "hline(price, title, color, linestyle, linewidth, editable, display) → hline",
      "arguments": [
        {
          "name": "price",
          "type": "input int/float",
          "description": "Price"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "color",
          "type": "input color",
          "description": "Color"
        },
        {
          "name": "linestyle",
          "type": "input hline_style",
          "description": "Style"
        },
        {
          "name": "linewidth",
          "type": "input int",
          "description": "Width"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "input plot_simple_display",
          "description": "Controls"
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.hline\", overlay=true)hline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)// You may fill the background between any two hlines with a fill() function:h1 = hline(20)h2 = hline(10)fill(h1, h2, color=color.new(color.green, 90))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "fill",
          "href": "fun_fill"
        }
      ]
    },
    "fun_hour": {
      "id": "fun_hour",
      "name": "hour",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "hour(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "Hour",
          "type": "in exchange timezone",
          "description": "for provided UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_indicator": {
      "id": "fun_indicator",
      "name": "indicator",
      "description": "This declaration statement designates the script\n                        as an indicator and sets a number of indicator-related properties.",
      "syntax": "indicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, max_polylines_count, dynamic_requests, behind_chart) → void",
      "arguments": [
        {
          "name": "title",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "shorttitle",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "overlay",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "format",
          "type": "const string",
          "description": "Specifies"
        },
        {
          "name": "precision",
          "type": "const int",
          "description": "Specifies"
        },
        {
          "name": "scale",
          "type": "const scale_type",
          "description": "The"
        },
        {
          "name": "max_bars_back",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "timeframe",
          "type": "const string",
          "description": "Adds"
        },
        {
          "name": "timeframe_gaps",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "explicit_plot_zorder",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "max_lines_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "max_labels_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "max_boxes_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "calc_bars_count",
          "type": "const int",
          "description": "Limits"
        },
        {
          "name": "max_polylines_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "dynamic_requests",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "behind_chart",
          "type": "const bool",
          "description": "Controls"
        }
      ],
      "examples": [
        "//@version=6indicator(\"My script\", shorttitle=\"Script\")plot(close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "library",
          "href": "fun_library"
        }
      ]
    },
    "fun_input": {
      "id": "fun_input",
      "name": "input",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function\n                        automatically detects the type of the argument used for 'defval' and uses the corresponding\n                        input widget.",
      "syntax": "input(defval, title, tooltip, inline, group, display, active) → input color",
      "arguments": [
        {
          "name": "defval",
          "type": "const int/float/bool/string/color or source-type built-ins",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input\", overlay=true)i_switch = input(true, \"On/Off\")plot(i_switch ? open : na)i_len = input(7, \"Length\")i_src = input(close, \"Source\")plot(ta.sma(i_src, i_len))i_border = input(142.50, \"Price Border\")hline(i_border)bgcolor(close > i_border ? color.green : color.red)i_col = input(color.red, \"Plot Color\")plot(close, color=i_col)i_text = input(\"Hello!\", \"Message\")l = label.new(bar_index, high, text=i_text)label.delete(l[1])"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        }
      ]
    },
    "fun_input.bool": {
      "id": "fun_input.bool",
      "name": "input.bool",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a checkmark to the script's inputs.",
      "syntax": "input.bool(defval, title, tooltip, inline, group, confirm, display, active) → input bool",
      "arguments": [
        {
          "name": "defval",
          "type": "const bool",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.bool\", overlay=true)i_switch = input.bool(true, \"On/Off\")plot(i_switch ? open : na)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.color": {
      "id": "fun_input.color",
      "name": "input.color",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a color picker that allows the user to select a color and transparency, either from a palette or\n                        a hex value.",
      "syntax": "input.color(defval, title, tooltip, inline, group, confirm, display, active) → input color",
      "arguments": [
        {
          "name": "defval",
          "type": "const color",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.color\", overlay=true)i_col = input.color(color.red, \"Plot Color\")plot(close, color=i_col)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.enum": {
      "id": "fun_input.enum",
      "name": "input.enum",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a dropdown with options based on the enum fields passed to its defval\n                        and options parameters.",
      "syntax": "input.enum(defval, title, options, tooltip, inline, group, confirm, display, active) → input enum",
      "arguments": [
        {
          "name": "defval",
          "type": "const enum",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of enum fields: [enumName.field1, enumName.field2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"Session highlight\", overlay = true)//@enum        Contains fields with popular timezones as titles.//@field exch  Has an empty string as the title to represent the chart timezone.enum tz    utc  = \"UTC\"    exch = \"\"    ny   = \"America/New_York\"    chi  = \"America/Chicago\"    lon  = \"Europe/London\"    tok  = \"Asia/Tokyo\"//@variable The session string.selectedSession = input.session(\"1200-1500\", \"Session\")//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.selectedTimezone = input.enum(tz.utc, \"Session Timezone\")//@variable Is `true` if the current bar's time is in the specified session.bool inSession = falseif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))    inSession := true// Highlight the background when `inSession` is `true`.bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.float": {
      "id": "fun_input.float",
      "name": "input.float",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a field for a float input to the script's inputs.",
      "syntax": "input.float(defval, title, options, tooltip, inline, group, confirm, display, active) → input float",
      "arguments": [
        {
          "name": "defval",
          "type": "const int/float",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of const int/float values: [val1, val2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.float\", overlay=true)i_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)plot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)i_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])plot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.int": {
      "id": "fun_input.int",
      "name": "input.int",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a field for an integer input to the script's inputs.",
      "syntax": "input.int(defval, title, options, tooltip, inline, group, confirm, display, active) → input int",
      "arguments": [
        {
          "name": "defval",
          "type": "const int",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of const int values: [val1, val2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.int\", overlay=true)i_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)plot(ta.sma(close, i_len1))i_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])plot(ta.sma(close, i_len2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.price": {
      "id": "fun_input.price",
      "name": "input.price",
      "description": "Adds a price input to the script's\n                        \"Settings/Inputs\" tab. Using confirm = true activates the interactive input mode\n                        where a price is selected by clicking on the chart.",
      "syntax": "input.price(defval, title, tooltip, inline, group, confirm, display, active) → input float",
      "arguments": [
        {
          "name": "defval",
          "type": "const int/float",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.price\", overlay=true)price1 = input.price(title=\"Date\", defval=42)plot(price1)price2 = input.price(54, title=\"Date\")plot(price2)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.resolution",
          "href": "fun_input.resolution"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.session": {
      "id": "fun_input.session",
      "name": "input.session",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        two dropdowns that allow the user to specify the beginning and the end of a session using the\n                        session selector and returns the result as a string.",
      "syntax": "input.session(defval, title, options, tooltip, inline, group, confirm, display, active) → input string",
      "arguments": [
        {
          "name": "defval",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of const string values: [val1, val2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.session\", overlay=true)i_sess = input.session(\"1300-1700\", \"Session\", options=[\"0930-1600\", \"1300-1700\", \"1700-2100\"])t = time(timeframe.period, i_sess)bgcolor(time == t ? color.green : na)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.source": {
      "id": "fun_input.source",
      "name": "input.source",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a dropdown that allows the user to select a source for the calculation, e.g. close, hl2, etc. The user can also\n                        select an output from another indicator on their chart as the source.",
      "syntax": "input.source(defval, title, tooltip, inline, group, display, active, confirm) → series float",
      "arguments": [
        {
          "name": "defval",
          "type": "open/high/low/close/hl2/hlc3/ohlc4/hlcc4",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.source\", overlay=true)i_src = input.source(close, \"Source\")plot(i_src)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.string": {
      "id": "fun_input.string",
      "name": "input.string",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a field for a string input to the script's inputs.",
      "syntax": "input.string(defval, title, options, tooltip, inline, group, confirm, display, active) → input string",
      "arguments": [
        {
          "name": "defval",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of const string values: [val1, val2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.string\", overlay=true)i_text = input.string(\"Hello!\", \"Message\")l = label.new(bar_index, high, i_text)label.delete(l[1])"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.symbol": {
      "id": "fun_input.symbol",
      "name": "input.symbol",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a field that allows the user to select a specific symbol using the symbol search and returns\n                        that symbol, paired with its exchange prefix, as a string.",
      "syntax": "input.symbol(defval, title, tooltip, inline, group, confirm, display, active) → input string",
      "arguments": [
        {
          "name": "defval",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.symbol\", overlay=true)i_sym = input.symbol(\"DELL\", \"Symbol\")s = request.security(i_sym, 'D', close)plot(s)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.text_area": {
      "id": "fun_input.text_area",
      "name": "input.text_area",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a field for a multiline text input.",
      "syntax": "input.text_area(defval, title, tooltip, group, confirm, display, active) → input string",
      "arguments": [
        {
          "name": "defval",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.text_area\")i_text = input.text_area(defval = \"Hello \\nWorld!\", title = \"Message\")plot(close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.time": {
      "id": "fun_input.time",
      "name": "input.time",
      "description": "Adds a time input to the script's\n                        \"Settings/Inputs\" tab. This function adds two input widgets on the same line: one for the date\n                        and one for the time. The function returns a date/time value in UNIX format. Using confirm\n                            = true activates the interactive input mode where a point in time is selected by\n                        clicking on the chart.",
      "syntax": "input.time(defval, title, tooltip, inline, group, confirm, display, active) → input int",
      "arguments": [
        {
          "name": "defval",
          "type": "const int",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.time\", overlay=true)i_date = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"Date\")l = label.new(i_date, high, \"Date\", xloc=xloc.bar_time)label.delete(l[1])"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_input.timeframe": {
      "id": "fun_input.timeframe",
      "name": "input.timeframe",
      "description": "Adds an input to the Inputs tab of your script's\n                        Settings, which allows you to provide configuration options to script users. This function adds\n                        a dropdown that allows the user to select a specific timeframe via the timeframe selector and\n                        returns it as a string. The selector includes the custom timeframes a user may have added using\n                        the chart's Timeframe dropdown.",
      "syntax": "input.timeframe(defval, title, options, tooltip, inline, group, confirm, display, active) → input string",
      "arguments": [
        {
          "name": "defval",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "options",
          "type": "tuple of const string values: [val1, val2, ...]",
          "description": "A"
        },
        {
          "name": "tooltip",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "inline",
          "type": "const string",
          "description": "Combines"
        },
        {
          "name": "group",
          "type": "const string",
          "description": "Creates"
        },
        {
          "name": "confirm",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "display",
          "type": "const plot_display",
          "description": "Controls"
        },
        {
          "name": "active",
          "type": "input bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"input.timeframe\", overlay=true)i_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])s = request.security(\"AAPL\", i_res, close)plot(s)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.bool",
          "href": "fun_input.bool"
        },
        {
          "name": "input.int",
          "href": "fun_input.int"
        },
        {
          "name": "input.float",
          "href": "fun_input.float"
        },
        {
          "name": "input.string",
          "href": "fun_input.string"
        },
        {
          "name": "input.text_area",
          "href": "fun_input.text_area"
        },
        {
          "name": "input.symbol",
          "href": "fun_input.symbol"
        },
        {
          "name": "input.session",
          "href": "fun_input.session"
        },
        {
          "name": "input.source",
          "href": "fun_input.source"
        },
        {
          "name": "input.color",
          "href": "fun_input.color"
        },
        {
          "name": "input.time",
          "href": "fun_input.time"
        },
        {
          "name": "input",
          "href": "fun_input"
        }
      ]
    },
    "fun_int": {
      "id": "fun_int",
      "name": "int",
      "description": "Casts na or truncates float value to int",
      "syntax": "int(x) → const int",
      "arguments": [
        {
          "name": "x",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_label": {
      "id": "fun_label",
      "name": "label",
      "description": "Casts na to label",
      "syntax": "label(x) → series label",
      "arguments": [
        {
          "name": "x",
          "type": "series label",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        }
      ]
    },
    "fun_label.copy": {
      "id": "fun_label.copy",
      "name": "label.copy",
      "description": "Clones the label object.",
      "syntax": "label.copy(id) → series label",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        }
      ],
      "examples": [
        "//@version=6indicator('Last 100 bars highest/lowest', overlay = true)LOOKBACK = 100highest = ta.highest(LOOKBACK)highestBars = ta.highestbars(LOOKBACK)lowest = ta.lowest(LOOKBACK)lowestBars = ta.lowestbars(LOOKBACK)if barstate.islastconfirmedhistory    var labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)    var labelLow = label.copy(labelHigh)    label.set_xy(labelLow, bar_index + lowestBars, lowest)    label.set_text(labelLow, str.tostring(lowest))    label.set_color(labelLow, color.red)    label.set_style(labelLow, label.style_label_up)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.delete",
          "href": "fun_label.delete"
        }
      ]
    },
    "fun_label.delete": {
      "id": "fun_label.delete",
      "name": "label.delete",
      "description": "Deletes the specified label object. If it has\n                        already been deleted, does nothing.",
      "syntax": "label.delete(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.get_text": {
      "id": "fun_label.get_text",
      "name": "label.get_text",
      "description": "Returns the text of this label object.",
      "syntax": "label.get_text(id) → series string",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        }
      ],
      "examples": [
        "//@version=6indicator(\"label.get_text\")my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)a = label.get_text(my_label)label.new(time, close, text = a + \" new\", xloc=xloc.bar_time)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.get_x": {
      "id": "fun_label.get_x",
      "name": "label.get_x",
      "description": "Returns UNIX time or bar index (depending on the\n                        last xloc value set) of this label's position.",
      "syntax": "label.get_x(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        }
      ],
      "examples": [
        "//@version=6indicator(\"label.get_x\")my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)a = label.get_x(my_label)plot(time - label.get_x(my_label)) //draws zero plot"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.get_y": {
      "id": "fun_label.get_y",
      "name": "label.get_y",
      "description": "Returns price of this label's position.",
      "syntax": "label.get_y(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.new": {
      "id": "fun_label.new",
      "name": "label.new",
      "description": "Creates new label object.",
      "syntax": "label.new(point, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family, force_overlay, text_formatting) → series label",
      "arguments": [
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "Label"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "See"
        },
        {
          "name": "yloc",
          "type": "series string",
          "description": "Possible"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "style",
          "type": "series string",
          "description": "Label"
        },
        {
          "name": "textcolor",
          "type": "series color",
          "description": "Text"
        },
        {
          "name": "size",
          "type": "series int/string",
          "description": "Optional."
        },
        {
          "name": "textalign",
          "type": "series string",
          "description": "Label"
        },
        {
          "name": "tooltip",
          "type": "series string",
          "description": "Hover"
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"label.new\")var label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)label.set_x(label1, 0)label.set_xloc(label1, time, xloc.bar_time)label.set_color(label1, color.red)label.set_size(label1, size.large)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "label.delete",
          "href": "fun_label.delete"
        },
        {
          "name": "label.set_x",
          "href": "fun_label.set_x"
        },
        {
          "name": "label.set_y",
          "href": "fun_label.set_y"
        },
        {
          "name": "label.set_xy",
          "href": "fun_label.set_xy"
        },
        {
          "name": "label.set_xloc",
          "href": "fun_label.set_xloc"
        },
        {
          "name": "label.set_yloc",
          "href": "fun_label.set_yloc"
        },
        {
          "name": "label.set_color",
          "href": "fun_label.set_color"
        },
        {
          "name": "label.set_textcolor",
          "href": "fun_label.set_textcolor"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.set_tooltip",
          "href": "fun_label.set_tooltip"
        },
        {
          "name": "label.set_text",
          "href": "fun_label.set_text"
        },
        {
          "name": "label.set_text_formatting",
          "href": "fun_label.set_text_formatting"
        }
      ]
    },
    "fun_label.set_color": {
      "id": "fun_label.set_color",
      "name": "label.set_color",
      "description": "Sets label border and arrow color.",
      "syntax": "label.set_color(id, color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_point": {
      "id": "fun_label.set_point",
      "name": "label.set_point",
      "description": "Sets the location of the id label to\n                        point.",
      "syntax": "label.set_point(id, point) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "A"
        },
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_label.set_size": {
      "id": "fun_label.set_size",
      "name": "label.set_size",
      "description": "Sets arrow and text size of the specified label\n                        object.",
      "syntax": "label.set_size(id, size) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "size",
          "type": "series int/string",
          "description": "Size"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_style": {
      "id": "fun_label.set_style",
      "name": "label.set_style",
      "description": "Sets label style.",
      "syntax": "label.set_style(id, style) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "style",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_text": {
      "id": "fun_label.set_text",
      "name": "label.set_text",
      "description": "Sets label text",
      "syntax": "label.set_text(id, text) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_text_formatting",
          "href": "fun_label.set_text_formatting"
        }
      ]
    },
    "fun_label.set_text_font_family": {
      "id": "fun_label.set_text_font_family",
      "name": "label.set_text_font_family",
      "description": "The function sets the font family of the text\n                        inside the label.",
      "syntax": "label.set_text_font_family(id, text_font_family) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "A"
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Example of setting the label font\")if barstate.islastconfirmedhistory    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)    label.set_text_font_family(l, font.family_monospace)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "font.family_default",
          "href": "const_font.family_default"
        },
        {
          "name": "font.family_monospace",
          "href": "const_font.family_monospace"
        }
      ]
    },
    "fun_label.set_text_formatting": {
      "id": "fun_label.set_text_formatting",
      "name": "label.set_text_formatting",
      "description": "Sets the formatting attributes the drawing applies\n                        to displayed text.",
      "syntax": "label.set_text_formatting(id, text_formatting) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_text",
          "href": "fun_label.set_text"
        }
      ]
    },
    "fun_label.set_textalign": {
      "id": "fun_label.set_textalign",
      "name": "label.set_textalign",
      "description": "Sets the alignment for the label text.",
      "syntax": "label.set_textalign(id, textalign) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "textalign",
          "type": "series string",
          "description": "Label"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "text.align_left",
          "href": "const_text.align_left"
        },
        {
          "name": "text.align_center",
          "href": "const_text.align_center"
        },
        {
          "name": "text.align_right",
          "href": "const_text.align_right"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_textcolor": {
      "id": "fun_label.set_textcolor",
      "name": "label.set_textcolor",
      "description": "Sets color of the label text.",
      "syntax": "label.set_textcolor(id, textcolor) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "textcolor",
          "type": "series color",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_tooltip": {
      "id": "fun_label.set_tooltip",
      "name": "label.set_tooltip",
      "description": "Sets the tooltip text.",
      "syntax": "label.set_tooltip(id, tooltip) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "tooltip",
          "type": "series string",
          "description": "Tooltip"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_x": {
      "id": "fun_label.set_x",
      "name": "label.set_x",
      "description": "Sets bar index or bar time (depending on the xloc)\n                        of the label position.",
      "syntax": "label.set_x(id, x) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_xloc": {
      "id": "fun_label.set_xloc",
      "name": "label.set_xloc",
      "description": "Sets x-location and new bar index/time value.",
      "syntax": "label.set_xloc(id, x, xloc) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "New"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "xloc.bar_index",
          "href": "const_xloc.bar_index"
        },
        {
          "name": "xloc.bar_time",
          "href": "const_xloc.bar_time"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_xy": {
      "id": "fun_label.set_xy",
      "name": "label.set_xy",
      "description": "Sets bar index/time and price of the label\n                        position.",
      "syntax": "label.set_xy(id, x, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "New"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_y": {
      "id": "fun_label.set_y",
      "name": "label.set_y",
      "description": "Sets price of the label position",
      "syntax": "label.set_y(id, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_label.set_yloc": {
      "id": "fun_label.set_yloc",
      "name": "label.set_yloc",
      "description": "Sets new y-location calculation algorithm.",
      "syntax": "label.set_yloc(id, yloc) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series label",
          "description": "Label"
        },
        {
          "name": "yloc",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "yloc.price",
          "href": "const_yloc.price"
        },
        {
          "name": "yloc.abovebar",
          "href": "const_yloc.abovebar"
        },
        {
          "name": "yloc.belowbar",
          "href": "const_yloc.belowbar"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "fun_library": {
      "id": "fun_library",
      "name": "library",
      "description": "Declaration statement identifying a script as a library.",
      "syntax": "library(title, overlay, dynamic_requests) → void",
      "arguments": [
        {
          "name": "title",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "overlay",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "dynamic_requests",
          "type": "const bool",
          "description": "Specifies"
        }
      ],
      "examples": [
        "//@version=6// @description Math librarylibrary(\"num_methods\", overlay = true)// Calculate \"sinh()\" from the float parameter `x`export sinh(float x) =>    (math.exp(x) - math.exp(-x)) / 2.0plot(sinh(0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "fun_line": {
      "id": "fun_line",
      "name": "line",
      "description": "Casts na to line",
      "syntax": "line(x) → series line",
      "arguments": [
        {
          "name": "x",
          "type": "series line",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_line.copy": {
      "id": "fun_line.copy",
      "name": "line.copy",
      "description": "Clones the line object.",
      "syntax": "line.copy(id) → series line",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [
        "//@version=6indicator('Last 100 bars price range', overlay = true)LOOKBACK = 100highest = ta.highest(LOOKBACK)lowest = ta.lowest(LOOKBACK)if barstate.islastconfirmedhistory    var lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)    var lineBottom = line.copy(lineTop)    line.set_y1(lineBottom, lowest)    line.set_y2(lineBottom, lowest)    line.set_color(lineBottom, color.red)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.delete",
          "href": "fun_line.delete"
        }
      ]
    },
    "fun_line.delete": {
      "id": "fun_line.delete",
      "name": "line.delete",
      "description": "Deletes the specified line object. If it has\n                        already been deleted, does nothing.",
      "syntax": "line.delete(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.get_price": {
      "id": "fun_line.get_price",
      "name": "line.get_price",
      "description": "Returns the price level of a line at a given bar\n                        index.",
      "syntax": "line.get_price(id, x) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "Bar"
        }
      ],
      "examples": [
        "//@version=6indicator(\"GetPrice\", overlay=true)var line l = naif bar_index == 10    l := line.new(0, high[5], bar_index, high)plot(line.get_price(l, bar_index), color=color.green)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.get_x1": {
      "id": "fun_line.get_x1",
      "name": "line.get_x1",
      "description": "Returns UNIX time or bar index (depending on the\n                        last xloc value set) of the first point of the line.",
      "syntax": "line.get_x1(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [
        "//@version=6indicator(\"line.get_x1\")my_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)a = line.get_x1(my_line)plot(time - line.get_x1(my_line)) //draws zero plot"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.get_x2": {
      "id": "fun_line.get_x2",
      "name": "line.get_x2",
      "description": "Returns UNIX time or bar index (depending on the\n                        last xloc value set) of the second point of the line.",
      "syntax": "line.get_x2(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.get_y1": {
      "id": "fun_line.get_y1",
      "name": "line.get_y1",
      "description": "Returns price of the first point of the line.",
      "syntax": "line.get_y1(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.get_y2": {
      "id": "fun_line.get_y2",
      "name": "line.get_y2",
      "description": "Returns price of the second point of the line.",
      "syntax": "line.get_y2(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.new": {
      "id": "fun_line.new",
      "name": "line.new",
      "description": "Creates new line object.",
      "syntax": "line.new(first_point, second_point, xloc, extend, color, style, width, force_overlay) → series line",
      "arguments": [
        {
          "name": "first_point",
          "type": "chart.point",
          "description": "A"
        },
        {
          "name": "second_point",
          "type": "chart.point",
          "description": "A"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "See"
        },
        {
          "name": "extend",
          "type": "series string",
          "description": "If"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Line"
        },
        {
          "name": "style",
          "type": "series string",
          "description": "Line"
        },
        {
          "name": "width",
          "type": "series int",
          "description": "Line"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"line.new\")var line1 = line.new(0, low, bar_index, high, extend=extend.right)var line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)line.set_x2(line1, 0)line.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)line.set_color(line2, color.green)line.set_width(line2, 5)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "line.delete",
          "href": "fun_line.delete"
        },
        {
          "name": "line.set_x1",
          "href": "fun_line.set_x1"
        },
        {
          "name": "line.set_y1",
          "href": "fun_line.set_y1"
        },
        {
          "name": "line.set_xy1",
          "href": "fun_line.set_xy1"
        },
        {
          "name": "line.set_x2",
          "href": "fun_line.set_x2"
        },
        {
          "name": "line.set_y2",
          "href": "fun_line.set_y2"
        },
        {
          "name": "line.set_xy2",
          "href": "fun_line.set_xy2"
        },
        {
          "name": "line.set_xloc",
          "href": "fun_line.set_xloc"
        },
        {
          "name": "line.set_color",
          "href": "fun_line.set_color"
        },
        {
          "name": "line.set_extend",
          "href": "fun_line.set_extend"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.set_width",
          "href": "fun_line.set_width"
        }
      ]
    },
    "fun_line.set_color": {
      "id": "fun_line.set_color",
      "name": "line.set_color",
      "description": "Sets the line color",
      "syntax": "line.set_color(id, color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_extend": {
      "id": "fun_line.set_extend",
      "name": "line.set_extend",
      "description": "Sets extending type of this line object. If\n                        extend=extend.none,\n                        draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to extend.right\n                        or extend.left, draws a ray starting at point (x1, y1) or\n                        (x2, y2), respectively. If extend=extend.both, draws a\n                        straight line that goes through these points.",
      "syntax": "line.set_extend(id, extend) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "extend",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "extend.none",
          "href": "const_extend.none"
        },
        {
          "name": "extend.right",
          "href": "const_extend.right"
        },
        {
          "name": "extend.left",
          "href": "const_extend.left"
        },
        {
          "name": "extend.both",
          "href": "const_extend.both"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_first_point": {
      "id": "fun_line.set_first_point",
      "name": "line.set_first_point",
      "description": "Sets the first point of the id line\n                        to point.",
      "syntax": "line.set_first_point(id, point) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "A"
        },
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_line.set_second_point": {
      "id": "fun_line.set_second_point",
      "name": "line.set_second_point",
      "description": "Sets the second point of the id line\n                        to point.",
      "syntax": "line.set_second_point(id, point) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "A"
        },
        {
          "name": "point",
          "type": "chart.point",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_line.set_style": {
      "id": "fun_line.set_style",
      "name": "line.set_style",
      "description": "Sets the line style",
      "syntax": "line.set_style(id, style) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "style",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_width": {
      "id": "fun_line.set_width",
      "name": "line.set_width",
      "description": "Sets the line width.",
      "syntax": "line.set_width(id, width) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "width",
          "type": "series int",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_x1": {
      "id": "fun_line.set_x1",
      "name": "line.set_x1",
      "description": "Sets bar index or bar time (depending on the xloc)\n                        of the first point.",
      "syntax": "line.set_x1(id, x) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "Bar"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_x2": {
      "id": "fun_line.set_x2",
      "name": "line.set_x2",
      "description": "Sets bar index or bar time (depending on the xloc)\n                        of the second point.",
      "syntax": "line.set_x2(id, x) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "Bar"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_xloc": {
      "id": "fun_line.set_xloc",
      "name": "line.set_xloc",
      "description": "Sets x-location and new bar index/time values.",
      "syntax": "line.set_xloc(id, x1, x2, xloc) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x1",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "x2",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "New"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "xloc.bar_index",
          "href": "const_xloc.bar_index"
        },
        {
          "name": "xloc.bar_time",
          "href": "const_xloc.bar_time"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_xy1": {
      "id": "fun_line.set_xy1",
      "name": "line.set_xy1",
      "description": "Sets bar index/time and price of the first\n                        point.",
      "syntax": "line.set_xy1(id, x, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "Price."
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_xy2": {
      "id": "fun_line.set_xy2",
      "name": "line.set_xy2",
      "description": "Sets bar index/time and price of the second\n                        point",
      "syntax": "line.set_xy2(id, x, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "x",
          "type": "series int",
          "description": "Bar"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "Price."
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_y1": {
      "id": "fun_line.set_y1",
      "name": "line.set_y1",
      "description": "Sets price of the first point",
      "syntax": "line.set_y1(id, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "Price."
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_line.set_y2": {
      "id": "fun_line.set_y2",
      "name": "line.set_y2",
      "description": "Sets price of the second point.",
      "syntax": "line.set_y2(id, y) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series line",
          "description": "Line"
        },
        {
          "name": "y",
          "type": "series int/float",
          "description": "Price."
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "fun_linefill": {
      "id": "fun_linefill",
      "name": "linefill",
      "description": "Casts na to linefill.",
      "syntax": "linefill(x) → series linefill",
      "arguments": [
        {
          "name": "x",
          "type": "series linefill",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_linefill.delete": {
      "id": "fun_linefill.delete",
      "name": "linefill.delete",
      "description": "Deletes the specified linefill object. If it has\n                        already been deleted, does nothing.",
      "syntax": "linefill.delete(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series linefill",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_linefill.get_line1": {
      "id": "fun_linefill.get_line1",
      "name": "linefill.get_line1",
      "description": "Returns the ID of the first line used in the\n                        id linefill.",
      "syntax": "linefill.get_line1(id) → series line",
      "arguments": [
        {
          "name": "id",
          "type": "series linefill",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_linefill.get_line2": {
      "id": "fun_linefill.get_line2",
      "name": "linefill.get_line2",
      "description": "Returns the ID of the second line used in the\n                        id linefill.",
      "syntax": "linefill.get_line2(id) → series line",
      "arguments": [
        {
          "name": "id",
          "type": "series linefill",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_linefill.new": {
      "id": "fun_linefill.new",
      "name": "linefill.new",
      "description": "Creates a new linefill object and displays it on\n                        the chart, filling the space between line1 and line2 with the color\n                        specified in color.",
      "syntax": "linefill.new(line1, line2, color) → series linefill",
      "arguments": [
        {
          "name": "line1",
          "type": "series line",
          "description": "First"
        },
        {
          "name": "line2",
          "type": "series line",
          "description": "Second"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_linefill.set_color": {
      "id": "fun_linefill.set_color",
      "name": "linefill.set_color",
      "description": "The function sets the color of the linefill object\n                        passed to it.",
      "syntax": "linefill.set_color(id, color) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series linefill",
          "description": "A"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_log.error": {
      "id": "fun_log.error",
      "name": "log.error",
      "description": "Converts the formatting string and value(s) into a\n                        formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"error\" debug\n                        level.",
      "syntax": "log.error(message) → void",
      "arguments": [
        {
          "name": "message",
          "type": "series string",
          "description": "Log"
        }
      ],
      "examples": [
        "//@version=6strategy(\"My strategy\", overlay = true, process_orders_on_close = true)bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    limitLevel = close * 1.01    log.info(\"Long limit order has been placed at {0}\", limitLevel)    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)if strategy.opentrades > 10    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)last10Perc = strategy.initial_capital / 10 > strategy.equityif (last10Perc and not last10Perc[1])    log.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_log.info": {
      "id": "fun_log.info",
      "name": "log.info",
      "description": "Converts the formatting string and value(s) into a\n                        formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"info\" debug\n                        level.",
      "syntax": "log.info(message) → void",
      "arguments": [
        {
          "name": "message",
          "type": "series string",
          "description": "Log"
        }
      ],
      "examples": [
        "//@version=6strategy(\"My strategy\", overlay = true, process_orders_on_close = true)bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    limitLevel = close * 1.01    log.info(\"Long limit order has been placed at {0}\", limitLevel)    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)if strategy.opentrades > 10    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)last10Perc = strategy.initial_capital / 10 > strategy.equityif (last10Perc and not last10Perc[1])    log.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_log.warning": {
      "id": "fun_log.warning",
      "name": "log.warning",
      "description": "Converts the formatting string and value(s) into a\n                        formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"warning\" debug\n                        level.",
      "syntax": "log.warning(message) → void",
      "arguments": [
        {
          "name": "message",
          "type": "series string",
          "description": "Log"
        }
      ],
      "examples": [
        "//@version=6strategy(\"My strategy\", overlay = true, process_orders_on_close = true)bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    limitLevel = close * 1.01    log.info(\"Long limit order has been placed at {0}\", limitLevel)    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)if strategy.opentrades > 10    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)last10Perc = strategy.initial_capital / 10 > strategy.equityif (last10Perc and not last10Perc[1])    log.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_map.clear": {
      "id": "fun_map.clear",
      "name": "map.clear",
      "description": "Clears the map, removing all key-value pairs from\n                        it.",
      "syntax": "map.clear(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.clear example\")oddMap = map.new<int, bool>()oddMap.put(1, true)oddMap.put(2, false)oddMap.put(3, true)map.clear(oddMap)plot(oddMap.size())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put_all",
          "href": "fun_map.put_all"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.remove",
          "href": "fun_map.remove"
        }
      ]
    },
    "fun_map.contains": {
      "id": "fun_map.contains",
      "name": "map.contains",
      "description": "Returns true if the\n                        key was found in the id map, false\n                        otherwise.",
      "syntax": "map.contains(id, key) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        },
        {
          "name": "key",
          "type": "series <type of the map's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.includes example\")a = map.new<string, float>()a.put(\"open\", open)p = closeif map.contains(a, \"open\")    p := a.get(\"open\")plot(p)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.size",
          "href": "fun_map.size"
        }
      ]
    },
    "fun_map.copy": {
      "id": "fun_map.copy",
      "name": "map.copy",
      "description": "Creates a copy of an existing map.",
      "syntax": "map.copy(id) → map<keyType, valueType>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.copy example\")a = map.new<string, int>()a.put(\"example\", 1)b = map.copy(a)a := map.new<string, int>()a.put(\"example\", 2)plot(a.get(\"example\"))plot(b.get(\"example\"))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.get",
          "href": "fun_map.get"
        },
        {
          "name": "map.size",
          "href": "fun_map.size"
        }
      ]
    },
    "fun_map.get": {
      "id": "fun_map.get",
      "name": "map.get",
      "description": "Returns the value associated with the specified\n                        key in the id map.",
      "syntax": "map.get(id, key) → <value_type>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        },
        {
          "name": "key",
          "type": "series <type of the map's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.get example\")a = map.new<int, int>()size = 10for i = 0 to size    a.put(i, size-i)plot(map.get(a, 1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.contains",
          "href": "fun_map.contains"
        }
      ]
    },
    "fun_map.keys": {
      "id": "fun_map.keys",
      "name": "map.keys",
      "description": "Returns an array of all the keys in the\n                        id map. The resulting array is a copy and any changes to it are not reflected in\n                        the original map.",
      "syntax": "map.keys(id) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.keys example\")a = map.new<string, float>()a.put(\"open\", open)a.put(\"high\", high)a.put(\"low\", low)a.put(\"close\", close)keys = map.keys(a)ohlc = 0.0for key in keys    ohlc += a.get(key)plot(ohlc/4)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.get",
          "href": "fun_map.get"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.size",
          "href": "fun_map.size"
        }
      ]
    },
    "fun_map.new<type,type>": {
      "id": "fun_map.new<type,type>",
      "name": "map.new<type,type>",
      "description": "Creates a new map object: a collection that\n                        consists of key-value pairs, where all keys are of the keyType, and all values are\n                        of the valueType.",
      "syntax": "map.new<keyType, valueType>() → map<keyType, valueType>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"map.new<string, int> example\")a = map.new<string, int>()a.put(\"example\", 1)label.new(bar_index, close, str.tostring(a.get(\"example\")))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.get",
          "href": "fun_map.get"
        },
        {
          "name": "array.new<type>",
          "href": "fun_array.new<type>"
        }
      ]
    },
    "fun_map.put": {
      "id": "fun_map.put",
      "name": "map.put",
      "description": "Puts a new key-value pair into the id\n                        map.",
      "syntax": "map.put(id, key, value) → <value_type>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        },
        {
          "name": "key",
          "type": "series <type of the map's elements>",
          "description": "The"
        },
        {
          "name": "value",
          "type": "series <type of the map's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.put example\")a = map.new<string, float>()map.put(a, \"first\", 10)map.put(a, \"second\", 15)prevFirst = map.put(a, \"first\", 20)currFirst = a.get(\"first\")plot(prevFirst)plot(currFirst)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put_all",
          "href": "fun_map.put_all"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.remove",
          "href": "fun_map.remove"
        }
      ]
    },
    "fun_map.put_all": {
      "id": "fun_map.put_all",
      "name": "map.put_all",
      "description": "Puts all key-value pairs from the id2\n                        map into the id map.",
      "syntax": "map.put_all(id, id2) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        },
        {
          "name": "id2",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.put_all example\")a = map.new<string, float>()b = map.new<string, float>()a.put(\"first\", 10)a.put(\"second\", 15)b.put(\"third\", 20)map.put_all(a, b)plot(a.get(\"third\"))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.remove",
          "href": "fun_map.remove"
        }
      ]
    },
    "fun_map.remove": {
      "id": "fun_map.remove",
      "name": "map.remove",
      "description": "Removes a key-value pair from the id\n                        map.",
      "syntax": "map.remove(id, key) → <value_type>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        },
        {
          "name": "key",
          "type": "series <type of the map's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.remove example\")a = map.new<string, color>()a.put(\"firstColor\", color.green)oldColorValue = map.remove(a, \"firstColor\")plot(close, color = oldColorValue)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.clear",
          "href": "fun_map.clear"
        }
      ]
    },
    "fun_map.size": {
      "id": "fun_map.size",
      "name": "map.size",
      "description": "Returns the number of key-value pairs in the\n                        id map.",
      "syntax": "map.size(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.size example\")a = map.new<int, int>()size = 10for i = 0 to size    a.put(i, size-i)plot(map.size(a))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.values",
          "href": "fun_map.values"
        },
        {
          "name": "map.get",
          "href": "fun_map.get"
        }
      ]
    },
    "fun_map.values": {
      "id": "fun_map.values",
      "name": "map.values",
      "description": "Returns an array of all the values in the\n                        id map. The resulting array is a copy and any changes to it are not reflected in\n                        the original map.",
      "syntax": "map.values(id) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any map type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"map.values example\")a = map.new<string, float>()a.put(\"open\", open)a.put(\"high\", high)a.put(\"low\", low)a.put(\"close\", close)values = map.values(a)ohlc = 0.0for value in values    ohlc += valueplot(ohlc/4)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        },
        {
          "name": "map.put",
          "href": "fun_map.put"
        },
        {
          "name": "map.get",
          "href": "fun_map.get"
        },
        {
          "name": "map.keys",
          "href": "fun_map.keys"
        },
        {
          "name": "map.size",
          "href": "fun_map.size"
        }
      ]
    },
    "fun_math.abs": {
      "id": "fun_math.abs",
      "name": "math.abs",
      "description": "Absolute value of number is number\n                        if number >= 0, or -number otherwise.",
      "syntax": "math.abs(number) → const int",
      "arguments": [
        {
          "name": "number",
          "type": "const int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.acos": {
      "id": "fun_math.acos",
      "name": "math.acos",
      "description": "The acos function returns the arccosine (in\n                        radians) of number such that cos(acos(y)) = y for y in range [-1, 1].",
      "syntax": "math.acos(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.asin": {
      "id": "fun_math.asin",
      "name": "math.asin",
      "description": "The asin function returns the arcsine (in radians)\n                        of number such that sin(asin(y)) = y for y in range [-1, 1].",
      "syntax": "math.asin(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.atan": {
      "id": "fun_math.atan",
      "name": "math.atan",
      "description": "The atan function returns the arctangent (in\n                        radians) of number such that tan(atan(y)) = y for any y.",
      "syntax": "math.atan(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.avg": {
      "id": "fun_math.avg",
      "name": "math.avg",
      "description": "Calculates average of all given series\n                        (elementwise).",
      "syntax": "math.avg(number0, number1, ...) → simple float",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.sum",
          "href": "fun_math.sum"
        },
        {
          "name": "ta.cum",
          "href": "fun_ta.cum"
        },
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        }
      ]
    },
    "fun_math.ceil": {
      "id": "fun_math.ceil",
      "name": "math.ceil",
      "description": "Rounds the specified number up to the\n                        smallest whole number (\"int\" value) that is greater than or equal to it.",
      "syntax": "math.ceil(number) → const int",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.floor",
          "href": "fun_math.floor"
        },
        {
          "name": "math.round",
          "href": "fun_math.round"
        }
      ]
    },
    "fun_math.cos": {
      "id": "fun_math.cos",
      "name": "math.cos",
      "description": "The cos function returns the trigonometric cosine\n                        of an angle.",
      "syntax": "math.cos(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "Angle,"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.exp": {
      "id": "fun_math.exp",
      "name": "math.exp",
      "description": "The exp function of number is e\n                        raised to the power of number, where e is Euler's number.",
      "syntax": "math.exp(number) → const float",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.pow",
          "href": "fun_math.pow"
        }
      ]
    },
    "fun_math.floor": {
      "id": "fun_math.floor",
      "name": "math.floor",
      "description": "Rounds the specified number down to\n                        the largest whole number (\"int\" value) that is less than or equal to it.",
      "syntax": "math.floor(number) → const int",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.ceil",
          "href": "fun_math.ceil"
        },
        {
          "name": "math.round",
          "href": "fun_math.round"
        }
      ]
    },
    "fun_math.log": {
      "id": "fun_math.log",
      "name": "math.log",
      "description": "Natural logarithm of any number >\n                        0 is the unique y such that e^y = number.",
      "syntax": "math.log(number) → const float",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.log10",
          "href": "fun_math.log10"
        }
      ]
    },
    "fun_math.log10": {
      "id": "fun_math.log10",
      "name": "math.log10",
      "description": "The common (or base 10) logarithm of\n                        number is the power to which 10 must be raised to obtain the number.\n                        10^y = number.",
      "syntax": "math.log10(number) → const float",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.log",
          "href": "fun_math.log"
        }
      ]
    },
    "fun_math.max": {
      "id": "fun_math.max",
      "name": "math.max",
      "description": "Returns the greatest of multiple values.",
      "syntax": "math.max(number0, number1, ...) → const int",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"math.max\", overlay=true)plot(math.max(close, open))plot(math.max(close, math.max(open, 42)))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "math.min",
          "href": "fun_math.min"
        }
      ]
    },
    "fun_math.min": {
      "id": "fun_math.min",
      "name": "math.min",
      "description": "Returns the smallest of multiple values.",
      "syntax": "math.min(number0, number1, ...) → const int",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"math.min\", overlay=true)plot(math.min(close, open))plot(math.min(close, math.min(open, 42)))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "math.max",
          "href": "fun_math.max"
        }
      ]
    },
    "fun_math.pow": {
      "id": "fun_math.pow",
      "name": "math.pow",
      "description": "Mathematical power function.",
      "syntax": "math.pow(base, exponent) → const float",
      "arguments": [
        {
          "name": "base",
          "type": "const int/float",
          "description": "Specify"
        },
        {
          "name": "exponent",
          "type": "const int/float",
          "description": "Specifies"
        }
      ],
      "examples": [
        "//@version=6indicator(\"math.pow\", overlay=true)plot(math.pow(close, 2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "math.sqrt",
          "href": "fun_math.sqrt"
        },
        {
          "name": "math.exp",
          "href": "fun_math.exp"
        }
      ]
    },
    "fun_math.random": {
      "id": "fun_math.random",
      "name": "math.random",
      "description": "Returns a pseudo-random value. The function will\n                        generate a different sequence of values for each script execution. Using the same value for the\n                        optional seed argument will produce a repeatable sequence.",
      "syntax": "math.random(min, max, seed) → series float",
      "arguments": [
        {
          "name": "min",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "max",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "seed",
          "type": "series int",
          "description": "Optional"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.round": {
      "id": "fun_math.round",
      "name": "math.round",
      "description": "Returns the value of number rounded\n                        to the nearest integer, with ties rounding up. If the precision parameter is used,\n                        returns a float value rounded to that amount of decimal places.",
      "syntax": "math.round(number) → const int",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.ceil",
          "href": "fun_math.ceil"
        },
        {
          "name": "math.floor",
          "href": "fun_math.floor"
        }
      ]
    },
    "fun_math.round_to_mintick": {
      "id": "fun_math.round_to_mintick",
      "name": "math.round_to_mintick",
      "description": "Returns the value rounded to the symbol's mintick,\n                        i.e. the nearest value that can be divided by syminfo.mintick,\n                        without the remainder, with ties rounding up.",
      "syntax": "math.round_to_mintick(number) → simple float",
      "arguments": [
        {
          "name": "number",
          "type": "simple int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.ceil",
          "href": "fun_math.ceil"
        },
        {
          "name": "math.floor",
          "href": "fun_math.floor"
        }
      ]
    },
    "fun_math.sign": {
      "id": "fun_math.sign",
      "name": "math.sign",
      "description": "Sign (signum) of number is zero if\n                        number is zero, 1.0 if number is greater than zero, -1.0 if number\n                        is less than zero.",
      "syntax": "math.sign(number) → const float",
      "arguments": [
        {
          "name": "Sign",
          "type": "signum",
          "description": "of number is zero if"
        },
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.sin": {
      "id": "fun_math.sin",
      "name": "math.sin",
      "description": "The sin function returns the trigonometric sine of\n                        an angle.",
      "syntax": "math.sin(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "Angle,"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.sqrt": {
      "id": "fun_math.sqrt",
      "name": "math.sqrt",
      "description": "Square root of any number >= 0 is\n                        the unique y >= 0 such that y^2 = number.",
      "syntax": "math.sqrt(number) → const float",
      "arguments": [
        {
          "name": "number",
          "type": "const int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.pow",
          "href": "fun_math.pow"
        }
      ]
    },
    "fun_math.sum": {
      "id": "fun_math.sum",
      "name": "math.sum",
      "description": "The sum function returns the sliding sum of last y\n                        values of x.",
      "syntax": "math.sum(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.cum",
          "href": "fun_ta.cum"
        },
        {
          "name": "for",
          "href": "kw_for"
        }
      ]
    },
    "fun_math.tan": {
      "id": "fun_math.tan",
      "name": "math.tan",
      "description": "The tan function returns the trigonometric tangent\n                        of an angle.",
      "syntax": "math.tan(angle) → const float",
      "arguments": [
        {
          "name": "angle",
          "type": "const int/float",
          "description": "Angle,"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.todegrees": {
      "id": "fun_math.todegrees",
      "name": "math.todegrees",
      "description": "Returns an approximately equivalent angle in\n                        degrees from an angle measured in radians.",
      "syntax": "math.todegrees(radians) → series float",
      "arguments": [
        {
          "name": "radians",
          "type": "series int/float",
          "description": "Angle"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_math.toradians": {
      "id": "fun_math.toradians",
      "name": "math.toradians",
      "description": "Returns an approximately equivalent angle in\n                        radians from an angle measured in degrees.",
      "syntax": "math.toradians(degrees) → series float",
      "arguments": [
        {
          "name": "degrees",
          "type": "series int/float",
          "description": "Angle"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_matrix.add_col": {
      "id": "fun_matrix.add_col",
      "name": "matrix.add_col",
      "description": "The function adds a column at the\n                        column index of the id matrix. The column can consist of\n                        na values, or an array can be used to provide values.",
      "syntax": "matrix.add_col(id, column) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.add_col()` Example 1\")// Create a 2x3 \"int\" matrix containing values `0`.m = matrix.new<int>(2, 3, 0)// Add a column with `na` values to the matrix.matrix.add_col(m)// Display matrix elements.if barstate.islastconfirmedhistory    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m))",
        "//@version=6indicator(\"`matrix.add_col()` Example 2\")if barstate.islastconfirmedhistory    // Create an empty matrix object.     var m = matrix.new<int>()        // Create an array with values `1` and `3`.    var a = array.from(1, 3)        // Add the `a` array as the first column of the empty matrix.    matrix.add_col(m, 0, a)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        },
        {
          "name": "matrix.add_row",
          "href": "fun_matrix.add_row"
        }
      ]
    },
    "fun_matrix.add_row": {
      "id": "fun_matrix.add_row",
      "name": "matrix.add_row",
      "description": "The function adds a row at the row\n                        index of the id matrix. The row can consist of na values, or an array\n                        can be used to provide values.",
      "syntax": "matrix.add_row(id, row) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.add_row()` Example 1\")// Create a 2x3 \"int\" matrix containing values `0`.m = matrix.new<int>(2, 3, 0)// Add a row with `na` values to the matrix.matrix.add_row(m)// Display matrix elements.if barstate.islastconfirmedhistory    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m))",
        "//@version=6indicator(\"`matrix.add_row()` Example 2\")if barstate.islastconfirmedhistory    // Create an empty matrix object.     var m = matrix.new<int>()        // Create an array with values `1` and `2`.    var a = array.from(1, 2)        // Add the `a` array as the first row of the empty matrix.    matrix.add_row(m, 0, a)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        },
        {
          "name": "matrix.add_col",
          "href": "fun_matrix.add_col"
        }
      ]
    },
    "fun_matrix.avg": {
      "id": "fun_matrix.avg",
      "name": "matrix.avg",
      "description": "The function calculates the average of all\n                        elements in the matrix.",
      "syntax": "matrix.avg(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.avg()` Example\")// Create a 2x2 matrix.var m = matrix.new<int>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0, 1)matrix.set(m, 0, 1, 2)matrix.set(m, 1, 0, 3)matrix.set(m, 1, 1, 4)// Get the average value of the matrix.var x = matrix.avg(m)plot(x, 'Matrix average value')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.col": {
      "id": "fun_matrix.col",
      "name": "matrix.col",
      "description": "The function creates a one-dimensional array from\n                        the elements of a matrix column.",
      "syntax": "matrix.col(id, column) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.col()` Example\", \"\", true)// Create a 2x3 \"float\" matrix from `hlc3` values.m = matrix.new<float>(2, 3, hlc3)// Return an array with the values of the first column of matrix `m`.a = matrix.col(m, 0)// Plot the first value from the array `a`.plot(array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "matrix.col",
          "href": "fun_matrix.col"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        }
      ]
    },
    "fun_matrix.columns": {
      "id": "fun_matrix.columns",
      "name": "matrix.columns",
      "description": "The function returns the number of columns in the\n                        matrix.",
      "syntax": "matrix.columns(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.columns()` Example\")// Create a 2x6 matrix with values `0`.var m = matrix.new<int>(2, 6, 0)// Get the quantity of columns in matrix `m`.var x = matrix.columns(m)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.col",
          "href": "fun_matrix.col"
        },
        {
          "name": "matrix.row",
          "href": "fun_matrix.row"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.concat": {
      "id": "fun_matrix.concat",
      "name": "matrix.concat",
      "description": "The function appends the m2 matrix to\n                        the m1 matrix.",
      "syntax": "matrix.concat(id1, id2) → matrix<type>",
      "arguments": [
        {
          "name": "id1",
          "type": "any matrix type",
          "description": "Matrix"
        },
        {
          "name": "id2",
          "type": "any matrix type",
          "description": "Matrix"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.concat()` Example\")// Create a 2x4 \"int\" matrix containing values `0`.m1 = matrix.new<int>(2, 4, 0)// Create a 2x4 \"int\" matrix containing values `1`.m2 = matrix.new<int>(2, 4, 1)// Append matrix `m2` to `m1`.matrix.concat(m1, m2)// Display matrix elements.if barstate.islastconfirmedhistory    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix Elements:\")    table.cell(t, 0, 1, str.tostring(m1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.copy": {
      "id": "fun_matrix.copy",
      "name": "matrix.copy",
      "description": "The function creates a new matrix which is a copy\n                        of the original.",
      "syntax": "matrix.copy(id) → matrix<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.copy()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 \"float\" matrix with `1` values.    var m1 = matrix.new<float>(2, 3, 1)        // Copy the matrix to a new one.    // Note that unlike what `matrix.copy()` does,     // the simple assignment operation `m2 = m1`    // would NOT create a new copy of the `m1` matrix.    // It would merely create a copy of its ID referencing the same matrix.    var m2 = matrix.copy(m1)        // Display using a table.    var t = table.new(position.top_right, 5, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Matrix Copy:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.det": {
      "id": "fun_matrix.det",
      "name": "matrix.det",
      "description": "The function returns the determinant of a square\n                        matrix.",
      "syntax": "matrix.det(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.det` Example\")// Create a 2x2 matrix.var m = matrix.new<float>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0,  3)matrix.set(m, 0, 1,  7)matrix.set(m, 1, 0,  1)matrix.set(m, 1, 1, -4)// Get the determinant of the matrix. var x = matrix.det(m)plot(x, 'Matrix determinant')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        }
      ]
    },
    "fun_matrix.diff": {
      "id": "fun_matrix.diff",
      "name": "matrix.diff",
      "description": "The function returns a new matrix resulting from\n                        the subtraction between matrices id1 and id2, or of matrix\n                        id1 and an id2 scalar (a numerical value).",
      "syntax": "matrix.diff(id1, id2) → matrix<int>",
      "arguments": [
        {
          "name": "id1",
          "type": "matrix<int>",
          "description": "Matrix"
        },
        {
          "name": "id2",
          "type": "series int/float/matrix<int>",
          "description": "Matrix"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.diff()` Example 1\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix containing values `5`.    var m1 = matrix.new<float>(2, 3, 5)     // Create a 2x3 matrix containing values `4`.    var m2 = matrix.new<float>(2, 3, 4)     // Create a new matrix containing the difference between matrices `m1` and `m2`.    var m3 = matrix.diff(m1, m2)         // Display using a table.    var t = table.new(position.top_right, 1, 2, color.green)    table.cell(t, 0, 0, \"Difference between two matrices:\")    table.cell(t, 0, 1, str.tostring(m3))",
        "//@version=6indicator(\"`matrix.diff()` Example 2\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix with values `4`.    var m1 = matrix.new<float>(2, 3, 4)        // Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.    var m2 = matrix.diff(m1, 1)        // Display using a table.    var t = table.new(position.top_right, 1, 2, color.green)    table.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")    table.cell(t, 0, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.eigenvalues": {
      "id": "fun_matrix.eigenvalues",
      "name": "matrix.eigenvalues",
      "description": "The function returns an array containing the eigenvalues\n                        of a square matrix.",
      "syntax": "matrix.eigenvalues(id) → array<float>",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.eigenvalues()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 2)    matrix.set(m1, 0, 1, 4)    matrix.set(m1, 1, 0, 6)    matrix.set(m1, 1, 1, 8)        // Get the eigenvalues of the matrix.    tr = matrix.eigenvalues(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Array of Eigenvalues:\")    table.cell(t, 1, 1, str.tostring(tr))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.eigenvectors",
          "href": "fun_matrix.eigenvectors"
        }
      ]
    },
    "fun_matrix.eigenvectors": {
      "id": "fun_matrix.eigenvectors",
      "name": "matrix.eigenvectors",
      "description": "Returns a matrix of eigenvectors,\n                        in which each column is an eigenvector of the id matrix.",
      "syntax": "matrix.eigenvectors(id) → matrix<float>",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.eigenvectors()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix     var m1 = matrix.new<int>(2, 2, 1)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 2)    matrix.set(m1, 0, 1, 4)    matrix.set(m1, 1, 0, 6)    matrix.set(m1, 1, 1, 8)        // Get the eigenvectors of the matrix.    m2 = matrix.eigenvectors(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix Elements:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Matrix Eigenvectors:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.eigenvalues",
          "href": "fun_matrix.eigenvalues"
        }
      ]
    },
    "fun_matrix.elements_count": {
      "id": "fun_matrix.elements_count",
      "name": "matrix.elements_count",
      "description": "The function returns the total number of all\n                        matrix elements.",
      "syntax": "matrix.elements_count(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.fill": {
      "id": "fun_matrix.fill",
      "name": "matrix.fill",
      "description": "The function fills a rectangular area of the\n                        id matrix defined by the indices from_column to to_column\n                        (not including it) and from_row to to_row(not including it) with the\n                        value.",
      "syntax": "matrix.fill(id, value, from_row, to_row, from_column, to_column) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "value",
          "type": "series <type of the matrix's elements>",
          "description": "The"
        },
        {
          "name": "from_row",
          "type": "series int",
          "description": "Row"
        },
        {
          "name": "to_row",
          "type": "series int",
          "description": "Row"
        },
        {
          "name": "from_column",
          "type": "series int",
          "description": "Column"
        },
        {
          "name": "to_column",
          "type": "series int",
          "description": "Column"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.fill()` Example\")// Create a 4x5 \"int\" matrix containing values `0`.m = matrix.new<float>(4, 5, 0)// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.matrix.fill(m, hl2, 0, 2, 1, 3)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.get": {
      "id": "fun_matrix.get",
      "name": "matrix.get",
      "description": "The function returns the element with the\n                        specified index of the matrix.",
      "syntax": "matrix.get(id, row, column) → <matrix_type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.get()` Example\", \"\", true)// Create a 2x3 \"float\" matrix from the `hl2` values.m = matrix.new<float>(2, 3, hl2)// Return the value of the element at index [0, 0] of matrix `m`.x = matrix.get(m, 0, 0)plot(x)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.inv": {
      "id": "fun_matrix.inv",
      "name": "matrix.inv",
      "description": "The function returns the inverse of a\n                        square matrix.",
      "syntax": "matrix.inv(id) → matrix<float>",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.inv()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Inverse of the matrix.    var m2 = matrix.inv(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Inverse matrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.pinv",
          "href": "fun_matrix.pinv"
        },
        {
          "name": "matrix.copy",
          "href": "fun_matrix.copy"
        },
        {
          "name": "str.tostring",
          "href": "fun_str.tostring"
        }
      ]
    },
    "fun_matrix.is_antidiagonal": {
      "id": "fun_matrix.is_antidiagonal",
      "name": "matrix.is_antidiagonal",
      "description": "The function determines if the matrix is anti-diagonal\n                        (all elements outside the secondary diagonal are zero).",
      "syntax": "matrix.is_antidiagonal(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        },
        {
          "name": "matrix.is_identity",
          "href": "fun_matrix.is_identity"
        },
        {
          "name": "matrix.is_diagonal",
          "href": "fun_matrix.is_diagonal"
        }
      ]
    },
    "fun_matrix.is_antisymmetric": {
      "id": "fun_matrix.is_antisymmetric",
      "name": "matrix.is_antisymmetric",
      "description": "The function determines if a matrix is antisymmetric\n                        (its transpose equals its\n                        negative).",
      "syntax": "matrix.is_antisymmetric(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        }
      ]
    },
    "fun_matrix.is_binary": {
      "id": "fun_matrix.is_binary",
      "name": "matrix.is_binary",
      "description": "The function determines if the matrix is binary (when all\n                        elements of the matrix are 0 or 1).",
      "syntax": "matrix.is_binary(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        }
      ]
    },
    "fun_matrix.is_diagonal": {
      "id": "fun_matrix.is_diagonal",
      "name": "matrix.is_diagonal",
      "description": "The function determines if the matrix is diagonal (all\n                        elements outside the main diagonal are zero).",
      "syntax": "matrix.is_diagonal(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        },
        {
          "name": "matrix.is_identity",
          "href": "fun_matrix.is_identity"
        },
        {
          "name": "matrix.is_antidiagonal",
          "href": "fun_matrix.is_antidiagonal"
        }
      ]
    },
    "fun_matrix.is_identity": {
      "id": "fun_matrix.is_identity",
      "name": "matrix.is_identity",
      "description": "The function determines if a matrix is an identity matrix\n                        (elements with ones on the main diagonal and zeros elsewhere).",
      "syntax": "matrix.is_identity(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        },
        {
          "name": "matrix.is_diagonal",
          "href": "fun_matrix.is_diagonal"
        }
      ]
    },
    "fun_matrix.is_square": {
      "id": "fun_matrix.is_square",
      "name": "matrix.is_square",
      "description": "The function determines if the matrix is square (it has the\n                        same number of rows and columns).",
      "syntax": "matrix.is_square(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.is_stochastic": {
      "id": "fun_matrix.is_stochastic",
      "name": "matrix.is_stochastic",
      "description": "The function determines if the matrix is stochastic.",
      "syntax": "matrix.is_stochastic(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        }
      ]
    },
    "fun_matrix.is_symmetric": {
      "id": "fun_matrix.is_symmetric",
      "name": "matrix.is_symmetric",
      "description": "The function determines if a square matrix is symmetric\n                        (elements are symmetric with respect to the main diagonal).",
      "syntax": "matrix.is_symmetric(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        }
      ]
    },
    "fun_matrix.is_triangular": {
      "id": "fun_matrix.is_triangular",
      "name": "matrix.is_triangular",
      "description": "The function determines if the matrix is triangular (if\n                        all elements above or below the main diagonal are zero).",
      "syntax": "matrix.is_triangular(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.is_square",
          "href": "fun_matrix.is_square"
        }
      ]
    },
    "fun_matrix.is_zero": {
      "id": "fun_matrix.is_zero",
      "name": "matrix.is_zero",
      "description": "The function determines if all elements of the\n                        matrix are zero.",
      "syntax": "matrix.is_zero(id) → series bool",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "Matrix"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        }
      ]
    },
    "fun_matrix.kron": {
      "id": "fun_matrix.kron",
      "name": "matrix.kron",
      "description": "The function returns the Kronecker product\n                        for the id1 and id2 matrices.",
      "syntax": "matrix.kron(id1, id2) → matrix<float>",
      "arguments": [
        {
          "name": "id1",
          "type": "matrix<int/float>",
          "description": "First"
        },
        {
          "name": "id2",
          "type": "matrix<int/float>",
          "description": "Second"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.kron()` Example\")// Display using a table.if barstate.islastconfirmedhistory    // Create two matrices with default values `1` and `2`.     var m1 = matrix.new<float>(2, 2, 1)     var m2 = matrix.new<float>(2, 2, 2)         // Calculate the Kronecker product of the matrices.    var m3 = matrix.kron(m1, m2)         // Display matrix elements.    var t = table.new(position.top_right, 5, 2, color.green)    table.cell(t, 0, 0, \"Matrix 1:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 1, \"⊗\")    table.cell(t, 2, 0, \"Matrix 2:\")    table.cell(t, 2, 1, str.tostring(m2))    table.cell(t, 3, 1, \"=\")    table.cell(t, 4, 0, \"Kronecker product:\")    table.cell(t, 4, 1, str.tostring(m3))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.mult",
          "href": "fun_matrix.mult"
        },
        {
          "name": "str.tostring",
          "href": "fun_str.tostring"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        }
      ]
    },
    "fun_matrix.max": {
      "id": "fun_matrix.max",
      "name": "matrix.max",
      "description": "The function returns the largest value from the\n                        matrix elements.",
      "syntax": "matrix.max(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.max()` Example\")// Create a 2x2 matrix.var m = matrix.new<int>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0, 1)matrix.set(m, 0, 1, 2)matrix.set(m, 1, 0, 3)matrix.set(m, 1, 1, 4)// Get the maximum value in the matrix.var x = matrix.max(m)plot(x, 'Matrix maximum value')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.min",
          "href": "fun_matrix.min"
        },
        {
          "name": "matrix.avg",
          "href": "fun_matrix.avg"
        },
        {
          "name": "matrix.sort",
          "href": "fun_matrix.sort"
        }
      ]
    },
    "fun_matrix.median": {
      "id": "fun_matrix.median",
      "name": "matrix.median",
      "description": "The function calculates the median (\"the middle\" value)\n                        of matrix elements.",
      "syntax": "matrix.median(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.median()` Example\")// Create a 2x2 matrix.m = matrix.new<int>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0, 1)matrix.set(m, 0, 1, 2)matrix.set(m, 1, 0, 3)matrix.set(m, 1, 1, 4)// Get the median of the matrix.x = matrix.median(m)plot(x, 'Median of the matrix')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.mode",
          "href": "fun_matrix.mode"
        },
        {
          "name": "matrix.sort",
          "href": "fun_matrix.sort"
        },
        {
          "name": "matrix.avg",
          "href": "fun_matrix.avg"
        }
      ]
    },
    "fun_matrix.min": {
      "id": "fun_matrix.min",
      "name": "matrix.min",
      "description": "The function returns the smallest value from the\n                        matrix elements.",
      "syntax": "matrix.min(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.min()` Example\")// Create a 2x2 matrix.var m = matrix.new<int>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0, 1)matrix.set(m, 0, 1, 2)matrix.set(m, 1, 0, 3)matrix.set(m, 1, 1, 4)// Get the minimum value from the matrix.var x = matrix.min(m)plot(x, 'Matrix minimum value')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.max",
          "href": "fun_matrix.max"
        },
        {
          "name": "matrix.avg",
          "href": "fun_matrix.avg"
        },
        {
          "name": "matrix.sort",
          "href": "fun_matrix.sort"
        }
      ]
    },
    "fun_matrix.mode": {
      "id": "fun_matrix.mode",
      "name": "matrix.mode",
      "description": "The function calculates the mode of the\n                        matrix, which is the most frequently occurring value from the matrix elements. When there are\n                        multiple values occurring equally frequently, the function returns the smallest of those values.",
      "syntax": "matrix.mode(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.mode()` Example\")// Create a 2x2 matrix.var m = matrix.new<int>(2, 2, na)// Fill the matrix with values.matrix.set(m, 0, 0, 0)matrix.set(m, 0, 1, 0)matrix.set(m, 1, 0, 1)matrix.set(m, 1, 1, 1)// Get the mode of the matrix.var x = matrix.mode(m)plot(x, 'Mode of the matrix')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.median",
          "href": "fun_matrix.median"
        },
        {
          "name": "matrix.sort",
          "href": "fun_matrix.sort"
        },
        {
          "name": "matrix.avg",
          "href": "fun_matrix.avg"
        }
      ]
    },
    "fun_matrix.mult": {
      "id": "fun_matrix.mult",
      "name": "matrix.mult",
      "description": "The function returns a new matrix resulting from\n                        the product\n                        between the matrices id1 and id2, or between an id1\n                        matrix and an id2 scalar (a numerical value), or between an id1 matrix\n                        and an id2 vector (an array of values).",
      "syntax": "matrix.mult(id1, id2) → array<int>",
      "arguments": [
        {
          "name": "id1",
          "type": "matrix<int>",
          "description": "First"
        },
        {
          "name": "id2",
          "type": "array<int>",
          "description": "Second"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.mult()` Example 1\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 6x2 matrix containing values `5`.    var m1 = matrix.new<float>(6, 2, 5)     // Create a 2x3 matrix containing values `4`.    // Note that it must have the same quantity of rows as there are columns in the first matrix.    var m2 = matrix.new<float>(2, 3, 4)     // Create a new matrix from the multiplication of the two matrices.    var m3 = matrix.mult(m1, m2)         // Display using a table.    var t = table.new(position.top_right, 1, 2, color.green)    table.cell(t, 0, 0, \"Product of two matrices:\")    table.cell(t, 0, 1, str.tostring(m3))",
        "//@version=6indicator(\"`matrix.mult()` Example 2\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix containing values `4`.    var m1 = matrix.new<float>(2, 3, 4)         // Create a new matrix from the product of the two matrices.    scalar = 5    var m2 = matrix.mult(m1, scalar)         // Display using a table.    var t = table.new(position.top_right, 5, 2, color.green)    table.cell(t, 0, 0, \"Matrix 1:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 1, \"x\")    table.cell(t, 2, 0, \"Scalar:\")    table.cell(t, 2, 1, str.tostring(scalar))    table.cell(t, 3, 1, \"=\")    table.cell(t, 4, 0, \"Matrix 2:\")    table.cell(t, 4, 1, str.tostring(m2))",
        "//@version=6indicator(\"`matrix.mult()` Example 3\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix containing values `4`.    var m1 = matrix.new<int>(2, 3, 4)        // Create an array of three elements.    var int[] a = array.from(1, 1, 1)        // Create a new matrix containing the product of the `m1` matrix and the `a` array.    var m3 = matrix.mult(m1, a)         // Display using a table.    var t = table.new(position.top_right, 5, 2, color.green)    table.cell(t, 0, 0, \"Matrix 1:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 1, \"x\")    table.cell(t, 2, 0, \"Value:\")    table.cell(t, 2, 1, str.tostring(a, \" \"))    table.cell(t, 3, 1, \"=\")    table.cell(t, 4, 0, \"Matrix 3:\")    table.cell(t, 4, 1, str.tostring(m3))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.sum",
          "href": "fun_matrix.sum"
        },
        {
          "name": "matrix.diff",
          "href": "fun_matrix.diff"
        }
      ]
    },
    "fun_matrix.new<type>": {
      "id": "fun_matrix.new<type>",
      "name": "matrix.new<type>",
      "description": "The function creates a new matrix object. A matrix\n                        is a two-dimensional data structure containing rows and columns. All elements in the matrix must\n                        be of the type specified in the type template (\"<type>\").",
      "syntax": "matrix.new<type>(rows, columns, initial_value) → matrix<type>",
      "arguments": [
        {
          "name": "rows",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "columns",
          "type": "series int",
          "description": "Initial"
        },
        {
          "name": "initial_value",
          "type": "<matrix_type>",
          "description": "Initial"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.new<type>()` Example 1\")// Create a 2x3 (2 rows x 3 columns) \"int\" matrix with values zero.var m = matrix.new<int>(2, 3, 0)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m))",
        "//@version=6indicator(\"`matrix.new<type>()` Example 2\")// Function to create a matrix whose rows are filled with array values.matrixFromArray(int rows, int columns, array<float> data) =>    m = matrix.new<float>(rows, columns)    for i = 0 to rows <= 0 ? na : rows - 1        for j = 0 to columns <= 0 ? na : columns - 1            matrix.set(m, i, j, array.get(data, i * columns + j))    m    // Create a 3x3 matrix from an array of values.var m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m1))",
        "//@version=6indicator(\"`matrix.new<type>()` Example 3\")// Function to create a matrix from a text string.// Values in a row must be separated by a space. Each line is one row.matrixFromInputArea(stringOfValues) =>    var rowsArray = str.split(stringOfValues, \"\\n\")    var rows = array.size(rowsArray)    var cols = array.size(str.split(array.get(rowsArray, 0), \" \"))    var matrix = matrix.new<float>(rows, cols, na)     row = 0    for rowString in rowsArray        col = 0        values = str.split(rowString, \" \")        for val in values            matrix.set(matrix, row, col, str.tonumber(val))            col += 1        row += 1    matrixstringInput = input.text_area(\"1 2 3\\n4 5 6\\n7 8 9\")var m = matrixFromInputArea(stringInput)    // Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m))",
        "//@version=6indicator(\"`matrix.new<type>()` Example 4\")// Function to create a matrix with random values (0.0 to 1.0).matrixRandom(int rows, int columns)=>    result = matrix.new<float>(rows, columns)    for i = 0 to rows - 1        for j = 0 to columns - 1            matrix.set(result, i, j, math.random())    result// Create a 2x3 matrix with random values.var m = matrixRandom(2, 3)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.fill",
          "href": "fun_matrix.fill"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        },
        {
          "name": "array.new<type>",
          "href": "fun_array.new<type>"
        }
      ]
    },
    "fun_matrix.pinv": {
      "id": "fun_matrix.pinv",
      "name": "matrix.pinv",
      "description": "The function returns the pseudoinverse\n                        of a matrix.",
      "syntax": "matrix.pinv(id) → matrix<float>",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.pinv()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Pseudoinverse of the matrix.    var m2 = matrix.pinv(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Pseudoinverse matrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.inv",
          "href": "fun_matrix.inv"
        }
      ]
    },
    "fun_matrix.pow": {
      "id": "fun_matrix.pow",
      "name": "matrix.pow",
      "description": "The function calculates the product of the matrix\n                        by itself power times.",
      "syntax": "matrix.pow(id, power) → matrix<float>",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        },
        {
          "name": "power",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.pow()` Example\")// Display using a table.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, 2)    // Calculate the power of three of the matrix.    var m2 = matrix.pow(m1, 3)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Matrix³:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.mult",
          "href": "fun_matrix.mult"
        }
      ]
    },
    "fun_matrix.rank": {
      "id": "fun_matrix.rank",
      "name": "matrix.rank",
      "description": "The function calculates the rank of the\n                        matrix.",
      "syntax": "matrix.rank(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.rank()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Get the rank of the matrix.     r = matrix.rank(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Rank of the matrix:\")    table.cell(t, 1, 1, str.tostring(r))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "str.tostring",
          "href": "fun_str.tostring"
        }
      ]
    },
    "fun_matrix.remove_col": {
      "id": "fun_matrix.remove_col",
      "name": "matrix.remove_col",
      "description": "The function removes the column at\n                        column index of the id matrix and returns an array containing the\n                        removed column's values.",
      "syntax": "matrix.remove_col(id, column) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"matrix_remove_col\", overlay = true)// Create a 2x2 matrix with ones.var matrixOrig = matrix.new<int>(2, 2, 1)// Set values to the 'matrixOrig' matrix.matrix.set(matrixOrig, 0, 1, 2)matrix.set(matrixOrig, 1, 0, 3)matrix.set(matrixOrig, 1, 1, 4)// Create a copy of the 'matrixOrig' matrix.matrixCopy = matrix.copy(matrixOrig)// Remove the first column from the `matrixCopy` matrix.arr = matrix.remove_col(matrixCopy, 0)// Display matrix elements.if barstate.islastconfirmedhistory    var t = table.new(position.top_right, 3, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(matrixOrig))    table.cell(t, 1, 0, \"Removed Elements:\")    table.cell(t, 1, 1, str.tostring(arr))    table.cell(t, 2, 0, \"Result Matrix:\")    table.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.copy",
          "href": "fun_matrix.copy"
        },
        {
          "name": "matrix.remove_row",
          "href": "fun_matrix.remove_row"
        }
      ]
    },
    "fun_matrix.remove_row": {
      "id": "fun_matrix.remove_row",
      "name": "matrix.remove_row",
      "description": "The function removes the row at row\n                        index of the id matrix and returns an array containing the removed row's values.",
      "syntax": "matrix.remove_row(id, row) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"matrix_remove_row\", overlay = true)// Create a 2x2 \"int\" matrix containing values `1`.var matrixOrig = matrix.new<int>(2, 2, 1)// Set values to the 'matrixOrig' matrix.matrix.set(matrixOrig, 0, 1, 2)matrix.set(matrixOrig, 1, 0, 3)matrix.set(matrixOrig, 1, 1, 4)// Create a copy of the 'matrixOrig' matrix.matrixCopy = matrix.copy(matrixOrig)// Remove the first row from the matrix `matrixCopy`.arr = matrix.remove_row(matrixCopy, 0)// Display matrix elements.if barstate.islastconfirmedhistory    var t = table.new(position.top_right, 3, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(matrixOrig))    table.cell(t, 1, 0, \"Removed Elements:\")    table.cell(t, 1, 1, str.tostring(arr))    table.cell(t, 2, 0, \"Result Matrix:\")    table.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.copy",
          "href": "fun_matrix.copy"
        },
        {
          "name": "matrix.remove_col",
          "href": "fun_matrix.remove_col"
        }
      ]
    },
    "fun_matrix.reshape": {
      "id": "fun_matrix.reshape",
      "name": "matrix.reshape",
      "description": "The function rebuilds the id matrix\n                        to rows x cols dimensions.",
      "syntax": "matrix.reshape(id, rows, columns) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "rows",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "columns",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.reshape()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix.    var m1 = matrix.new<float>(2, 3)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 0, 2, 3)    matrix.set(m1, 1, 0, 4)    matrix.set(m1, 1, 1, 5)    matrix.set(m1, 1, 2, 6)        // Copy the matrix to a new one.    var m2 = matrix.copy(m1)        // Reshape the copy to a 3x2.    matrix.reshape(m2, 3, 2)        // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Reshaped matrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.add_row",
          "href": "fun_matrix.add_row"
        },
        {
          "name": "matrix.add_col",
          "href": "fun_matrix.add_col"
        }
      ]
    },
    "fun_matrix.reverse": {
      "id": "fun_matrix.reverse",
      "name": "matrix.reverse",
      "description": "The function reverses the order of rows and\n                        columns in the matrix id. The first row and first column become the last, and the\n                        last become the first.",
      "syntax": "matrix.reverse(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.reverse()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Copy the matrix to a new one.    var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Copy matrix elements to a new matrix.    var m2 = matrix.copy(m1)        // Reverse the `m2` copy of the original matrix.     matrix.reverse(m2)        // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Reversed matrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        },
        {
          "name": "matrix.reshape",
          "href": "fun_matrix.reshape"
        }
      ]
    },
    "fun_matrix.row": {
      "id": "fun_matrix.row",
      "name": "matrix.row",
      "description": "The function creates a one-dimensional array from\n                        the elements of a matrix row.",
      "syntax": "matrix.row(id, row) → array<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.row()` Example\", \"\", true)// Create a 2x3 \"float\" matrix from `hlc3` values.m = matrix.new<float>(2, 3, hlc3)// Return an array with the values of the first row of the matrix.a = matrix.row(m, 0)// Plot the first value from the array `a`.plot(array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "array.get",
          "href": "fun_array.get"
        },
        {
          "name": "matrix.col",
          "href": "fun_matrix.col"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.rows": {
      "id": "fun_matrix.rows",
      "name": "matrix.rows",
      "description": "The function returns the number of rows in the\n                        matrix.",
      "syntax": "matrix.rows(id) → series int",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.rows()` Example\")// Create a 2x6 matrix with values `0`.var m = matrix.new<int>(2, 6, 0)// Get the quantity of rows in the matrix.var x = matrix.rows(m)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.row",
          "href": "fun_matrix.row"
        }
      ]
    },
    "fun_matrix.set": {
      "id": "fun_matrix.set",
      "name": "matrix.set",
      "description": "The function assigns value to the\n                        element at the row and column of the id matrix.",
      "syntax": "matrix.set(id, row, column, value) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "value",
          "type": "series <type of the matrix's elements>",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.set()` Example\")// Create a 2x3 \"int\" matrix containing values `4`.m = matrix.new<int>(2, 3, 4)// Replace the value of element at row 1 and column 2 with value `3`.matrix.set(m, 0, 1, 3)// Display using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.sort": {
      "id": "fun_matrix.sort",
      "name": "matrix.sort",
      "description": "The function rearranges the rows in the\n                        id matrix following the sorted order of the values in the column.",
      "syntax": "matrix.sort(id, column, order) → void",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float/string>",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "order",
          "type": "series sort_order",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.sort()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<float>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 3)    matrix.set(m1, 0, 1, 4)    matrix.set(m1, 1, 0, 1)    matrix.set(m1, 1, 1, 2)        // Copy the matrix to a new one.    var m2 = matrix.copy(m1)    // Sort the rows of `m2` using the default arguments (first column and ascending order).    matrix.sort(m2)        // Display using a table.    if barstate.islastconfirmedhistory        var t = table.new(position.top_right, 2, 2, color.green)        table.cell(t, 0, 0, \"Original matrix:\")        table.cell(t, 0, 1, str.tostring(m1))        table.cell(t, 1, 0, \"Sorted matrix:\")        table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.max",
          "href": "fun_matrix.max"
        },
        {
          "name": "matrix.min",
          "href": "fun_matrix.min"
        },
        {
          "name": "matrix.avg",
          "href": "fun_matrix.avg"
        }
      ]
    },
    "fun_matrix.submatrix": {
      "id": "fun_matrix.submatrix",
      "name": "matrix.submatrix",
      "description": "The function extracts a submatrix of the\n                        id matrix within the specified indices.",
      "syntax": "matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "from_row",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "to_row",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "from_column",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "to_column",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.submatrix()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix matrix with values `0`.    var m1 = matrix.new<int>(2, 3, 0)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 0, 2, 3)    matrix.set(m1, 1, 0, 4)    matrix.set(m1, 1, 1, 5)    matrix.set(m1, 1, 2, 6)        // Create a 2x2 submatrix of the `m1` matrix.    var m2 = matrix.submatrix(m1, 0, 2, 1, 3)        // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original Matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Submatrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.row",
          "href": "fun_matrix.row"
        },
        {
          "name": "matrix.col",
          "href": "fun_matrix.col"
        },
        {
          "name": "matrix.reshape",
          "href": "fun_matrix.reshape"
        }
      ]
    },
    "fun_matrix.sum": {
      "id": "fun_matrix.sum",
      "name": "matrix.sum",
      "description": "The function returns a new matrix resulting from\n                        the sum of two\n                        matrices id1 and id2, or of an id1 matrix and an id2\n                        scalar (a numerical value).",
      "syntax": "matrix.sum(id1, id2) → matrix<int>",
      "arguments": [
        {
          "name": "id1",
          "type": "matrix<int>",
          "description": "First"
        },
        {
          "name": "id2",
          "type": "series int/float/matrix<int>",
          "description": "Second"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.sum()` Example 1\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix containing values `5`.    var m1 = matrix.new<float>(2, 3, 5)     // Create a 2x3 matrix containing values `4`.    var m2 = matrix.new<float>(2, 3, 4)     // Create a new matrix that sums matrices `m1` and `m2`.    var m3 = matrix.sum(m1, m2)         // Display using a table.    var t = table.new(position.top_right, 1, 2, color.green)    table.cell(t, 0, 0, \"Sum of two matrices:\")    table.cell(t, 0, 1, str.tostring(m3))",
        "//@version=6indicator(\"`matrix.sum()` Example 2\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x3 matrix with values `4`.    var m1 = matrix.new<float>(2, 3, 4)        // Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.    var m2 = matrix.sum(m1, 1)        // Display using a table.    var t = table.new(position.top_right, 1, 2, color.green)    table.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")    table.cell(t, 0, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.swap_columns": {
      "id": "fun_matrix.swap_columns",
      "name": "matrix.swap_columns",
      "description": "The function swaps the columns at the index column1\n                        and column2 in the id matrix.",
      "syntax": "matrix.swap_columns(id, column1, column2) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "column1",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "column2",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.swap_columns()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix with ‘na’ values.    var m1 = matrix.new<int>(2, 2, na)        // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Copy the matrix to a new one.    var m2 = matrix.copy(m1)        // Swap the first and second columns of the matrix copy.    matrix.swap_columns(m2, 0, 1)    // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Swapped columns in copy:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.swap_rows": {
      "id": "fun_matrix.swap_rows",
      "name": "matrix.swap_rows",
      "description": "The function swaps the rows at the index row1\n                        and row2 in the id matrix.",
      "syntax": "matrix.swap_rows(id, row1, row2) → void",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        },
        {
          "name": "row1",
          "type": "series int",
          "description": "Index"
        },
        {
          "name": "row2",
          "type": "series int",
          "description": "Index"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.swap_rows()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 3x2 matrix with ‘na’ values.    var m1 = matrix.new<int>(3, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)    matrix.set(m1, 2, 0, 5)    matrix.set(m1, 2, 1, 6)        // Copy the matrix to a new one.    var m2 = matrix.copy(m1)        // Swap the first and second rows of the matrix copy.    matrix.swap_rows(m2, 0, 1)        // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Swapped rows in copy:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.swap_columns",
          "href": "fun_matrix.swap_columns"
        }
      ]
    },
    "fun_matrix.trace": {
      "id": "fun_matrix.trace",
      "name": "matrix.trace",
      "description": "The function calculates the trace of a\n                        matrix (the sum of the main diagonal's elements).",
      "syntax": "matrix.trace(id) → series float",
      "arguments": [
        {
          "name": "id",
          "type": "matrix<int/float>",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.trace()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<int>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Get the trace of the matrix.    tr = matrix.trace(m1)        // Display matrix elements.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Matrix elements:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Trace of the matrix:\")    table.cell(t, 1, 1, str.tostring(tr))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.get",
          "href": "fun_matrix.get"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        }
      ]
    },
    "fun_matrix.transpose": {
      "id": "fun_matrix.transpose",
      "name": "matrix.transpose",
      "description": "The function creates a new, transposed\n                        version of the id. This interchanges the row and column index of each element.",
      "syntax": "matrix.transpose(id) → matrix<type>",
      "arguments": [
        {
          "name": "id",
          "type": "any matrix type",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`matrix.transpose()` Example\")// For efficiency, execute this code only once.if barstate.islastconfirmedhistory    // Create a 2x2 matrix.     var m1 = matrix.new<float>(2, 2, na)    // Fill the matrix with values.    matrix.set(m1, 0, 0, 1)    matrix.set(m1, 0, 1, 2)    matrix.set(m1, 1, 0, 3)    matrix.set(m1, 1, 1, 4)        // Create a transpose of the matrix.    var m2 = matrix.transpose(m1)        // Display using a table.    var t = table.new(position.top_right, 2, 2, color.green)    table.cell(t, 0, 0, \"Original matrix:\")    table.cell(t, 0, 1, str.tostring(m1))    table.cell(t, 1, 0, \"Transposed matrix:\")    table.cell(t, 1, 1, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "matrix.set",
          "href": "fun_matrix.set"
        },
        {
          "name": "matrix.columns",
          "href": "fun_matrix.columns"
        },
        {
          "name": "matrix.rows",
          "href": "fun_matrix.rows"
        },
        {
          "name": "matrix.reshape",
          "href": "fun_matrix.reshape"
        },
        {
          "name": "matrix.reverse",
          "href": "fun_matrix.reverse"
        }
      ]
    },
    "fun_max_bars_back": {
      "id": "fun_max_bars_back",
      "name": "max_bars_back",
      "description": "Function sets the maximum number of bars that is\n                        available for historical reference of a given built-in or user variable. When operator '[]' is\n                        applied to a variable - it is a reference to a historical value of that variable.",
      "syntax": "max_bars_back(var, num) → void",
      "arguments": [
        {
          "name": "var",
          "type": "series int/float/bool/color/label/line",
          "description": "Series"
        },
        {
          "name": "num",
          "type": "const int",
          "description": "History"
        }
      ],
      "examples": [
        "//@version=6indicator(\"max_bars_back\")close_() => closedepth() => 400d = depth()v = close_()max_bars_back(v, 500)out = if bar_index > 0    v[d]else    vplot(out)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        }
      ]
    },
    "fun_minute": {
      "id": "fun_minute",
      "name": "minute",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "minute(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "Minute",
          "type": "in exchange timezone",
          "description": "for provided UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_month": {
      "id": "fun_month",
      "name": "month",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "month(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "Month",
          "type": "in exchange timezone",
          "description": "for provided UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_na": {
      "id": "fun_na",
      "name": "na",
      "description": "Tests if x is na.",
      "syntax": "na(x) → simple bool",
      "arguments": [
        {
          "name": "x",
          "type": "simple int/float",
          "description": "Value"
        }
      ],
      "examples": [
        "//@version=6indicator(\"na\")// Use the `na()` function to test for `na`.plot(na(close[1]) ? close : close[1])// ALTERNATIVE// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.plot(nz(close[1], close))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "na",
          "href": "var_na"
        },
        {
          "name": "fixnan",
          "href": "fun_fixnan"
        },
        {
          "name": "nz",
          "href": "fun_nz"
        }
      ]
    },
    "fun_nz": {
      "id": "fun_nz",
      "name": "nz",
      "description": "Replaces NaN values with zeros (or given value) in\n                        a series.",
      "syntax": "nz(source) → simple color",
      "arguments": [
        {
          "name": "source",
          "type": "simple color",
          "description": "Series"
        }
      ],
      "examples": [
        "//@version=6indicator(\"nz\", overlay=true)plot(nz(ta.sma(close, 100)))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "na",
          "href": "var_na"
        },
        {
          "name": "na",
          "href": "fun_na"
        },
        {
          "name": "fixnan",
          "href": "fun_fixnan"
        }
      ]
    },
    "fun_plot": {
      "id": "fun_plot",
      "name": "plot",
      "description": "Plots a series of data on the chart.",
      "syntax": "plot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display, format, precision, force_overlay) → plot",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "linewidth",
          "type": "input int",
          "description": "Width"
        },
        {
          "name": "style",
          "type": "input plot_style",
          "description": "Type"
        },
        {
          "name": "trackprice",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "histbase",
          "type": "input int/float",
          "description": "The"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "join",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plot\")plot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)// You may fill the background between any two plots with a fill() function:p1 = plot(open)p2 = plot(close)fill(p1, p2, color=color.new(color.green, 90))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        },
        {
          "name": "fill",
          "href": "fun_fill"
        }
      ]
    },
    "fun_plotarrow": {
      "id": "fun_plotarrow",
      "name": "plotarrow",
      "description": "Plots up and down arrows on the chart. Up arrow is\n                        drawn at every indicator positive value, down arrow is drawn at every negative value. If\n                        indicator returns na then no arrow\n                        is drawn. Arrows has different height, the more absolute indicator value the longer arrow is\n                        drawn.",
      "syntax": "plotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display, format, precision, force_overlay) → void",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "colorup",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "colordown",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "minheight",
          "type": "input int",
          "description": "Minimal"
        },
        {
          "name": "maxheight",
          "type": "input int",
          "description": "Maximum"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plotarrow example\", overlay=true)codiff = close - openplotarrow(codiff, colorup=color.new(color.teal,40), colordown=color.new(color.orange, 40))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        }
      ]
    },
    "fun_plotbar": {
      "id": "fun_plotbar",
      "name": "plotbar",
      "description": "Plots ohlc bars on the chart.",
      "syntax": "plotbar(open, high, low, close, title, color, editable, show_last, display, format, precision, force_overlay) → void",
      "arguments": [
        {
          "name": "open",
          "type": "series int/float",
          "description": "Open"
        },
        {
          "name": "high",
          "type": "series int/float",
          "description": "High"
        },
        {
          "name": "low",
          "type": "series int/float",
          "description": "Low"
        },
        {
          "name": "close",
          "type": "series int/float",
          "description": "Close"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plotbar example\", overlay=true)plotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "fun_plotcandle": {
      "id": "fun_plotcandle",
      "name": "plotcandle",
      "description": "Plots candles on the chart.",
      "syntax": "plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display, format, precision, force_overlay) → void",
      "arguments": [
        {
          "name": "open",
          "type": "series int/float",
          "description": "Open"
        },
        {
          "name": "high",
          "type": "series int/float",
          "description": "High"
        },
        {
          "name": "low",
          "type": "series int/float",
          "description": "Low"
        },
        {
          "name": "close",
          "type": "series int/float",
          "description": "Close"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "wickcolor",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "bordercolor",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plotcandle example\", overlay=true)plotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        }
      ]
    },
    "fun_plotchar": {
      "id": "fun_plotchar",
      "name": "plotchar",
      "description": "Plots visual shapes using any given one Unicode\n                        character on the chart.",
      "syntax": "plotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float/bool",
          "description": "Series"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "char",
          "type": "input string",
          "description": "Character"
        },
        {
          "name": "location",
          "type": "input string",
          "description": "Location"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "text",
          "type": "const string",
          "description": "Text"
        },
        {
          "name": "textcolor",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "size",
          "type": "const string",
          "description": "Size"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plotchar example\", overlay=true)data = close >= openplotchar(data, char='❄')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        }
      ]
    },
    "fun_plotshape": {
      "id": "fun_plotshape",
      "name": "plotshape",
      "description": "Plots visual shapes on the chart.",
      "syntax": "plotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float/bool",
          "description": "Series"
        },
        {
          "name": "title",
          "type": "const string",
          "description": "Title"
        },
        {
          "name": "style",
          "type": "input string",
          "description": "Type"
        },
        {
          "name": "location",
          "type": "input string",
          "description": "Location"
        },
        {
          "name": "color",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Shifts"
        },
        {
          "name": "text",
          "type": "const string",
          "description": "Text"
        },
        {
          "name": "textcolor",
          "type": "series color",
          "description": "Color"
        },
        {
          "name": "editable",
          "type": "input bool",
          "description": "If"
        },
        {
          "name": "size",
          "type": "const string",
          "description": "Size"
        },
        {
          "name": "show_last",
          "type": "input int",
          "description": "Optional."
        },
        {
          "name": "display",
          "type": "input plot_display",
          "description": "Controls"
        },
        {
          "name": "format",
          "type": "input string",
          "description": "Determines"
        },
        {
          "name": "precision",
          "type": "input int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"plotshape example 1\", overlay=true)data = close >= openplotshape(data, style=shape.xcross)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "barcolor",
          "href": "fun_barcolor"
        },
        {
          "name": "bgcolor",
          "href": "fun_bgcolor"
        }
      ]
    },
    "fun_polyline.delete": {
      "id": "fun_polyline.delete",
      "name": "polyline.delete",
      "description": "Deletes the specified polyline\n                        object. It has no effect if the id doesn't exist.",
      "syntax": "polyline.delete(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series polyline",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_polyline.new": {
      "id": "fun_polyline.new",
      "name": "polyline.new",
      "description": "Creates a new polyline\n                        instance and displays it on the chart, sequentially connecting all of the points in the points\n                        array with line segments. The segments in the drawing can be straight or curved depending on the\n                        curved parameter.",
      "syntax": "polyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width, force_overlay) → series polyline",
      "arguments": [
        {
          "name": "points",
          "type": "array<chart.point>",
          "description": "An"
        },
        {
          "name": "curved",
          "type": "series bool",
          "description": "If"
        },
        {
          "name": "closed",
          "type": "series bool",
          "description": "If"
        },
        {
          "name": "xloc",
          "type": "series string",
          "description": "Determines"
        },
        {
          "name": "line_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "fill_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "line_style",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "line_width",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Polylines example\", overlay = true)//@variable If `true`, connects all points in the polyline with curved line segments. bool curvedInput = input.bool(false, \"Curve Polyline\")//@variable If `true`, connects the first point in the polyline to the last point.bool closedInput = input.bool(true, \"Close Polyline\")//@variable The color of the space filled by the polyline.color fillcolor = input.color(color.new(color.blue, 90), \"Fill Color\")// Time and price inputs for the polyline's points. p1x = input.time(0,  \"p1\", confirm = true, inline = \"p1\")p1y = input.price(0, \"  \", confirm = true, inline = \"p1\")p2x = input.time(0,  \"p2\", confirm = true, inline = \"p2\")p2y = input.price(0, \"  \", confirm = true, inline = \"p2\")p3x = input.time(0,  \"p3\", confirm = true, inline = \"p3\")p3y = input.price(0, \"  \", confirm = true, inline = \"p3\")p4x = input.time(0,  \"p4\", confirm = true, inline = \"p4\")p4y = input.price(0, \"  \", confirm = true, inline = \"p4\")p5x = input.time(0,  \"p5\", confirm = true, inline = \"p5\")p5y = input.price(0, \"  \", confirm = true, inline = \"p5\")if barstate.islastconfirmedhistory    //@variable An array of `chart.point` objects for the new polyline.    var points = array.new<chart.point>()    // Push new `chart.point` instances into the `points` array.    points.push(chart.point.from_time(p1x, p1y))    points.push(chart.point.from_time(p2x, p2y))    points.push(chart.point.from_time(p3x, p3y))    points.push(chart.point.from_time(p4x, p4y))    points.push(chart.point.from_time(p5x, p5y))    // Add labels for each `chart.point` in `points`.    l1p1 = label.new(points.get(0), text = \"p1\", xloc = xloc.bar_time, color = na)    l1p2 = label.new(points.get(1), text = \"p2\", xloc = xloc.bar_time, color = na)    l2p1 = label.new(points.get(2), text = \"p3\", xloc = xloc.bar_time, color = na)    l2p2 = label.new(points.get(3), text = \"p4\", xloc = xloc.bar_time, color = na)    // Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.    polyline.new(points, curved = curvedInput, closed = closedInput, fill_color = fillcolor, xloc = xloc.bar_time)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "chart.point.new",
          "href": "fun_chart.point.new"
        }
      ]
    },
    "fun_request.currency_rate": {
      "id": "fun_request.currency_rate",
      "name": "request.currency_rate",
      "description": "Provides a daily rate that can be used to convert\n                        a value expressed in the from currency to another in the to currency.",
      "syntax": "request.currency_rate(from, to, ignore_invalid_currency) → series float",
      "arguments": [
        {
          "name": "from",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "to",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "ignore_invalid_currency",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Close in British Pounds\")rate = request.currency_rate(syminfo.currency, \"GBP\")plot(close * rate)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_request.dividends": {
      "id": "fun_request.dividends",
      "name": "request.dividends",
      "description": "Requests dividends data for the specified\n                        symbol.",
      "syntax": "request.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float",
      "arguments": [
        {
          "name": "ticker",
          "type": "series string",
          "description": "Symbol."
        },
        {
          "name": "field",
          "type": "series string",
          "description": "Input"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Merge"
        },
        {
          "name": "lookahead",
          "type": "simple barmerge_lookahead",
          "description": "Merge"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "An"
        },
        {
          "name": "currency",
          "type": "series string",
          "description": "Currency"
        }
      ],
      "examples": [
        "//@version=6indicator(\"request.dividends\")s1 = request.dividends(\"NASDAQ:BELFA\")plot(s1)s2 = request.dividends(\"NASDAQ:BELFA\", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)plot(s2)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        },
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "fun_request.earnings": {
      "id": "fun_request.earnings",
      "name": "request.earnings",
      "description": "Requests earnings data for the specified symbol.",
      "syntax": "request.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float",
      "arguments": [
        {
          "name": "ticker",
          "type": "series string",
          "description": "Symbol."
        },
        {
          "name": "field",
          "type": "series string",
          "description": "Input"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Merge"
        },
        {
          "name": "lookahead",
          "type": "simple barmerge_lookahead",
          "description": "Merge"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "An"
        },
        {
          "name": "currency",
          "type": "series string",
          "description": "Currency"
        }
      ],
      "examples": [
        "//@version=6indicator(\"request.earnings\")s1 = request.earnings(\"NASDAQ:BELFA\")plot(s1)s2 = request.earnings(\"NASDAQ:BELFA\", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)plot(s2)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        },
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "fun_request.economic": {
      "id": "fun_request.economic",
      "name": "request.economic",
      "description": "Requests economic data for a symbol. Economic data\n                        includes information such as the state of a country's economy (GDP, inflation rate, etc.) or of\n                        a particular industry (steel production, ICU beds, etc.).",
      "syntax": "request.economic(country_code, field, gaps, ignore_invalid_symbol) → series float",
      "arguments": [
        {
          "name": "country_code",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "field",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Specifies"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"US GDP\")e = request.economic(\"US\", \"GDP\")plot(e)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.financial",
          "href": "fun_request.financial"
        }
      ]
    },
    "fun_request.financial": {
      "id": "fun_request.financial",
      "name": "request.financial",
      "description": "Requests financial series for symbol.",
      "syntax": "request.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float",
      "arguments": [
        {
          "name": "symbol",
          "type": "series string",
          "description": "Symbol."
        },
        {
          "name": "financial_id",
          "type": "series string",
          "description": "Financial"
        },
        {
          "name": "period",
          "type": "series string",
          "description": "Reporting"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Merge"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "An"
        },
        {
          "name": "currency",
          "type": "series string",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"request.financial\")f = request.financial(\"NASDAQ:MSFT\", \"ACCOUNTS_PAYABLE\", \"FY\")plot(f)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "fun_request.quandl": {
      "id": "fun_request.quandl",
      "name": "request.quandl",
      "description": "Note: This function has been deprecated\n                        due to the API change from NASDAQ Data Link. Requests for \"QUANDL\" symbols are no longer valid\n                        and requests for them return a runtime error.",
      "syntax": "request.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float",
      "arguments": [
        {
          "name": "ticker",
          "type": "series string",
          "description": "Symbol."
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Merge"
        },
        {
          "name": "index",
          "type": "series int",
          "description": "A"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"request.quandl\")f = request.quandl(\"CFTC/SB_FO_ALL\", barmerge.gaps_off, 0)plot(f)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "fun_request.security": {
      "id": "fun_request.security",
      "name": "request.security",
      "description": "Requests the result of an expression from a\n                        specified context (symbol and timeframe).",
      "syntax": "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency, calc_bars_count) → series <type>",
      "arguments": [
        {
          "name": "symbol",
          "type": "series string",
          "description": "Symbol"
        },
        {
          "name": "timeframe",
          "type": "series string",
          "description": "Timeframe"
        },
        {
          "name": "expression",
          "type": "variable, function, object, array, matrix, or map of series int/float/bool/string/color/enum, or a tuple of these",
          "description": "The"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Specifies"
        },
        {
          "name": "lookahead",
          "type": "simple barmerge_lookahead",
          "description": "On"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "Determines"
        },
        {
          "name": "currency",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "calc_bars_count",
          "type": "simple int",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Simple `request.security()` calls\")// Returns 1D close of the current symbol.dailyClose = request.security(syminfo.tickerid, \"1D\", close)plot(dailyClose)// Returns the close of \"AAPL\" from the same timeframe as currently open on the chart.aaplClose = request.security(\"AAPL\", timeframe.period, close)plot(aaplClose)",
        "//@version=6indicator(\"Advanced `request.security()` calls\")// This calculates a 10-period moving average on the active chart.sma = ta.sma(close, 10)// This sends the `sma` calculation for execution in the context of the \"AAPL\" symbol at a \"240\" (4 hours) timeframe.aaplSma = request.security(\"AAPL\", \"240\", sma)plot(aaplSma)// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:indexHighTF = barstate.isrealtime ? 1 : 0indexCurrTF = barstate.isrealtime ? 0 : 1nonRepaintingClose = request.security(syminfo.tickerid, \"1D\", close[indexHighTF])[indexCurrTF]plot(nonRepaintingClose, \"Non-repainting close\")// Returns the 1H close of \"AAPL\", extended session included. The value is dividend-adjusted.extendedTicker = ticker.modify(\"NASDAQ:AAPL\", session = session.extended, adjustment = adjustment.dividends)aaplExtAdj = request.security(extendedTicker, \"60\", close)plot(aaplExtAdj)// Returns the result of a user-defined function.// The `max` variable is mutable, but we can pass it to `request.security()` because it is wrapped in a function.allTimeHigh(source) =>    var max = source    max := math.max(max, source)allTimeHigh1D = request.security(syminfo.tickerid, \"1D\", allTimeHigh(high))// By using a tuple `expression`, we obtain several values with only one `request.security()` call.[open1D, high1D, low1D, close1D, ema1D] = request.security(syminfo.tickerid, \"1D\", [open, high, low, close, ta.ema(close, 10)])plotcandle(open1D, high1D, low1D, close1D)plot(ema1D)// Returns an array containing the OHLC values of the chart's symbol from the 1D timeframe.ohlcArray = request.security(syminfo.tickerid, \"1D\", array.from(open, high, low, close))plotcandle(array.get(ohlcArray, 0), array.get(ohlcArray, 1), array.get(ohlcArray, 2), array.get(ohlcArray, 3))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "request.security_lower_tf",
          "href": "fun_request.security_lower_tf"
        },
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        },
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        },
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        },
        {
          "name": "request.financial",
          "href": "fun_request.financial"
        }
      ]
    },
    "fun_request.security_lower_tf": {
      "id": "fun_request.security_lower_tf",
      "name": "request.security_lower_tf",
      "description": "Requests the results of an expression from a\n                        specified symbol on a timeframe lower than or equal to the chart's timeframe. It returns an array containing one\n                        element for each lower-timeframe bar within the chart bar. On a 5-minute chart, requesting data\n                        using a timeframe argument of \"1\" typically returns an array with five elements\n                        representing the value of the expression on each 1-minute bar, ordered by time with\n                        the earliest value first.",
      "syntax": "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency, ignore_invalid_timeframe, calc_bars_count) → array<type>",
      "arguments": [
        {
          "name": "symbol",
          "type": "series string",
          "description": "Symbol"
        },
        {
          "name": "timeframe",
          "type": "series string",
          "description": "Timeframe"
        },
        {
          "name": "expression",
          "type": "variable, object or function of series int/float/bool/string/color/enum, or a tuple of these",
          "description": "The"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "series bool",
          "description": "Determines"
        },
        {
          "name": "currency",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "ignore_invalid_timeframe",
          "type": "series bool",
          "description": "Determines"
        },
        {
          "name": "calc_bars_count",
          "type": "simple int",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`request.security_lower_tf()` Example\", overlay = true)// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.arrClose = request.security_lower_tf(syminfo.tickerid, \"60\", close)if bar_index == last_bar_index - 1    label.new(bar_index, high, str.tostring(arrClose))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        },
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        },
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        },
        {
          "name": "request.financial",
          "href": "fun_request.financial"
        }
      ]
    },
    "fun_request.seed": {
      "id": "fun_request.seed",
      "name": "request.seed",
      "description": "Requests data from a user-maintained GitHub\n                        repository and returns it as a series. An in-depth tutorial on how to add new data can be found\n                        here.",
      "syntax": "request.seed(source, symbol, expression, ignore_invalid_symbol, calc_bars_count) → series <type>",
      "arguments": [
        {
          "name": "source",
          "type": "series string",
          "description": "Name"
        },
        {
          "name": "symbol",
          "type": "series string",
          "description": "Name"
        },
        {
          "name": "expression",
          "type": "<arg_expr_type>",
          "description": "An"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "Determines"
        },
        {
          "name": "calc_bars_count",
          "type": "simple int",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"BTC Development Activity\")[devAct, devActSMA] = request.seed(\"seed_crypto_santiment\", \"BTC_DEV_ACTIVITY\", [close, ta.sma(close, 10)])plot(devAct, \"BTC Development Activity\")plot(devActSMA, \"BTC Development Activity SMA10\", color = color.yellow)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_request.splits": {
      "id": "fun_request.splits",
      "name": "request.splits",
      "description": "Requests splits data for the specified symbol.",
      "syntax": "request.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float",
      "arguments": [
        {
          "name": "ticker",
          "type": "series string",
          "description": "Symbol."
        },
        {
          "name": "field",
          "type": "series string",
          "description": "Input"
        },
        {
          "name": "gaps",
          "type": "simple barmerge_gaps",
          "description": "Merge"
        },
        {
          "name": "lookahead",
          "type": "simple barmerge_lookahead",
          "description": "Merge"
        },
        {
          "name": "ignore_invalid_symbol",
          "type": "input bool",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6indicator(\"request.splits\")s1 = request.splits(\"NASDAQ:BELFA\", splits.denominator)plot(s1)s2 = request.splits(\"NASDAQ:BELFA\", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)plot(s2)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        },
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "fun_runtime.error": {
      "id": "fun_runtime.error",
      "name": "runtime.error",
      "description": "When called, causes a runtime error with the error\n                        message specified in the message argument.",
      "syntax": "runtime.error(message) → void",
      "arguments": [
        {
          "name": "message",
          "type": "series string",
          "description": "Error"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_second": {
      "id": "fun_second",
      "name": "second",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "second(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "Second",
          "type": "in exchange timezone",
          "description": "for provided UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "second",
          "href": "var_second"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        }
      ]
    },
    "fun_str.contains": {
      "id": "fun_str.contains",
      "name": "str.contains",
      "description": "Returns true if the source string\n                        contains the str substring, false otherwise.",
      "syntax": "str.contains(source, str) → const bool",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "str",
          "type": "const string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.contains\")// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.var isFutures = str.contains(syminfo.tickerid, \"!\")plot(isFutures ? 1 : 0)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "str.pos",
          "href": "fun_str.pos"
        },
        {
          "name": "str.match",
          "href": "fun_str.match"
        }
      ]
    },
    "fun_str.endswith": {
      "id": "fun_str.endswith",
      "name": "str.endswith",
      "description": "Returns true if the source string\n                        ends with the substring specified in str, false otherwise.",
      "syntax": "str.endswith(source, str) → const bool",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "str",
          "type": "const string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "str.startswith",
          "href": "fun_str.startswith"
        }
      ]
    },
    "fun_str.format": {
      "id": "fun_str.format",
      "name": "str.format",
      "description": "Converts the formatting string and value(s) into a\n                        formatted string. The formatting string can contain literal text and one placeholder in curly\n                        braces {} for each value to be formatted. Each placeholder consists of the index of the required\n                        argument (beginning at 0) that will replace it, and an optional format specifier. The index\n                        represents the position of that argument in the str.format argument list.",
      "syntax": "str.format(formatString, arg0, arg1, ...) → simple string",
      "arguments": [
        {
          "name": "formatString",
          "type": "simple string",
          "description": "Format"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.format\", overlay=true)// The format specifier inside the curly braces accepts certain modifiers:// - Specify the number of decimals to display:s1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3label.new(bar_index, close, text=s1)// - Round a float value to an integer:s2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1label.new(bar_index - 1, close, text=s2)// - Display a number in currency:s3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34label.new(bar_index - 2, close, text=s3)// - Display a number as a percentage:s4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%label.new(bar_index - 3, close, text=s4)// EXAMPLES WITH SEVERAL ARGUMENTS// returns: Number 1 is not equal to 4s5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)label.new(bar_index - 4, close, text=s5)// returns: 1.34 != 1.3s6 = str.format(\"{0} != {0, number, #.#}\", 1.34)label.new(bar_index - 5, close, text=s6)// returns: 1 is equal to 1, but 2 is equal to 2s7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)label.new(bar_index - 6, close, text=s7)// returns: The cash turnover amounted to $1,340,000.00s8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)label.new(bar_index - 7, close, text=s8)// returns: Expected return is 10% - 20%s9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)label.new(bar_index - 8, close, text=s9)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_str.format_time": {
      "id": "fun_str.format_time",
      "name": "str.format_time",
      "description": "Converts the time timestamp into a\n                        string formatted according to format and timezone.",
      "syntax": "str.format_time(time, format, timezone) → series string",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "format",
          "type": "series string",
          "description": "A"
        },
        {
          "name": "timezone",
          "type": "series string",
          "description": "Allows"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.format_time\")if timeframe.change(\"1D\")    formattedTime = str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone)    label.new(bar_index, high, formattedTime)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_str.length": {
      "id": "fun_str.length",
      "name": "str.length",
      "description": "Returns an integer corresponding to the amount of\n                        chars in that string.",
      "syntax": "str.length(string) → const int",
      "arguments": [
        {
          "name": "string",
          "type": "const string",
          "description": "Source"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_str.lower": {
      "id": "fun_str.lower",
      "name": "str.lower",
      "description": "Returns a new string with all letters converted to\n                        lowercase.",
      "syntax": "str.lower(source) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "String"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "str.upper",
          "href": "fun_str.upper"
        }
      ]
    },
    "fun_str.match": {
      "id": "fun_str.match",
      "name": "str.match",
      "description": "Returns the new substring of the\n                        source string if it matches a regex regular expression, an empty\n                        string otherwise.",
      "syntax": "str.match(source, regex) → simple string",
      "arguments": [
        {
          "name": "source",
          "type": "simple string",
          "description": "Source"
        },
        {
          "name": "regex",
          "type": "simple string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.match\")s = input.string(\"It's time to sell some NASDAQ:AAPL!\")// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"var string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")if barstate.islastconfirmedhistory    label.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\""
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "str.contains",
          "href": "fun_str.contains"
        },
        {
          "name": "str.substring",
          "href": "fun_str.substring"
        }
      ]
    },
    "fun_str.pos": {
      "id": "fun_str.pos",
      "name": "str.pos",
      "description": "Returns the position of the first occurrence of\n                        the str string in the source string, 'na' otherwise.",
      "syntax": "str.pos(source, str) → const int",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "str",
          "type": "const string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "str.contains",
          "href": "fun_str.contains"
        },
        {
          "name": "str.match",
          "href": "fun_str.match"
        },
        {
          "name": "str.substring",
          "href": "fun_str.substring"
        }
      ]
    },
    "fun_str.repeat": {
      "id": "fun_str.repeat",
      "name": "str.repeat",
      "description": "Constructs a new string containing the source\n                        string repeated repeat times with the separator injected between each\n                        repeated instance.",
      "syntax": "str.repeat(source, repeat, separator) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "String"
        },
        {
          "name": "repeat",
          "type": "const int",
          "description": "Number"
        },
        {
          "name": "separator",
          "type": "const string",
          "description": "String"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.repeat\")repeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"label.new(bar_index,close,repeat)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_str.replace": {
      "id": "fun_str.replace",
      "name": "str.replace",
      "description": "Returns a new string with the Nth occurrence of\n                        the target string replaced by the replacement string, where N is\n                        specified in occurrence.",
      "syntax": "str.replace(source, target, replacement, occurrence) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "target",
          "type": "const string",
          "description": "String"
        },
        {
          "name": "replacement",
          "type": "const string",
          "description": "String"
        },
        {
          "name": "occurrence",
          "type": "const int",
          "description": "N-th"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.replace\")var source = \"FTX:BTCUSD / FTX:BTCEUR\"// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement stringvar newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)if barstate.islastconfirmedhistory    // Display \"BINANCE:BTCUSD / FTX:BTCEUR\"    label.new(bar_index, high, text = newSource)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "str.replace_all",
          "href": "fun_str.replace_all"
        },
        {
          "name": "str.match",
          "href": "fun_str.match"
        }
      ]
    },
    "fun_str.replace_all": {
      "id": "fun_str.replace_all",
      "name": "str.replace_all",
      "description": "Replaces each occurrence of the target string in\n                        the source string with the replacement string.",
      "syntax": "str.replace_all(source, target, replacement) → simple string",
      "arguments": [
        {
          "name": "source",
          "type": "simple string",
          "description": "Source"
        },
        {
          "name": "target",
          "type": "simple string",
          "description": "String"
        },
        {
          "name": "replacement",
          "type": "simple string",
          "description": "String"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_str.split": {
      "id": "fun_str.split",
      "name": "str.split",
      "description": "Divides a string into an array of substrings and\n                        returns its array id.",
      "syntax": "str.split(string, separator) → array<string>",
      "arguments": [
        {
          "name": "string",
          "type": "series string",
          "description": "Source"
        },
        {
          "name": "separator",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_str.startswith": {
      "id": "fun_str.startswith",
      "name": "str.startswith",
      "description": "Returns true if the source string\n                        starts with the substring specified in str, false otherwise.",
      "syntax": "str.startswith(source, str) → const bool",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "str",
          "type": "const string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "str.endswith",
          "href": "fun_str.endswith"
        }
      ]
    },
    "fun_str.substring": {
      "id": "fun_str.substring",
      "name": "str.substring",
      "description": "Returns a new string that is a substring of the\n                        source string. The substring begins with the character at the index specified by\n                        begin_pos and extends to 'end_pos - 1' of the source string.",
      "syntax": "str.substring(source, begin_pos) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "Source"
        },
        {
          "name": "begin_pos",
          "type": "const int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.substring\", overlay = true)sym= input.symbol(\"NASDAQ:AAPL\")pos = str.pos(sym, \":\") // Get position of \":\" charactertkr= str.substring(sym, pos+1) // \"AAPL\"if barstate.islastconfirmedhistory    label.new(bar_index, high, text = tkr)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "str.contains",
          "href": "fun_str.contains"
        },
        {
          "name": "str.pos",
          "href": "fun_str.pos"
        },
        {
          "name": "str.match",
          "href": "fun_str.match"
        }
      ]
    },
    "fun_str.tonumber": {
      "id": "fun_str.tonumber",
      "name": "str.tonumber",
      "description": "Converts a value represented in\n                        string to its \"float\" equivalent.",
      "syntax": "str.tonumber(string) → const float",
      "arguments": [
        {
          "name": "string",
          "type": "const string",
          "description": "String"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_str.tostring": {
      "id": "fun_str.tostring",
      "name": "str.tostring",
      "description": "value (simple int/float) Value\n                        or array ID whose elements are converted to a string.",
      "syntax": "str.tostring(value, format) → simple string",
      "arguments": [
        {
          "name": "value",
          "type": "simple int/float",
          "description": "Value"
        },
        {
          "name": "format",
          "type": "simple string",
          "description": "Format"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_str.trim": {
      "id": "fun_str.trim",
      "name": "str.trim",
      "description": "Constructs a new string with all consecutive\n                        whitespaces and other control characters (e.g., “\\n”, “\\t”, etc.) removed from the left and\n                        right of the source.",
      "syntax": "str.trim(source) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "String"
        }
      ],
      "examples": [
        "//@version=6indicator(\"str.trim\")trim = str.trim(\"    abc    \") // Returns \"abc\"label.new(bar_index,close,trim)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_str.upper": {
      "id": "fun_str.upper",
      "name": "str.upper",
      "description": "Returns a new string with all letters converted to\n                        uppercase.",
      "syntax": "str.upper(source) → const string",
      "arguments": [
        {
          "name": "source",
          "type": "const string",
          "description": "String"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "str.lower",
          "href": "fun_str.lower"
        }
      ]
    },
    "fun_strategy": {
      "id": "fun_strategy",
      "name": "strategy",
      "description": "This declaration statement designates the script\n                        as a strategy and sets a number of strategy-related properties.",
      "syntax": "strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, risk_free_rate, use_bar_magnifier, fill_orders_on_standard_ohlc, max_polylines_count, dynamic_requests, behind_chart) → void",
      "arguments": [
        {
          "name": "title",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "shorttitle",
          "type": "const string",
          "description": "The"
        },
        {
          "name": "overlay",
          "type": "const bool",
          "description": "If"
        },
        {
          "name": "format",
          "type": "const string",
          "description": "Specifies"
        },
        {
          "name": "precision",
          "type": "const int",
          "description": "Specifies"
        },
        {
          "name": "scale",
          "type": "const scale_type",
          "description": "The"
        },
        {
          "name": "pyramiding",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "calc_on_order_fills",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "calc_on_every_tick",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "max_bars_back",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "backtest_fill_limits_assumption",
          "type": "const int",
          "description": "Limit"
        },
        {
          "name": "default_qty_type",
          "type": "const string",
          "description": "Specifies"
        },
        {
          "name": "default_qty_value",
          "type": "const int/float",
          "description": "The"
        },
        {
          "name": "initial_capital",
          "type": "const int/float",
          "description": "The"
        },
        {
          "name": "currency",
          "type": "const string",
          "description": "Currency"
        },
        {
          "name": "slippage",
          "type": "const int",
          "description": "Slippage"
        },
        {
          "name": "commission_type",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "commission_value",
          "type": "const int/float",
          "description": "Commission"
        },
        {
          "name": "process_orders_on_close",
          "type": "const bool",
          "description": "When"
        },
        {
          "name": "close_entries_rule",
          "type": "const string",
          "description": "Determines"
        },
        {
          "name": "margin_long",
          "type": "const int/float",
          "description": "Margin"
        },
        {
          "name": "margin_short",
          "type": "const int/float",
          "description": "Margin"
        },
        {
          "name": "explicit_plot_zorder",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "max_lines_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "max_labels_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "max_boxes_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "calc_bars_count",
          "type": "const int",
          "description": "Limits"
        },
        {
          "name": "risk_free_rate",
          "type": "const int/float",
          "description": "The"
        },
        {
          "name": "use_bar_magnifier",
          "type": "const bool",
          "description": "Optional."
        },
        {
          "name": "fill_orders_on_standard_ohlc",
          "type": "const bool",
          "description": "When"
        },
        {
          "name": "max_polylines_count",
          "type": "const int",
          "description": "The"
        },
        {
          "name": "dynamic_requests",
          "type": "const bool",
          "description": "Specifies"
        },
        {
          "name": "behind_chart",
          "type": "const bool",
          "description": "Controls"
        }
      ],
      "examples": [
        "//@version=6strategy(\"My strategy\", overlay = true)// Enter long by market if current open is greater than previous high.if open > high[1]    strategy.entry(\"Long\", strategy.long, 1)// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named \"Long\".strategy.exit(\"Exit\", \"Long\", profit = 10, loss = 5)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "library",
          "href": "fun_library"
        }
      ]
    },
    "fun_strategy.cancel": {
      "id": "fun_strategy.cancel",
      "name": "strategy.cancel",
      "description": "Cancels a pending or unfilled order with a\n                        specific identifier. If multiple unfilled orders share the same ID, calling this command with\n                        that ID as the id argument cancels all of them. If a script calls this command with\n                        an id representing the ID of a filled order, it has no effect.",
      "syntax": "strategy.cancel(id) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(title = \"Order cancellation demo\")conditionForBuy = open > high[1]if conditionForBuy    strategy.entry(\"Long\", strategy.long, 1, limit = low) // Enter long using limit order at low price of current bar if `conditionForBuy` is `true`.if not conditionForBuy    strategy.cancel(\"Long\") // Cancel the entry order with name \"Long\" if `conditionForBuy` is `false`."
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.cancel_all": {
      "id": "fun_strategy.cancel_all",
      "name": "strategy.cancel_all",
      "description": "Cancels all pending or unfilled orders, regardless\n                        of their identifiers.",
      "syntax": "strategy.cancel_all() → void",
      "arguments": [],
      "examples": [
        "//@version=6strategy(title = \"Cancel all orders demo\")conditionForBuy1 = open > high[1]if conditionForBuy1    strategy.entry(\"Long entry 1\", strategy.long, 1, limit = low) // Enter long using a limit order if `conditionForBuy1` is `true`.conditionForBuy2 = conditionForBuy1 and open[1] > high[2]float lowest2 = ta.lowest(low, 2)if conditionForBuy2    strategy.entry(\"Long entry 2\", strategy.long, 1, limit = lowest2) // Enter long using a limit order if `conditionForBuy2` is `true`.conditionForStopTrading = open < lowest2if conditionForStopTrading    strategy.cancel_all() // Cancel both limit orders if `conditionForStopTrading` is `true`."
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.close": {
      "id": "fun_strategy.close",
      "name": "strategy.close",
      "description": "Creates an order to exit from the part of a\n                        position opened by entry orders with a specific identifier. If multiple entries in the position\n                        share the same ID, the orders from this command apply to all those entries, starting from the\n                        first open trade, when its calls use that ID as the id argument.",
      "syntax": "strategy.close(id, comment, qty, qty_percent, alert_message, immediately, disable_alert) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "comment",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "qty",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "qty_percent",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "alert_message",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "immediately",
          "type": "series bool",
          "description": "Optional."
        },
        {
          "name": "disable_alert",
          "type": "series bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6strategy(\"Partial close strategy\")// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)// Place a market order to enter a long position when `sma14` crosses over `sma28`.if ta.crossover(sma14, sma28)    strategy.entry(\"My Long Entry ID\", strategy.long)// Place a market order to close the long trade when `sma14` crosses under `sma28`. if ta.crossunder(sma14, sma28)    strategy.close(\"My Long Entry ID\", \"50% market close\", qty_percent = 50)// Plot the position size.plot(strategy.position_size)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.close_all": {
      "id": "fun_strategy.close_all",
      "name": "strategy.close_all",
      "description": "Creates an order to close an open position\n                        completely, regardless of the identifiers of the entry orders that opened or added to it.",
      "syntax": "strategy.close_all(comment, alert_message) → void",
      "arguments": [
        {
          "name": "comment",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_message",
          "type": "series string",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6strategy(\"Multi-entry close strategy\")// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)// Place a market order to enter a long trade every time `sma14` crosses over `sma28`.if ta.crossover(sma14, sma28)    strategy.order(\"My Long Entry ID \" + str.tostring(strategy.opentrades), strategy.long)// Place a market order to close the entire position every 500 bars. if bar_index % 500 == 0    strategy.close_all()// Plot the position size.plot(strategy.position_size)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.closedtrades.commission": {
      "id": "fun_strategy.closedtrades.commission",
      "name": "strategy.closedtrades.commission",
      "description": "Returns the sum of entry and exit fees paid in the\n                        closed trade, expressed in strategy.account_currency.",
      "syntax": "strategy.closedtrades.commission(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Plot total fees for the latest closed trade.plot(strategy.closedtrades.commission(strategy.closedtrades - 1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.opentrades.commission",
          "href": "fun_strategy.opentrades.commission"
        }
      ]
    },
    "fun_strategy.closedtrades.entry_bar_index": {
      "id": "fun_strategy.closedtrades.entry_bar_index",
      "name": "strategy.closedtrades.entry_bar_index",
      "description": "Returns the bar_index of the closed trade's\n                        entry.",
      "syntax": "strategy.closedtrades.entry_bar_index(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.entry_bar_index Example\")// Enter long trades on three rising bars; exit on two falling bars.if ta.rising(close, 3)    strategy.entry(\"Long\", strategy.long)if ta.falling(close, 2)    strategy.close(\"Long\")// Function that calculates the average amount of bars in a trade.avgBarsPerTrade() =>    sumBarsPerTrade = 0    for tradeNo = 0 to strategy.closedtrades - 1        // Loop through all closed trades, starting with the oldest.        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1    result = nz(sumBarsPerTrade / strategy.closedtrades)plot(avgBarsPerTrade())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.exit_bar_index",
          "href": "fun_strategy.closedtrades.exit_bar_index"
        },
        {
          "name": "strategy.opentrades.entry_bar_index",
          "href": "fun_strategy.opentrades.entry_bar_index"
        }
      ]
    },
    "fun_strategy.closedtrades.entry_comment": {
      "id": "fun_strategy.closedtrades.entry_comment",
      "name": "strategy.closedtrades.entry_comment",
      "description": "Returns the comment message of the closed trade's\n                        entry, or na\n                        if there is no entry with this trade_num.",
      "syntax": "strategy.closedtrades.entry_comment(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.entry_comment()` Example\", overlay = true)stopPrice = open * 1.01longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))    strategy.exit(\"EXIT\", trail_points = 1000, trail_offset = 0)var testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)if barstate.islastconfirmedhistory or barstate.isrealtime    table.cell(testTable, 0, 0, 'Last closed trade:')    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.closedtrades.entry_comment(strategy.closedtrades - 1))    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.closedtrades.entry_price(strategy.closedtrades - 1)))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        }
      ]
    },
    "fun_strategy.closedtrades.entry_id": {
      "id": "fun_strategy.closedtrades.entry_id",
      "name": "strategy.closedtrades.entry_id",
      "description": "Returns the id of the closed trade's entry.",
      "syntax": "strategy.closedtrades.entry_id(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.entry_id Example\", overlay = true)// Enter a short position and close at the previous to last bar.if bar_index == 1    strategy.entry(\"Short at bar #\" + str.tostring(bar_index), strategy.short)if bar_index == last_bar_index - 2    strategy.close_all()    // Display ID of the last entry position.if barstate.islastconfirmedhistory    label.new(last_bar_index, high, \"Last Entry ID is: \" + strategy.closedtrades.entry_id(strategy.closedtrades - 1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_bar_index",
          "href": "fun_strategy.closedtrades.entry_bar_index"
        },
        {
          "name": "strategy.closedtrades.entry_price",
          "href": "fun_strategy.closedtrades.entry_price"
        },
        {
          "name": "strategy.closedtrades.entry_time",
          "href": "fun_strategy.closedtrades.entry_time"
        }
      ]
    },
    "fun_strategy.closedtrades.entry_price": {
      "id": "fun_strategy.closedtrades.entry_price",
      "name": "strategy.closedtrades.entry_price",
      "description": "Returns the price of the closed trade's entry.",
      "syntax": "strategy.closedtrades.entry_price(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.entry_price Example 1\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Return the entry price for the latest entry.entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)plot(entryPrice, \"Long entry price\")",
        "// Calculates the average profit percentage for all closed trades.//@version=6strategy(\"strategy.closedtrades.entry_price Example 2\")// Strategy calls to create single short and long tradesif bar_index == last_bar_index - 15    strategy.entry(\"Long Entry\", strategy.long)else if bar_index == last_bar_index - 10    strategy.close(\"Long Entry\")    strategy.entry(\"Short\", strategy.short)else if bar_index == last_bar_index - 5    strategy.close(\"Short\")// Calculate profit for both closed trades.profitPct = 0.0for tradeNo = 0 to strategy.closedtrades - 1    entryP = strategy.closedtrades.entry_price(tradeNo)    exitP = strategy.closedtrades.exit_price(tradeNo)    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100    // Calculate average profit percent for both closed trades.avgProfitPct = nz(profitPct / strategy.closedtrades)plot(avgProfitPct)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_price",
          "href": "fun_strategy.closedtrades.entry_price"
        },
        {
          "name": "strategy.closedtrades.exit_price",
          "href": "fun_strategy.closedtrades.exit_price"
        },
        {
          "name": "strategy.closedtrades.size",
          "href": "fun_strategy.closedtrades.size"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        }
      ]
    },
    "fun_strategy.closedtrades.entry_time": {
      "id": "fun_strategy.closedtrades.entry_time",
      "name": "strategy.closedtrades.entry_time",
      "description": "Returns the UNIX time of the closed trade's entry,\n                        expressed in milliseconds..",
      "syntax": "strategy.closedtrades.entry_time(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.entry_time Example\", overlay = true)// Enter long trades on three rising bars; exit on two falling bars.if ta.rising(close, 3)    strategy.entry(\"Long\", strategy.long)if ta.falling(close, 2)    strategy.close(\"Long\")// Calculate the average trade duration avgTradeDuration() =>    sumTradeDuration = 0    for i = 0 to strategy.closedtrades - 1        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)    result = nz(sumTradeDuration / strategy.closedtrades)// Display average duration converted to seconds and formatted using 2 decimal pointsif barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.entry_time",
          "href": "fun_strategy.opentrades.entry_time"
        },
        {
          "name": "strategy.closedtrades.exit_time",
          "href": "fun_strategy.closedtrades.exit_time"
        },
        {
          "name": "time",
          "href": "var_time"
        }
      ]
    },
    "fun_strategy.closedtrades.exit_bar_index": {
      "id": "fun_strategy.closedtrades.exit_bar_index",
      "name": "strategy.closedtrades.exit_bar_index",
      "description": "Returns the bar_index of the closed trade's\n                        exit.",
      "syntax": "strategy.closedtrades.exit_bar_index(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.exit_bar_index Example 1\")// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.if bar_index == 0    strategy.entry(\"Short\", strategy.short)if bar_index == last_bar_index - 10    strategy.close(\"Short\")// Calculate the amount of bars since the last closed trade.barsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : naplot(barsSinceClosed, \"Bars since last closed trade\")",
        "// Calculates the average amount of bars per trade.//@version=6strategy(\"strategy.closedtrades.exit_bar_index Example 2\")// Enter long trades on three rising bars; exit on two falling bars.if ta.rising(close, 3)    strategy.entry(\"Long\", strategy.long)if ta.falling(close, 2)    strategy.close(\"Long\")// Function that calculates the average amount of bars per trade.avgBarsPerTrade() =>    sumBarsPerTrade = 0    for tradeNo = 0 to strategy.closedtrades - 1        // Loop through all closed trades, starting with the oldest.        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1    result = nz(sumBarsPerTrade / strategy.closedtrades)plot(avgBarsPerTrade())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "bar_index",
          "href": "var_bar_index"
        },
        {
          "name": "last_bar_index",
          "href": "var_last_bar_index"
        }
      ]
    },
    "fun_strategy.closedtrades.exit_comment": {
      "id": "fun_strategy.closedtrades.exit_comment",
      "name": "strategy.closedtrades.exit_comment",
      "description": "Returns the comment message of the closed trade's\n                        exit, or\n                        na if there is no entry with this\n                        trade_num.",
      "syntax": "strategy.closedtrades.exit_comment(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.exit_comment()` Example\", overlay = true)longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    strategy.entry(\"Long\", strategy.long)    strategy.exit(\"Exit\", stop = open * 0.95, limit = close * 1.05, trail_points = 100, trail_offset = 0, comment_profit = \"TP\", comment_loss = \"SL\", comment_trailing = \"TRAIL\")exitStats() =>    int slCount = 0    int tpCount = 0    int trailCount = 0        if strategy.closedtrades > 0        for i = 0 to strategy.closedtrades - 1            switch strategy.closedtrades.exit_comment(i)                \"TP\"    => tpCount    += 1                \"SL\"    => slCount    += 1                \"TRAIL\" => trailCount += 1    [slCount, tpCount, trailCount]var testTable = table.new(position.top_right, 1, 4, color.orange, border_width = 1)if barstate.islastconfirmedhistory    [slCount, tpCount, trailCount] = exitStats()    table.cell(testTable, 0, 0, \"Closed trades (\" + str.tostring(strategy.closedtrades) +\") stats:\")    table.cell(testTable, 0, 1, \"Stop Loss: \" + str.tostring(slCount))    table.cell(testTable, 0, 2, \"Take Profit: \" + str.tostring(tpCount))    table.cell(testTable, 0, 3, \"Trailing Stop: \" + str.tostring(trailCount))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.close",
          "href": "fun_strategy.close"
        },
        {
          "name": "strategy.closedtrades",
          "href": "fun_strategy.closedtrades"
        }
      ]
    },
    "fun_strategy.closedtrades.exit_id": {
      "id": "fun_strategy.closedtrades.exit_id",
      "name": "strategy.closedtrades.exit_id",
      "description": "Returns the id of the closed trade's exit.",
      "syntax": "strategy.closedtrades.exit_id(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.exit_id Example\", overlay = true)// Strategy calls to create single short and long tradesif bar_index == last_bar_index - 15    strategy.entry(\"Long Entry\", strategy.long)else if bar_index == last_bar_index - 10    strategy.entry(\"Short Entry\", strategy.short)    // When a new open trade is detected then we create the exit strategy corresponding with the matching entry id// We detect the correct entry id by determining if a position is long or short based on the position quantityif ta.change(strategy.opentrades) != 0    posSign = strategy.opentrades.size(strategy.opentrades - 1)    strategy.exit(posSign > 0 ? \"SL Long Exit\" : \"SL Short Exit\", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)// When a new closed trade is detected then we place a label above the bar with the exit infoif ta.change(strategy.closedtrades) != 0    msg = \"Trade closed by: \" + strategy.closedtrades.exit_id(strategy.closedtrades - 1)    label.new(bar_index, high + (3 * ta.tr), msg)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.exit_bar_index",
          "href": "fun_strategy.closedtrades.exit_bar_index"
        },
        {
          "name": "strategy.closedtrades.exit_price",
          "href": "fun_strategy.closedtrades.exit_price"
        },
        {
          "name": "strategy.closedtrades.exit_time",
          "href": "fun_strategy.closedtrades.exit_time"
        }
      ]
    },
    "fun_strategy.closedtrades.exit_price": {
      "id": "fun_strategy.closedtrades.exit_price",
      "name": "strategy.closedtrades.exit_price",
      "description": "Returns the price of the closed trade's exit.",
      "syntax": "strategy.closedtrades.exit_price(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.exit_price Example 1\")// We are creating a long trade every 5 barsif bar_index % 5 == 0    strategy.entry(\"Long\", strategy.long)strategy.close(\"Long\")// Return the exit price from the latest closed trade.exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)plot(exitPrice, \"Long exit price\")",
        "// Calculates the average profit percentage for all closed trades.//@version=6strategy(\"strategy.closedtrades.exit_price Example 2\")// Strategy calls to create single short and long trades.if bar_index == last_bar_index - 15    strategy.entry(\"Long Entry\", strategy.long)else if bar_index == last_bar_index - 10    strategy.close(\"Long Entry\")    strategy.entry(\"Short\", strategy.short)else if bar_index == last_bar_index - 5    strategy.close(\"Short\")// Calculate profit for both closed trades.profitPct = 0.0for tradeNo = 0 to strategy.closedtrades - 1    entryP = strategy.closedtrades.entry_price(tradeNo)    exitP = strategy.closedtrades.exit_price(tradeNo)    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100    // Calculate average profit percent for both closed trades.avgProfitPct = nz(profitPct / strategy.closedtrades)plot(avgProfitPct)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_price",
          "href": "fun_strategy.closedtrades.entry_price"
        }
      ]
    },
    "fun_strategy.closedtrades.exit_time": {
      "id": "fun_strategy.closedtrades.exit_time",
      "name": "strategy.closedtrades.exit_time",
      "description": "Returns the UNIX time of the closed trade's exit,\n                        expressed in milliseconds.",
      "syntax": "strategy.closedtrades.exit_time(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.closedtrades.exit_time Example 1\")// Enter long trades on three rising bars; exit on two falling bars.if ta.rising(close, 3)    strategy.entry(\"Long\", strategy.long)if ta.falling(close, 2)    strategy.close(\"Long\")// Calculate the average trade duration. avgTradeDuration() =>    sumTradeDuration = 0    for i = 0 to strategy.closedtrades - 1        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)    result = nz(sumTradeDuration / strategy.closedtrades)// Display average duration converted to seconds and formatted using 2 decimal points.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")",
        "// Reopens a closed trade after X seconds.//@version=6strategy(\"strategy.closedtrades.exit_time Example 2\")// Strategy calls to emulate a single long trade at the first bar.if bar_index == 0    strategy.entry(\"Long\", strategy.long)reopenPositionAfter(timeSec) =>    if strategy.closedtrades > 0        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000            strategy.entry(\"Long\", strategy.long)// Reopen last closed position after 120 sec.                reopenPositionAfter(120)if ta.change(strategy.opentrades) != 0    strategy.exit(\"Long\", stop = low * 0.9, profit = high * 2.5)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_time",
          "href": "fun_strategy.closedtrades.entry_time"
        }
      ]
    },
    "fun_strategy.closedtrades.max_drawdown": {
      "id": "fun_strategy.closedtrades.max_drawdown",
      "name": "strategy.closedtrades.max_drawdown",
      "description": "Returns the maximum drawdown of the closed trade,\n                        i.e., the maximum possible loss during the trade, expressed in strategy.account_currency.",
      "syntax": "strategy.closedtrades.max_drawdown(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.max_drawdown` Example\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Get the biggest max trade drawdown value from all of the closed trades.maxTradeDrawDown() =>    maxDrawdown = 0.0    for tradeNo = 0 to strategy.closedtrades - 1        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))    result = maxDrawdownplot(maxTradeDrawDown(), \"Biggest max drawdown\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.max_drawdown",
          "href": "fun_strategy.opentrades.max_drawdown"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "fun_strategy.closedtrades.max_drawdown_percent": {
      "id": "fun_strategy.closedtrades.max_drawdown_percent",
      "name": "strategy.closedtrades.max_drawdown_percent",
      "description": "Returns the maximum drawdown of the closed trade,\n                        i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by\n                        formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.",
      "syntax": "strategy.closedtrades.max_drawdown_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.max_drawdown",
          "href": "fun_strategy.closedtrades.max_drawdown"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "fun_strategy.closedtrades.max_runup": {
      "id": "fun_strategy.closedtrades.max_runup",
      "name": "strategy.closedtrades.max_runup",
      "description": "Returns the maximum run up of the closed trade,\n                        i.e., the maximum possible profit during the trade, expressed in strategy.account_currency.",
      "syntax": "strategy.closedtrades.max_runup(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.max_runup` Example\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Get the biggest max trade runup value from all of the closed trades.maxTradeRunUp() =>    maxRunup = 0.0    for tradeNo = 0 to strategy.closedtrades - 1        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))    result = maxRunupplot(maxTradeRunUp(), \"Max trade runup\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.max_runup",
          "href": "fun_strategy.opentrades.max_runup"
        },
        {
          "name": "strategy.max_runup",
          "href": "var_strategy.max_runup"
        }
      ]
    },
    "fun_strategy.closedtrades.max_runup_percent": {
      "id": "fun_strategy.closedtrades.max_runup_percent",
      "name": "strategy.closedtrades.max_runup_percent",
      "description": "Returns the maximum run-up of the closed trade,\n                        i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by\n                        formula: Highest Value During Trade / (Entry Price x Quantity) * 100.",
      "syntax": "strategy.closedtrades.max_runup_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.max_runup",
          "href": "fun_strategy.closedtrades.max_runup"
        },
        {
          "name": "strategy.max_runup",
          "href": "var_strategy.max_runup"
        }
      ]
    },
    "fun_strategy.closedtrades.profit": {
      "id": "fun_strategy.closedtrades.profit",
      "name": "strategy.closedtrades.profit",
      "description": "Returns the profit/loss of the closed trade,\n                        expressed in strategy.account_currency. Losses\n                        are expressed as negative values.",
      "syntax": "strategy.closedtrades.profit(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.profit` Example\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculate average gross profit by adding the difference between gross profit and commission.avgGrossProfit() =>    sumGrossProfit = 0.0    for tradeNo = 0 to strategy.closedtrades - 1        sumGrossProfit += strategy.closedtrades.profit(tradeNo) - strategy.closedtrades.commission(tradeNo)    result = nz(sumGrossProfit / strategy.closedtrades)    plot(avgGrossProfit(), \"Average gross profit\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.profit",
          "href": "fun_strategy.opentrades.profit"
        },
        {
          "name": "strategy.closedtrades.commission",
          "href": "fun_strategy.closedtrades.commission"
        }
      ]
    },
    "fun_strategy.closedtrades.profit_percent": {
      "id": "fun_strategy.closedtrades.profit_percent",
      "name": "strategy.closedtrades.profit_percent",
      "description": "Returns the profit/loss value of the closed trade,\n                        expressed as a percentage. Losses are expressed as negative values.",
      "syntax": "strategy.closedtrades.profit_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.profit",
          "href": "fun_strategy.closedtrades.profit"
        }
      ]
    },
    "fun_strategy.closedtrades.size": {
      "id": "fun_strategy.closedtrades.size",
      "name": "strategy.closedtrades.size",
      "description": "Returns the direction and the number of contracts\n                        traded in the closed trade. If the value is > 0, the market position was long. If the value\n                        is < 0, the market position was short.",
      "syntax": "strategy.closedtrades.size(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.closedtrades.size` Example 1\")// We calculate the max amt of shares we can buy.amtShares = math.floor(strategy.equity / close)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 barsif bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long, qty = amtShares)if bar_index % 20 == 0    strategy.close(\"Long\")// Plot the number of contracts traded in the last closed trade.     plot(strategy.closedtrades.size(strategy.closedtrades - 1), \"Number of contracts traded\")",
        "// Calculates the average profit percentage for all closed trades.//@version=6strategy(\"`strategy.closedtrades.size` Example 2\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculate profit for both closed trades.profitPct = 0.0for tradeNo = 0 to strategy.closedtrades - 1    entryP = strategy.closedtrades.entry_price(tradeNo)    exitP = strategy.closedtrades.exit_price(tradeNo)    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100    // Calculate average profit percent for both closed trades.avgProfitPct = nz(profitPct / strategy.closedtrades)plot(avgProfitPct)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.size",
          "href": "fun_strategy.opentrades.size"
        },
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        }
      ]
    },
    "fun_strategy.convert_to_account": {
      "id": "fun_strategy.convert_to_account",
      "name": "strategy.convert_to_account",
      "description": "Converts the value from the currency that the\n                        symbol on the chart is traded in (syminfo.currency) to\n                        the currency used by the strategy (strategy.account_currency).",
      "syntax": "strategy.convert_to_account(value) → series float",
      "arguments": [
        {
          "name": "value",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.convert_to_account` Example 1\", currency = currency.EUR)plot(close, \"Close price using default currency\")plot(strategy.convert_to_account(close), \"Close price converted to strategy currency\")",
        "// Calculates the \"Buy and hold return\" using your account's currency.//@version=6strategy(\"`strategy.convert_to_account` Example 2\", currency = currency.EUR)dateInput = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"From Date\", confirm = true)buyAndHoldReturnPct(fromDate) =>    if time >= fromDate        money = close * syminfo.pointvalue        var initialBal = strategy.convert_to_account(money)        (strategy.convert_to_account(money) - initialBal) / initialBal * 100        plot(buyAndHoldReturnPct(dateInput))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.convert_to_symbol",
          "href": "fun_strategy.convert_to_symbol"
        }
      ]
    },
    "fun_strategy.convert_to_symbol": {
      "id": "fun_strategy.convert_to_symbol",
      "name": "strategy.convert_to_symbol",
      "description": "Converts the value from the currency used by the\n                        strategy (strategy.account_currency) to the\n                        currency that the symbol on the chart is traded in (syminfo.currency).",
      "syntax": "strategy.convert_to_symbol(value) → series float",
      "arguments": [
        {
          "name": "value",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.convert_to_symbol` Example\", currency = currency.EUR)// Calculate the max qty we can buy using current chart's currency.calcContracts(accountMoney) =>    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)// Return max qty we can buy using 300 eurosqt = calcContracts(300)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long, qty = qt)if bar_index % 20 == 0    strategy.close(\"Long\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.convert_to_account",
          "href": "fun_strategy.convert_to_account"
        }
      ]
    },
    "fun_strategy.default_entry_qty": {
      "id": "fun_strategy.default_entry_qty",
      "name": "strategy.default_entry_qty",
      "description": "Calculates the default quantity, in units, of an\n                        entry order from strategy.entry or strategy.order\n                        if it were to fill at the specified fill_price value. The calculation depends on\n                        several strategy properties, including default_qty_type,\n                        default_qty_value, currency, and other parameters in the strategy function\n                        and their representation in the \"Properties\" tab of the strategy's settings.",
      "syntax": "strategy.default_entry_qty(fill_price) → series float",
      "arguments": [
        {
          "name": "fill_price",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"Supertrend Strategy\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 15)//@variable The length of the ATR calculation.atrPeriod = input(10, \"ATR Length\")//@variable The ATR multiplier.factor = input.float(3.0, \"Factor\", step = 0.01)//@variable The tick offset of the stop order.stopOffsetInput = input.int(100, \"Tick offset for entry stop\")// Get the direction of the SuperTrend.[_, direction] = ta.supertrend(factor, atrPeriod)if ta.change(direction) < 0    //@variable The stop price of the entry order.    stopPrice = close + syminfo.mintick * stopOffsetInput    //@variable The expected default fill quantity at the `stopPrice`. This value may not reflect actual qty of the filled order, because fill price may be different.    calculatedQty = strategy.default_entry_qty(stopPrice)    strategy.entry(\"My Long Entry Id\", strategy.long, stop = stopPrice)    label.new(bar_index, stopPrice, str.format(\"Stop set at {0}\\nExpected qty at {0}: {1}\", math.round_to_mintick(stopPrice), calculatedQty))if ta.change(direction) > 0    strategy.close_all()"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.entry": {
      "id": "fun_strategy.entry",
      "name": "strategy.entry",
      "description": "Creates a new order to open or add to a position.\n                        If an unfilled order with the same id exists, a call to this command modifies that\n                        order.",
      "syntax": "strategy.entry(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "direction",
          "type": "series strategy_direction",
          "description": "The"
        },
        {
          "name": "qty",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "limit",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "stop",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "oca_name",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "oca_type",
          "type": "input string",
          "description": "Optional."
        },
        {
          "name": "comment",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_message",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "disable_alert",
          "type": "series bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6strategy(\"Market order strategy\", overlay = true)// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)// Place a market order to close the short trade and enter a long position when `sma14` crosses over `sma28`.if ta.crossover(sma14, sma28)    strategy.entry(\"My Long Entry ID\", strategy.long)// Place a market order to close the long trade and enter a short position when `sma14` crosses under `sma28`.if ta.crossunder(sma14, sma28)    strategy.entry(\"My Short Entry ID\", strategy.short)",
        "//@version=6strategy(\"Limit order strategy\", overlay=true, margin_long=100, margin_short=100)//@variable The distance from the `close` price for each limit order.float limitOffsetInput = input.int(100, \"Limit offset, in ticks\", 1) * syminfo.mintick//@function Draws a label and line at the specified `price` to visualize a limit order's level. drawLimit(float price, bool isLong) =>    color col = isLong ? color.blue : color.red    label.new(         bar_index, price, (isLong ? \"Long\" : \"Short\") + \" limit order created\",          style = label.style_label_right, color = col, textcolor = color.white     )    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)//@function Stops the `l` line from extending further.method stopExtend(line l) =>    l.set_x2(bar_index)    l.set_extend(extend.none)// Initialize two `line` variables to reference limit line IDs.var line longLimit  = navar line shortLimit = na// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)if ta.crossover(sma14, sma28)    // Cancel any unfilled sell orders with the specified ID.    strategy.cancel(\"My Short Entry ID\")    //@variable The limit price level. Its value is `limitOffsetInput` ticks below the current `close`.    float limitLevel = close - limitOffsetInput    // Place a long limit order to close the short trade and enter a long position at the `limitLevel`.    strategy.entry(\"My Long Entry ID\", strategy.long, limit = limitLevel)    // Make new drawings for the long limit and stop extending the `shortLimit` line.    longLimit := drawLimit(limitLevel, isLong = true)    shortLimit.stopExtend()    if ta.crossunder(sma14, sma28)    // Cancel any unfilled buy orders with the specified ID.    strategy.cancel(\"My Long Entry ID\")    //@variable The limit price level. Its value is `limitOffsetInput` ticks above the current `close`.    float limitLevel = close + limitOffsetInput    // Place a short limit order to close the long trade and enter a short position at the `limitLevel`.    strategy.entry(\"My Short Entry ID\", strategy.short, limit = limitLevel)    // Make new drawings for the short limit and stop extending the `shortLimit` line.    shortLimit := drawLimit(limitLevel, isLong = false)    longLimit.stopExtend()"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.exit": {
      "id": "fun_strategy.exit",
      "name": "strategy.exit",
      "description": "Creates price-based orders to exit from an open\n                        position. If unfilled exit orders with the same id exist, calls to this command\n                        modify those orders. This command can generate more than one type of exit order, depending on\n                        the specified parameters. However, it does not create market orders. To exit from a position with a market order, use strategy.close\n                        or strategy.close_all.",
      "syntax": "strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, comment_profit, comment_loss, comment_trailing, alert_message, alert_profit, alert_loss, alert_trailing, disable_alert) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "from_entry",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "qty",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "qty_percent",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "profit",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "limit",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "loss",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "stop",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "trail_price",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "trail_points",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "trail_offset",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "oca_name",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "comment",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "comment_profit",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "comment_loss",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "comment_trailing",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_message",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_profit",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_loss",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_trailing",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "disable_alert",
          "type": "series bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6strategy(\"Exit bracket strategy\", overlay = true)// Inputs that define the profit and loss amount of each trade as a tick distance from the entry price.int profitDistanceInput = input.int(100, \"Profit distance, in ticks\", 1)int lossDistanceInput   = input.int(100, \"Loss distance, in ticks\", 1)// Variables to track the take-profit and stop-loss price. var float takeProfit = navar float stopLoss   = na// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)if ta.crossover(sma14, sma28) and strategy.opentrades == 0    // Place a market order to enter a long position.    strategy.entry(\"My Long Entry ID\", strategy.long)    // Place a take-profit and stop-loss order when the entry order fills.     strategy.exit(\"My Long Exit ID\", \"My Long Entry ID\", profit = profitDistanceInput, loss = lossDistanceInput)if ta.change(strategy.opentrades) == 1    //@variable The long entry price.    float entryPrice = strategy.opentrades.entry_price(0)    // Update the `takeProfit` and `stopLoss` values.    takeProfit := entryPrice + profitDistanceInput * syminfo.mintick    stopLoss   := entryPrice - lossDistanceInput * syminfo.mintickif ta.change(strategy.closedtrades) == 1    // Reset the `takeProfit` and `stopLoss`.    takeProfit := na    stopLoss   := na// Plot the `takeProfit` and `stopLoss`.plot(takeProfit, \"Take-profit level\", color.green, 2, plot.style_linebr)plot(stopLoss, \"Stop-loss level\", color.red, 2, plot.style_linebr)",
        "//@version=6strategy(\"Trailing stop strategy\", overlay = true)//@variable The distance required to activate the trailing stop.float activationDistanceInput = input.int(100, \"Trail activation distance, in ticks\") * syminfo.mintick //@variable The number of ticks the trailing stop follows behind the price as it reaches new peaks. int trailDistanceInput = input.int(100, \"Trail distance, in ticks\")//@function Draws a label and line at the specified `price` to visualize a trailing stop order's activation level. drawActivation(float price) =>    label.new(         bar_index, price, \"Activation level\", style = label.style_label_right,          color = color.gray, textcolor = color.white     )    line.new(         bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = color.gray     )//@function Stops the `l` line from extending further.method stopExtend(line l) =>    l.set_x2(bar_index)    l.set_extend(extend.none)// The activation line, active trailing stop price, and active trailing stop flag. var line activationLine     = navar float trailingStopPrice = navar bool isActive           = falseif bar_index % 100 == 0 and strategy.opentrades == 0    trailingStopPrice := na    isActive          := false    // Place a market order to enter a long position.    strategy.entry(\"My Long Entry ID\", strategy.long)    //@variable The activation level's price.     float activationPrice = close + activationDistanceInput    // Create a trailing stop order that activates the defined number of ticks above the entry price.    strategy.exit(         \"My Long Exit ID\", \"My Long Entry ID\", trail_price = activationPrice, trail_offset = trailDistanceInput,         oca_name = \"Exit\"     )    // Create new drawings at the `activationPrice`.    activationLine := drawActivation(activationPrice)// Logic for trailing stop visualization. if strategy.opentrades == 1    // Stop extending the `activationLine` when the stop activates.    if not isActive and high > activationLine.get_price(bar_index)        isActive := true        activationLine.stopExtend()    // Update the `trailingStopPrice` while the trailing stop is active.     if isActive        float offsetPrice = high - trailDistanceInput * syminfo.mintick        trailingStopPrice := math.max(nz(trailingStopPrice, offsetPrice), offsetPrice)// Close the trade with a market order if the trailing stop does not activate before the next 300th bar. if not isActive and bar_index % 300 == 0    strategy.close_all(\"Market close\")// Reset the `trailingStopPrice` and `isActive` flags when the trade closes, and stop extending the `activationLine`.if ta.change(strategy.closedtrades) > 0    if not isActive        activationLine.stopExtend()    trailingStopPrice := na    isActive          := false// Plot the `trailingStopPrice`.plot(trailingStopPrice, \"Trailing stop\", color.red, 3, plot.style_linebr)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.opentrades.commission": {
      "id": "fun_strategy.opentrades.commission",
      "name": "strategy.opentrades.commission",
      "description": "Returns the sum of entry and exit fees paid in the\n                        open trade, expressed in strategy.account_currency.",
      "syntax": "strategy.opentrades.commission(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "// Calculates the gross profit or loss for the current open position.//@version=6strategy(\"`strategy.opentrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculate gross profit or loss for open positions only.tradeOpenGrossPL() =>    sumOpenGrossPL = 0.0    for tradeNo = 0 to strategy.opentrades - 1        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)    result = sumOpenGrossPL    plot(tradeOpenGrossPL())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.closedtrades.commission",
          "href": "fun_strategy.closedtrades.commission"
        }
      ]
    },
    "fun_strategy.opentrades.entry_bar_index": {
      "id": "fun_strategy.opentrades.entry_bar_index",
      "name": "strategy.opentrades.entry_bar_index",
      "description": "Returns the bar_index of the open trade's entry.",
      "syntax": "strategy.opentrades.entry_bar_index(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "// Wait 10 bars and then close the position.//@version=6strategy(\"`strategy.opentrades.entry_bar_index` Example\")barsSinceLastEntry() =>    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na// Enter a long position if there are no open positions.if strategy.opentrades == 0    strategy.entry(\"Long\", strategy.long)// Close the long position after 10 bars. if barsSinceLastEntry() >= 10    strategy.close(\"Long\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_bar_index",
          "href": "fun_strategy.closedtrades.entry_bar_index"
        },
        {
          "name": "strategy.closedtrades.exit_bar_index",
          "href": "fun_strategy.closedtrades.exit_bar_index"
        }
      ]
    },
    "fun_strategy.opentrades.entry_comment": {
      "id": "fun_strategy.opentrades.entry_comment",
      "name": "strategy.opentrades.entry_comment",
      "description": "Returns the comment message of the open trade's\n                        entry, or\n                        na if there is no entry with this\n                        trade_num.",
      "syntax": "strategy.opentrades.entry_comment(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.opentrades.entry_comment()` Example\", overlay = true)stopPrice = open * 1.01longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))var testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)if barstate.islastconfirmedhistory or barstate.isrealtime    table.cell(testTable, 0, 0, 'Last entry stats')    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.opentrades.entry_comment(strategy.opentrades - 1))    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.opentrades.entry_price(strategy.opentrades - 1)))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        }
      ]
    },
    "fun_strategy.opentrades.entry_id": {
      "id": "fun_strategy.opentrades.entry_id",
      "name": "strategy.opentrades.entry_id",
      "description": "Returns the id of the open trade's entry.",
      "syntax": "strategy.opentrades.entry_id(trade_num) → series string",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.opentrades.entry_id` Example\", overlay = true)// We enter a long position when 14 period sma crosses over 28 period sma.// We enter a short position when 14 period sma crosses under 28 period sma.longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))// Strategy calls to enter a long or short position when the corresponding condition is met.if longCondition    strategy.entry(\"Long entry at bar #\" + str.tostring(bar_index), strategy.long)if shortCondition    strategy.entry(\"Short entry at bar #\" + str.tostring(bar_index), strategy.short)// Display ID of the latest open position.if barstate.islastconfirmedhistory    label.new(bar_index, high + (2 * ta.tr), \"Last opened position is \\n \" + strategy.opentrades.entry_id(strategy.opentrades - 1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.entry_bar_index",
          "href": "fun_strategy.opentrades.entry_bar_index"
        },
        {
          "name": "strategy.opentrades.entry_price",
          "href": "fun_strategy.opentrades.entry_price"
        },
        {
          "name": "strategy.opentrades.entry_time",
          "href": "fun_strategy.opentrades.entry_time"
        }
      ]
    },
    "fun_strategy.opentrades.entry_price": {
      "id": "fun_strategy.opentrades.entry_price",
      "name": "strategy.opentrades.entry_price",
      "description": "Returns the price of the open trade's entry.",
      "syntax": "strategy.opentrades.entry_price(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.opentrades.entry_price Example 1\", overlay = true)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if ta.crossover(close, ta.sma(close, 14))    strategy.entry(\"Long\", strategy.long)// Return the entry price for the latest closed trade.currEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)currExitPrice = currEntryPrice * 1.05if high >= currExitPrice    strategy.close(\"Long\")plot(currEntryPrice, \"Long entry price\", style = plot.style_linebr)plot(currExitPrice, \"Long exit price\", color.green, style = plot.style_linebr)",
        "// Calculates the average price for the open position.//@version=6strategy(\"strategy.opentrades.entry_price Example 2\", pyramiding = 2)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculates the average price for the open position.avgOpenPositionPrice() =>    sumOpenPositionPrice = 0.0    for tradeNo = 0 to strategy.opentrades - 1        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size    result = nz(sumOpenPositionPrice / strategy.opentrades)plot(avgOpenPositionPrice())"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.exit_price",
          "href": "fun_strategy.closedtrades.exit_price"
        }
      ]
    },
    "fun_strategy.opentrades.entry_time": {
      "id": "fun_strategy.opentrades.entry_time",
      "name": "strategy.opentrades.entry_time",
      "description": "Returns the UNIX time of the open trade's entry,\n                        expressed in milliseconds.",
      "syntax": "strategy.opentrades.entry_time(trade_num) → series int",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.opentrades.entry_time Example\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculates duration in milliseconds since the last position was opened.timeSinceLastEntry()=>    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : naplot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, \"Days since last entry\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.entry_time",
          "href": "fun_strategy.closedtrades.entry_time"
        },
        {
          "name": "strategy.closedtrades.exit_time",
          "href": "fun_strategy.closedtrades.exit_time"
        }
      ]
    },
    "fun_strategy.opentrades.max_drawdown": {
      "id": "fun_strategy.opentrades.max_drawdown",
      "name": "strategy.opentrades.max_drawdown",
      "description": "Returns the maximum drawdown of the open trade,\n                        i.e., the maximum possible loss during the trade, expressed in strategy.account_currency.",
      "syntax": "strategy.opentrades.max_drawdown(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.opentrades.max_drawdown Example 1\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Plot the max drawdown of the latest open trade.plot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), \"Max drawdown of the latest open trade\")",
        "// Calculates the max trade drawdown value for all open trades.//@version=6strategy(\"`strategy.opentrades.max_drawdown` Example 2\", pyramiding = 100)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Get the biggest max trade drawdown value from all of the open trades.maxTradeDrawDown() =>    maxDrawdown = 0.0    for tradeNo = 0 to strategy.opentrades - 1        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))    result = maxDrawdownplot(maxTradeDrawDown(), \"Biggest max drawdown\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.max_drawdown",
          "href": "fun_strategy.closedtrades.max_drawdown"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "fun_strategy.opentrades.max_drawdown_percent": {
      "id": "fun_strategy.opentrades.max_drawdown_percent",
      "name": "strategy.opentrades.max_drawdown_percent",
      "description": "Returns the maximum drawdown of the open trade,\n                        i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by\n                        formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.",
      "syntax": "strategy.opentrades.max_drawdown_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.max_drawdown",
          "href": "fun_strategy.opentrades.max_drawdown"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "fun_strategy.opentrades.max_runup": {
      "id": "fun_strategy.opentrades.max_runup",
      "name": "strategy.opentrades.max_runup",
      "description": "Returns the maximum run up of the open trade,\n                        i.e., the maximum possible profit during the trade, expressed in strategy.account_currency.",
      "syntax": "strategy.opentrades.max_runup(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.opentrades.max_runup Example 1\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Plot the max runup of the latest open trade.plot(strategy.opentrades.max_runup(strategy.opentrades - 1), \"Max runup of the latest open trade\")",
        "// Calculates the max trade runup value for all open trades.//@version=6strategy(\"strategy.opentrades.max_runup Example 2\", pyramiding = 100)// Enter a long position every 30 bars.if bar_index % 30 == 0    strategy.entry(\"Long\", strategy.long)// Calculate biggest max trade runup value from all of the open trades.maxOpenTradeRunUp() =>    maxRunup = 0.0    for tradeNo = 0 to strategy.opentrades - 1        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))    result = maxRunupplot(maxOpenTradeRunUp(), \"Biggest max runup of all open trades\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.max_runup",
          "href": "fun_strategy.closedtrades.max_runup"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "fun_strategy.opentrades.max_runup_percent": {
      "id": "fun_strategy.opentrades.max_runup_percent",
      "name": "strategy.opentrades.max_runup_percent",
      "description": "Returns the maximum run-up of the open trade,\n                        i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by\n                        formula: Highest Value During Trade / (Entry Price x Quantity) * 100.",
      "syntax": "strategy.opentrades.max_runup_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.max_runup",
          "href": "fun_strategy.opentrades.max_runup"
        },
        {
          "name": "strategy.max_runup",
          "href": "var_strategy.max_runup"
        }
      ]
    },
    "fun_strategy.opentrades.profit": {
      "id": "fun_strategy.opentrades.profit",
      "name": "strategy.opentrades.profit",
      "description": "Returns the profit/loss of the open trade,\n                        expressed in strategy.account_currency. Losses\n                        are expressed as negative values.",
      "syntax": "strategy.opentrades.profit(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "// Returns the profit of the last open trade.//@version=6strategy(\"`strategy.opentrades.profit` Example 1\", commission_type = strategy.commission.percent, commission_value = 0.1)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")plot(strategy.opentrades.profit(strategy.opentrades - 1), \"Profit of the latest open trade\")",
        "// Calculates the profit for all open trades.//@version=6strategy(\"`strategy.opentrades.profit` Example 2\", pyramiding = 5)// Strategy calls to enter 5 long positions every 2 bars.if bar_index % 2 == 0    strategy.entry(\"Long\", strategy.long, qty = 5)// Calculate open profit or loss for the open positions.tradeOpenPL() =>    sumProfit = 0.0    for tradeNo = 0 to strategy.opentrades - 1        sumProfit += strategy.opentrades.profit(tradeNo)    result = sumProfit    plot(tradeOpenPL(), \"Profit of all open trades\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.profit",
          "href": "fun_strategy.closedtrades.profit"
        },
        {
          "name": "strategy.openprofit",
          "href": "var_strategy.openprofit"
        },
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.grossprofit",
          "href": "var_strategy.grossprofit"
        }
      ]
    },
    "fun_strategy.opentrades.profit_percent": {
      "id": "fun_strategy.opentrades.profit_percent",
      "name": "strategy.opentrades.profit_percent",
      "description": "Returns the profit/loss of the open trade,\n                        expressed as a percentage. Losses are expressed as negative values.",
      "syntax": "strategy.opentrades.profit_percent(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.opentrades.profit",
          "href": "fun_strategy.opentrades.profit"
        }
      ]
    },
    "fun_strategy.opentrades.size": {
      "id": "fun_strategy.opentrades.size",
      "name": "strategy.opentrades.size",
      "description": "Returns the direction and the number of contracts\n                        traded in the open trade. If the value is > 0, the market position was long. If the value is\n                        < 0, the market position was short.",
      "syntax": "strategy.opentrades.size(trade_num) → series float",
      "arguments": [
        {
          "name": "trade_num",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"`strategy.opentrades.size` Example 1\")// We calculate the max amt of shares we can buy.amtShares = math.floor(strategy.equity / close)// Strategy calls to enter long trades every 15 bars and exit long trades every 20 barsif bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long, qty = amtShares)if bar_index % 20 == 0    strategy.close(\"Long\")// Plot the number of contracts in the latest open trade.plot(strategy.opentrades.size(strategy.opentrades - 1), \"Amount of contracts in latest open trade\")",
        "// Calculates the average profit percentage for all open trades.//@version=6strategy(\"`strategy.opentrades.size` Example 2\")// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.if bar_index % 15 == 0    strategy.entry(\"Long\", strategy.long)if bar_index % 20 == 0    strategy.close(\"Long\")// Calculate profit for all open trades.profitPct = 0.0for tradeNo = 0 to strategy.opentrades - 1    entryP = strategy.opentrades.entry_price(tradeNo)    exitP = close    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100    // Calculate average profit percent for all open trades.avgProfitPct = nz(profitPct / strategy.opentrades)plot(avgProfitPct)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy.closedtrades.size",
          "href": "fun_strategy.closedtrades.size"
        },
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        }
      ]
    },
    "fun_strategy.order": {
      "id": "fun_strategy.order",
      "name": "strategy.order",
      "description": "Creates a new order to open, add to, or exit from\n                        a position. If an unfilled order with the same id exists, a call to this command\n                        modifies that order.",
      "syntax": "strategy.order(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void",
      "arguments": [
        {
          "name": "id",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "direction",
          "type": "series strategy_direction",
          "description": "The"
        },
        {
          "name": "qty",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "limit",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "stop",
          "type": "series int/float",
          "description": "Optional."
        },
        {
          "name": "oca_name",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "oca_type",
          "type": "input string",
          "description": "Optional."
        },
        {
          "name": "comment",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "alert_message",
          "type": "series string",
          "description": "Optional."
        },
        {
          "name": "disable_alert",
          "type": "series bool",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6strategy(\"Market order strategy\", overlay = true)// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)// Place a market order to enter a long position when `sma14` crosses over `sma28`.if ta.crossover(sma14, sma28) and strategy.position_size == 0    strategy.order(\"My Long Entry ID\", strategy.long)// Place a market order to sell the same quantity as the long trade when `sma14` crosses under `sma28`, // effectively closing the long position.if ta.crossunder(sma14, sma28) and strategy.position_size > 0    strategy.order(\"My Long Exit ID\", strategy.short)",
        "//@version=6strategy(\"Limit and stop exit strategy\", overlay = true)//@variable The distance from the long entry price for each short limit order.float shortOffsetInput = input.int(200, \"Sell limit/stop offset, in ticks\", 1) * syminfo.mintick//@function Draws a label and line at the specified `price` to visualize a limit order's level. drawLimit(float price, bool isLong, bool isStop = false) =>    color col = isLong ? color.blue : color.red    label.new(         bar_index, price, (isLong ? \"Long \" : \"Short \") + (isStop ? \"stop\" : \"limit\") + \" order created\",          style = label.style_label_right, color = col, textcolor = color.white     )    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)//@function Stops the `l` line from extending further.method stopExtend(line l) =>    l.set_x2(bar_index)    l.set_extend(extend.none)// Initialize two `line` variables to reference limit and stop line IDs.var line profitLimit = navar line lossStop    = na// Calculate a 14-bar and 28-bar moving average of `close` prices.float sma14 = ta.sma(close, 14)float sma28 = ta.sma(close, 28)if ta.crossover(sma14, sma28) and strategy.position_size == 0    // Place a market order to enter a long position.    strategy.order(\"My Long Entry ID\", strategy.long)    if strategy.position_size > 0 and strategy.position_size[1] == 0    //@variable The entry price of the long trade.     float entryPrice = strategy.opentrades.entry_price(0)    // Calculate short limit and stop levels above and below the `entryPrice`.    float profitLevel = entryPrice + shortOffsetInput    float lossLevel   = entryPrice - shortOffsetInput    // Place short limit and stop orders at the `profitLevel` and `lossLevel`.     strategy.order(\"Profit\", strategy.short, limit = profitLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)    strategy.order(\"Loss\", strategy.short, stop = lossLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)    // Make new drawings for the `profitLimit` and `lossStop` lines.    profitLimit := drawLimit(profitLevel, isLong = false)    lossStop    := drawLimit(lossLevel, isLong = false, isStop = true)if ta.change(strategy.closedtrades) > 0    // Stop extending the `profitLimit` and `lossStop` lines.    profitLimit.stopExtend()    lossStop.stopExtend()"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.risk.allow_entry_in": {
      "id": "fun_strategy.risk.allow_entry_in",
      "name": "strategy.risk.allow_entry_in",
      "description": "This function can be used to specify in which\n                        market direction the strategy.entry function is allowed to\n                        open positions.",
      "syntax": "strategy.risk.allow_entry_in(value) → void",
      "arguments": [
        {
          "name": "value",
          "type": "simple string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6strategy(\"strategy.risk.allow_entry_in\")strategy.risk.allow_entry_in(strategy.direction.long)if open > close    strategy.entry(\"Long\", strategy.long)// Instead of opening a short position with 10 contracts, this command will close long entries.if open < close    strategy.entry(\"Short\", strategy.short, qty = 10)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.risk.max_cons_loss_days": {
      "id": "fun_strategy.risk.max_cons_loss_days",
      "name": "strategy.risk.max_cons_loss_days",
      "description": "The purpose of this rule is to cancel all pending\n                        orders, close all open positions and stop placing orders after a specified number of consecutive\n                        days with losses. The rule affects the whole strategy.",
      "syntax": "strategy.risk.max_cons_loss_days(count, alert_message) → void",
      "arguments": [
        {
          "name": "count",
          "type": "simple int",
          "description": "A"
        },
        {
          "name": "alert_message",
          "type": "simple string",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6strategy(\"risk.max_cons_loss_days Demo 1\")strategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.plot(strategy.position_size)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.risk.max_drawdown": {
      "id": "fun_strategy.risk.max_drawdown",
      "name": "strategy.risk.max_drawdown",
      "description": "The purpose of this rule is to determine maximum\n                        drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all\n                        pending orders are cancelled, all open positions are closed and no new orders can be placed.",
      "syntax": "strategy.risk.max_drawdown(value, type, alert_message) → void",
      "arguments": [
        {
          "name": "value",
          "type": "simple int/float",
          "description": "A"
        },
        {
          "name": "type",
          "type": "simple string",
          "description": "A"
        },
        {
          "name": "alert_message",
          "type": "simple string",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6strategy(\"risk.max_drawdown Demo 1\")strategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equityplot(strategy.position_size)",
        "//@version=6strategy(\"risk.max_drawdown Demo 2\", currency = \"EUR\")strategy.risk.max_drawdown(2000, strategy.cash) // set maximum drawdown to 2000 EUR from maximum equityplot(strategy.position_size)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.risk.max_intraday_filled_orders": {
      "id": "fun_strategy.risk.max_intraday_filled_orders",
      "name": "strategy.risk.max_intraday_filled_orders",
      "description": "The purpose of this rule is to determine maximum\n                        number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The\n                        rule affects the whole strategy. Once the maximum number of filled orders is reached, all\n                        pending orders are cancelled, all open positions are closed and no new orders can be placed till\n                        the end of the current trading session.",
      "syntax": "strategy.risk.max_intraday_filled_orders(count, alert_message) → void",
      "arguments": [
        {
          "name": "count",
          "type": "simple int",
          "description": "A"
        },
        {
          "name": "alert_message",
          "type": "simple string",
          "description": "An"
        }
      ],
      "examples": [
        "//@version=6strategy(\"risk.max_intraday_filled_orders Demo\")strategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).if open > close    strategy.entry(\"buy\", strategy.long)if open < close    strategy.entry(\"sell\", strategy.short)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_strategy.risk.max_intraday_loss": {
      "id": "fun_strategy.risk.max_intraday_loss",
      "name": "strategy.risk.max_intraday_loss",
      "description": "The maximum loss value allowed during a day. It is\n                        specified either in money (base currency), or in percentage of maximum intraday equity (0 -100).",
      "syntax": "strategy.risk.max_intraday_loss(value, type, alert_message) → void",
      "arguments": [
        {
          "name": "value",
          "type": "simple int/float",
          "description": "A"
        },
        {
          "name": "type",
          "type": "simple string",
          "description": "A"
        },
        {
          "name": "alert_message",
          "type": "simple string",
          "description": "An"
        }
      ],
      "examples": [
        "// Sets the maximum intraday loss using the strategy's equity value.//@version=6strategy(\"strategy.risk.max_intraday_loss Example 1\", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)// Input for maximum intraday loss %. lossPct = input.float(10)// Set maximum intraday loss to our lossPct inputstrategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)// Enter Short at bar_index zero.if bar_index == 0    strategy.entry(\"Short\", strategy.short)// Store equity value from the beginning of the dayeqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)// Calculate change of the current equity from the beginning of the current day.eqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)// Plot itplot(eqChgPct) hline(-lossPct)",
        "// Sets the maximum intraday loss using the strategy's cash value.//@version=6strategy(\"strategy.risk.max_intraday_loss Example 2\", overlay = false)// Input for maximum intraday loss in absolute cash value of the symbol. absCashLoss = input.float(5)// Set maximum intraday loss to `absCashLoss` in account currency.strategy.risk.max_intraday_loss(absCashLoss, strategy.cash)// Enter Short at bar_index zero.if bar_index == 0    strategy.entry(\"Short\", strategy.short)// Store the open price value from the beginning of the day.beginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)// Calculate the absolute price change for the current period.priceChg = (close - beginPrice)hline(absCashLoss)plot(priceChg)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.percent_of_equity",
          "href": "const_strategy.percent_of_equity"
        },
        {
          "name": "strategy.cash",
          "href": "const_strategy.cash"
        }
      ]
    },
    "fun_strategy.risk.max_position_size": {
      "id": "fun_strategy.risk.max_position_size",
      "name": "strategy.risk.max_position_size",
      "description": "The purpose of this rule is to determine maximum\n                        size of a market position. The rule affects the following function: strategy.entry.\n                        The 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units,\n                        so the total position size doesn't exceed the value specified in\n                        'strategy.risk.max_position_size'. If minimum possible quantity still violates the rule, the\n                        order will not be placed.",
      "syntax": "strategy.risk.max_position_size(contracts) → void",
      "arguments": [
        {
          "name": "contracts",
          "type": "simple int/float",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6strategy(\"risk.max_position_size Demo\", default_qty_value = 100)strategy.risk.max_position_size(10)if open > close    strategy.entry(\"buy\", strategy.long)plot(strategy.position_size) // max plot value will be 10"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_string": {
      "id": "fun_string",
      "name": "string",
      "description": "Casts na to string",
      "syntax": "string(x) → const string",
      "arguments": [
        {
          "name": "x",
          "type": "const string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_syminfo.prefix": {
      "id": "fun_syminfo.prefix",
      "name": "syminfo.prefix",
      "description": "Returns exchange prefix of the symbol,\n                        e.g. \"NASDAQ\".",
      "syntax": "syminfo.prefix(symbol) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol."
        }
      ],
      "examples": [
        "//@version=6indicator(\"syminfo.prefix fun\", overlay=true)i_sym = input.symbol(\"NASDAQ:AAPL\")pref = syminfo.prefix(i_sym)tick = syminfo.ticker(i_sym)t = ticker.new(pref, tick, session.extended)s = request.security(t, \"1D\", close)plot(s)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.prefix",
          "href": "var_syminfo.prefix"
        },
        {
          "name": "syminfo.ticker",
          "href": "fun_syminfo.ticker"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        }
      ]
    },
    "fun_syminfo.ticker": {
      "id": "fun_syminfo.ticker",
      "name": "syminfo.ticker",
      "description": "Returns symbol name without exchange\n                        prefix, e.g. \"AAPL\".",
      "syntax": "syminfo.ticker(symbol) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol."
        }
      ],
      "examples": [
        "//@version=6indicator(\"syminfo.ticker fun\", overlay=true) i_sym = input.symbol(\"NASDAQ:AAPL\")pref = syminfo.prefix(i_sym)tick = syminfo.ticker(i_sym)t = ticker.new(pref, tick, session.extended)s = request.security(t, \"1D\", close)plot(s)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.prefix",
          "href": "var_syminfo.prefix"
        },
        {
          "name": "syminfo.prefix",
          "href": "fun_syminfo.prefix"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        }
      ]
    },
    "fun_ta.alma": {
      "id": "fun_ta.alma",
      "name": "ta.alma",
      "description": "Arnaud Legoux Moving Average. It uses Gaussian\n                        distribution as weights for moving average.",
      "syntax": "ta.alma(series, length, offset, sigma) → series float",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "offset",
          "type": "simple int/float",
          "description": "Controls"
        },
        {
          "name": "sigma",
          "type": "simple int/float",
          "description": "Changes"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.alma\", overlay=true) plot(ta.alma(close, 9, 0.85, 6))// same on pine, but much less efficientpine_alma(series, windowsize, offset, sigma) =>    m = offset * (windowsize - 1)    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true    s = windowsize / sigma    norm = 0.0    sum = 0.0    for i = 0 to windowsize - 1        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))        norm := norm + weight        sum := sum + series[windowsize - i - 1] * weight    sum / normplot(pine_alma(close, 9, 0.85, 6))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        }
      ]
    },
    "fun_ta.atr": {
      "id": "fun_ta.atr",
      "name": "ta.atr",
      "description": "Function atr (average true range) returns the RMA\n                        of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1])).",
      "syntax": "ta.atr(length) → series float",
      "arguments": [
        {
          "name": "length",
          "type": "simple int",
          "description": "Length"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.atr\")plot(ta.atr(14))//the same on pinepine_atr(length) =>    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))    //true range can be also calculated with ta.tr(true)    ta.rma(trueRange, length)plot(pine_atr(14))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.tr",
          "href": "fun_ta.tr"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        }
      ]
    },
    "fun_ta.barssince": {
      "id": "fun_ta.barssince",
      "name": "ta.barssince",
      "description": "Counts the number of bars since the last time the\n                        condition was true.",
      "syntax": "ta.barssince(condition) → series int",
      "arguments": [
        {
          "name": "condition",
          "type": "series bool",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.barssince\")// get number of bars since last color.green barplot(ta.barssince(close >= open))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.lowestbars",
          "href": "fun_ta.lowestbars"
        },
        {
          "name": "ta.highestbars",
          "href": "fun_ta.highestbars"
        },
        {
          "name": "ta.valuewhen",
          "href": "fun_ta.valuewhen"
        },
        {
          "name": "ta.highest",
          "href": "fun_ta.highest"
        },
        {
          "name": "ta.lowest",
          "href": "fun_ta.lowest"
        }
      ]
    },
    "fun_ta.bb": {
      "id": "fun_ta.bb",
      "name": "ta.bb",
      "description": "Bollinger Bands. A Bollinger Band is a technical\n                        analysis tool defined by a set of lines plotted two standard deviations (positively and\n                        negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted\n                        to user preferences.",
      "syntax": "ta.bb(series, length, mult) → [series float, series float, series float]",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "mult",
          "type": "simple int/float",
          "description": "Standard"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.bb\")[middle, upper, lower] = ta.bb(close, 5, 4)plot(middle, color=color.yellow)plot(upper, color=color.yellow)plot(lower, color=color.yellow)// the same on pinef_bb(src, length, mult) =>    float basis = ta.sma(src, length)    float dev = mult * ta.stdev(src, length)    [basis, basis + dev, basis - dev][pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)plot(pineMiddle)plot(pineUpper)plot(pineLower)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.stdev",
          "href": "fun_ta.stdev"
        },
        {
          "name": "ta.kc",
          "href": "fun_ta.kc"
        }
      ]
    },
    "fun_ta.bbw": {
      "id": "fun_ta.bbw",
      "name": "ta.bbw",
      "description": "Bollinger Bands Width. The Bollinger Band Width is\n                        the difference between the upper and the lower Bollinger Bands divided by the middle band.",
      "syntax": "ta.bbw(series, length, mult) → series float",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "mult",
          "type": "simple int/float",
          "description": "Standard"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.bbw\")plot(ta.bbw(close, 5, 4), color=color.yellow)// the same on pinef_bbw(src, length, mult) =>    float basis = ta.sma(src, length)    float dev = mult * ta.stdev(src, length)    (((basis + dev) - (basis - dev)) / basis) * 100plot(f_bbw(close, 5, 4))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.bb",
          "href": "fun_ta.bb"
        },
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.stdev",
          "href": "fun_ta.stdev"
        }
      ]
    },
    "fun_ta.cci": {
      "id": "fun_ta.cci",
      "name": "ta.cci",
      "description": "The CCI (commodity channel index) is calculated as\n                        the difference between the typical price of a commodity and its simple moving average, divided\n                        by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of\n                        0.015 to provide more readable numbers.",
      "syntax": "ta.cci(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.change": {
      "id": "fun_ta.change",
      "name": "ta.change",
      "description": "Compares the current source value to\n                        its value length bars ago and returns the difference.",
      "syntax": "ta.change(source) → series int",
      "arguments": [
        {
          "name": "source",
          "type": "series int",
          "description": "Source"
        }
      ],
      "examples": [
        "//@version=6indicator('Day and Direction Change', overlay = true)dailyBarTime = time('1D')isNewDay = ta.change(dailyBarTime) != 0bgcolor(isNewDay ? color.new(color.green, 80) : na)isGreenBar = close >= opencolorChange = ta.change(isGreenBar)plotshape(colorChange, 'Direction Change')"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.mom",
          "href": "fun_ta.mom"
        },
        {
          "name": "ta.cross",
          "href": "fun_ta.cross"
        }
      ]
    },
    "fun_ta.cmo": {
      "id": "fun_ta.cmo",
      "name": "ta.cmo",
      "description": "Chande Momentum Oscillator. Calculates the\n                        difference between the sum of recent gains and the sum of recent losses and then divides the\n                        result by the sum of all price movement over the same period.",
      "syntax": "ta.cmo(series, length) → series float",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.cmo\")plot(ta.cmo(close, 5), color=color.yellow)// the same on pinef_cmo(src, length) =>    float mom = ta.change(src)    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)    100 * (sm1 - sm2) / (sm1 + sm2)plot(f_cmo(close, 5))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.rsi",
          "href": "fun_ta.rsi"
        },
        {
          "name": "ta.stoch",
          "href": "fun_ta.stoch"
        },
        {
          "name": "math.sum",
          "href": "fun_math.sum"
        }
      ]
    },
    "fun_ta.cog": {
      "id": "fun_ta.cog",
      "name": "ta.cog",
      "description": "The cog (center of gravity) is an indicator based\n                        on statistics and the Fibonacci golden ratio.",
      "syntax": "ta.cog(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.cog\", overlay=true) plot(ta.cog(close, 10))// the same on pinepine_cog(source, length) =>    sum = math.sum(source, length)    num = 0.0    for i = 0 to length - 1        price = source[i]        num := num + price * (i + 1)    -num / sumplot(pine_cog(close, 10))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.stoch",
          "href": "fun_ta.stoch"
        }
      ]
    },
    "fun_ta.correlation": {
      "id": "fun_ta.correlation",
      "name": "ta.correlation",
      "description": "Correlation coefficient. Describes the degree to\n                        which two series tend to deviate from their ta.sma values.",
      "syntax": "ta.correlation(source1, source2, length) → series float",
      "arguments": [
        {
          "name": "source1",
          "type": "series int/float",
          "description": "Source"
        },
        {
          "name": "source2",
          "type": "series int/float",
          "description": "Target"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Length"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        }
      ]
    },
    "fun_ta.cross": {
      "id": "fun_ta.cross",
      "name": "ta.cross",
      "description": "source1 (series int/float) First\n                        data series.",
      "syntax": "ta.cross(source1, source2) → series bool",
      "arguments": [
        {
          "name": "source1",
          "type": "series int/float",
          "description": "First"
        },
        {
          "name": "source2",
          "type": "series int/float",
          "description": "Second"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.change",
          "href": "fun_ta.change"
        }
      ]
    },
    "fun_ta.crossover": {
      "id": "fun_ta.crossover",
      "name": "ta.crossover",
      "description": "The source1-series is defined as\n                        having crossed over source2-series if, on the current bar, the value of source1\n                        is greater than the value of source2, and on the previous bar, the value of source1\n                        was less than or equal to the value of source2.",
      "syntax": "ta.crossover(source1, source2) → series bool",
      "arguments": [
        {
          "name": "source1",
          "type": "series int/float",
          "description": "First"
        },
        {
          "name": "source2",
          "type": "series int/float",
          "description": "Second"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.crossunder": {
      "id": "fun_ta.crossunder",
      "name": "ta.crossunder",
      "description": "The source1-series is defined as\n                        having crossed under source2-series if, on the current bar, the value of source1\n                        is less than the value of source2, and on the previous bar, the value of source1\n                        was greater than or equal to the value of source2.",
      "syntax": "ta.crossunder(source1, source2) → series bool",
      "arguments": [
        {
          "name": "source1",
          "type": "series int/float",
          "description": "First"
        },
        {
          "name": "source2",
          "type": "series int/float",
          "description": "Second"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.cum": {
      "id": "fun_ta.cum",
      "name": "ta.cum",
      "description": "Cumulative (total) sum of source. In\n                        other words it's a sum of all elements of source.",
      "syntax": "ta.cum(source) → series float",
      "arguments": [
        {
          "name": "Cumulative",
          "type": "total",
          "description": "sum of source. In"
        },
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "math.sum",
          "href": "fun_math.sum"
        }
      ]
    },
    "fun_ta.dev": {
      "id": "fun_ta.dev",
      "name": "ta.dev",
      "description": "Measure of difference between the series and it's\n                        ta.sma",
      "syntax": "ta.dev(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.dev\")plot(ta.dev(close, 10))// the same on pinepine_dev(source, length) =>    mean = ta.sma(source, length)    sum = 0.0    for i = 0 to length - 1        val = source[i]        sum := sum + math.abs(val - mean)    dev = sum/lengthplot(pine_dev(close, 10))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.variance",
          "href": "fun_ta.variance"
        },
        {
          "name": "ta.stdev",
          "href": "fun_ta.stdev"
        }
      ]
    },
    "fun_ta.dmi": {
      "id": "fun_ta.dmi",
      "name": "ta.dmi",
      "description": "The dmi function returns the directional movement\n                        index.",
      "syntax": "ta.dmi(diLength, adxSmoothing) → [series float, series float, series float]",
      "arguments": [
        {
          "name": "diLength",
          "type": "simple int",
          "description": "DI"
        },
        {
          "name": "adxSmoothing",
          "type": "simple int",
          "description": "ADX"
        }
      ],
      "examples": [
        "//@version=6indicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)len = input.int(17, minval=1, title=\"DI Length\")lensig = input.int(14, title=\"ADX Smoothing\", minval=1)[diplus, diminus, adx] = ta.dmi(len, lensig)plot(adx, color=color.red, title=\"ADX\")plot(diplus, color=color.blue, title=\"+DI\")plot(diminus, color=color.orange, title=\"-DI\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.rsi",
          "href": "fun_ta.rsi"
        },
        {
          "name": "ta.tsi",
          "href": "fun_ta.tsi"
        },
        {
          "name": "ta.mfi",
          "href": "fun_ta.mfi"
        }
      ]
    },
    "fun_ta.ema": {
      "id": "fun_ta.ema",
      "name": "ta.ema",
      "description": "The ema function returns the exponentially\n                        weighted moving average. In ema weighting factors decrease exponentially. It calculates by using\n                        a formula: EMA = alpha * source + (1 - alpha) * EMA[1], where alpha = 2 /\n                            (length + 1).",
      "syntax": "ta.ema(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.ema\")plot(ta.ema(close, 15))//the same on pinepine_ema(src, length) =>    alpha = 2 / (length + 1)    sum = 0.0    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])plot(pine_ema(close,15))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        }
      ]
    },
    "fun_ta.falling": {
      "id": "fun_ta.falling",
      "name": "ta.falling",
      "description": "Test if the source series is now\n                        falling for length bars long.",
      "syntax": "ta.falling(source, length) → series bool",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.rising",
          "href": "fun_ta.rising"
        }
      ]
    },
    "fun_ta.highest": {
      "id": "fun_ta.highest",
      "name": "ta.highest",
      "description": "Highest value for a given number of bars back.",
      "syntax": "ta.highest(length) → series float",
      "arguments": [
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.lowest",
          "href": "fun_ta.lowest"
        },
        {
          "name": "ta.lowestbars",
          "href": "fun_ta.lowestbars"
        },
        {
          "name": "ta.highestbars",
          "href": "fun_ta.highestbars"
        },
        {
          "name": "ta.valuewhen",
          "href": "fun_ta.valuewhen"
        },
        {
          "name": "ta.barssince",
          "href": "fun_ta.barssince"
        }
      ]
    },
    "fun_ta.highestbars": {
      "id": "fun_ta.highestbars",
      "name": "ta.highestbars",
      "description": "Highest value offset for a given number of bars\n                        back.",
      "syntax": "ta.highestbars(length) → series int",
      "arguments": [
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.lowest",
          "href": "fun_ta.lowest"
        },
        {
          "name": "ta.highest",
          "href": "fun_ta.highest"
        },
        {
          "name": "ta.lowestbars",
          "href": "fun_ta.lowestbars"
        },
        {
          "name": "ta.barssince",
          "href": "fun_ta.barssince"
        },
        {
          "name": "ta.valuewhen",
          "href": "fun_ta.valuewhen"
        }
      ]
    },
    "fun_ta.hma": {
      "id": "fun_ta.hma",
      "name": "ta.hma",
      "description": "The hma function returns the Hull Moving\n                        Average.",
      "syntax": "ta.hma(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Hull Moving Average\")src = input(defval=close, title=\"Source\")length = input(defval=9, title=\"Length\")hmaBuildIn = ta.hma(src, length)plot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        }
      ]
    },
    "fun_ta.kc": {
      "id": "fun_ta.kc",
      "name": "ta.kc",
      "description": "Keltner Channels. Keltner channel is a technical\n                        analysis indicator showing a central moving average line plus channel lines at a distance above\n                        and below.",
      "syntax": "ta.kc(series, length, mult) → [series float, series float, series float]",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        },
        {
          "name": "mult",
          "type": "simple int/float",
          "description": "Standard"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.kc\")[middle, upper, lower] = ta.kc(close, 5, 4)plot(middle, color=color.yellow)plot(upper, color=color.yellow)plot(lower, color=color.yellow)// the same on pinef_kc(src, length, mult, useTrueRange) =>    float basis = ta.ema(src, length)    float span = (useTrueRange) ? ta.tr : (high - low)    float rangeEma = ta.ema(span, length)    [basis, basis + rangeEma * mult, basis - rangeEma * mult]    [pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)plot(pineMiddle)plot(pineUpper)plot(pineLower)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.atr",
          "href": "fun_ta.atr"
        },
        {
          "name": "ta.bb",
          "href": "fun_ta.bb"
        }
      ]
    },
    "fun_ta.kcw": {
      "id": "fun_ta.kcw",
      "name": "ta.kcw",
      "description": "Keltner Channels Width. The Keltner Channels Width\n                        is the difference between the upper and the lower Keltner Channels divided by the middle\n                        channel.",
      "syntax": "ta.kcw(series, length, mult) → series float",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        },
        {
          "name": "mult",
          "type": "simple int/float",
          "description": "Standard"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.kcw\")plot(ta.kcw(close, 5, 4), color=color.yellow)// the same on pinef_kcw(src, length, mult, useTrueRange) =>    float basis = ta.ema(src, length)    float span = (useTrueRange) ? ta.tr : (high - low)    float rangeEma = ta.ema(span, length)        ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basisplot(f_kcw(close, 5, 4, true))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.kc",
          "href": "fun_ta.kc"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.atr",
          "href": "fun_ta.atr"
        },
        {
          "name": "ta.bb",
          "href": "fun_ta.bb"
        }
      ]
    },
    "fun_ta.linreg": {
      "id": "fun_ta.linreg",
      "name": "ta.linreg",
      "description": "Linear regression curve. A line that best fits the\n                        prices specified over a user-defined time period. It is calculated using the least squares\n                        method. The result of this function is calculated using the formula: linreg = intercept + slope\n                        * (length - 1 - offset), where intercept and slope are the values calculated with the least\n                        squares method on source series.",
      "syntax": "ta.linreg(source, length, offset) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "offset",
          "type": "simple int",
          "description": "Offset."
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.lowest": {
      "id": "fun_ta.lowest",
      "name": "ta.lowest",
      "description": "Lowest value for a given number of bars back.",
      "syntax": "ta.lowest(length) → series float",
      "arguments": [
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.highest",
          "href": "fun_ta.highest"
        },
        {
          "name": "ta.lowestbars",
          "href": "fun_ta.lowestbars"
        },
        {
          "name": "ta.highestbars",
          "href": "fun_ta.highestbars"
        },
        {
          "name": "ta.valuewhen",
          "href": "fun_ta.valuewhen"
        },
        {
          "name": "ta.barssince",
          "href": "fun_ta.barssince"
        }
      ]
    },
    "fun_ta.lowestbars": {
      "id": "fun_ta.lowestbars",
      "name": "ta.lowestbars",
      "description": "Lowest value offset for a given number of bars\n                        back.",
      "syntax": "ta.lowestbars(length) → series int",
      "arguments": [
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.lowest",
          "href": "fun_ta.lowest"
        },
        {
          "name": "ta.highest",
          "href": "fun_ta.highest"
        },
        {
          "name": "ta.highestbars",
          "href": "fun_ta.highestbars"
        },
        {
          "name": "ta.barssince",
          "href": "fun_ta.barssince"
        },
        {
          "name": "ta.valuewhen",
          "href": "fun_ta.valuewhen"
        }
      ]
    },
    "fun_ta.macd": {
      "id": "fun_ta.macd",
      "name": "ta.macd",
      "description": "MACD (moving average convergence/divergence). It\n                        is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a\n                        stock's price.",
      "syntax": "ta.macd(source, fastlen, slowlen, siglen) → [series float, series float, series float]",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "fastlen",
          "type": "simple int",
          "description": "Fast"
        },
        {
          "name": "slowlen",
          "type": "simple int",
          "description": "Slow"
        },
        {
          "name": "siglen",
          "type": "simple int",
          "description": "Signal"
        }
      ],
      "examples": [
        "//@version=6indicator(\"MACD\")[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)plot(macdLine, color=color.blue)plot(signalLine, color=color.orange)plot(histLine, color=color.red, style=plot.style_histogram)",
        "//@version=6indicator(\"MACD\")[_, signalLine, _] = ta.macd(close, 12, 26, 9)plot(signalLine, color=color.orange)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        }
      ]
    },
    "fun_ta.max": {
      "id": "fun_ta.max",
      "name": "ta.max",
      "description": "Returns the all-time high value of\n                        source from the beginning of the chart up to the current bar.",
      "syntax": "ta.max(source) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.median": {
      "id": "fun_ta.median",
      "name": "ta.median",
      "description": "Returns the median of the series.",
      "syntax": "ta.median(source, length) → series int",
      "arguments": [
        {
          "name": "source",
          "type": "series int",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.mfi": {
      "id": "fun_ta.mfi",
      "name": "ta.mfi",
      "description": "Money Flow Index. The Money Flow Index (MFI) is a\n                        technical oscillator that uses price and volume for identifying overbought or oversold\n                        conditions in an asset.",
      "syntax": "ta.mfi(series, length) → series float",
      "arguments": [
        {
          "name": "series",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Money Flow Index\")plot(ta.mfi(hlc3, 14), color=color.yellow)// the same on pinepine_mfi(src, length) =>    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)    mfi = 100.0 - (100.0 / (1.0 + upper / lower))    mfiplot(pine_mfi(hlc3, 14))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.rsi",
          "href": "fun_ta.rsi"
        },
        {
          "name": "math.sum",
          "href": "fun_math.sum"
        }
      ]
    },
    "fun_ta.min": {
      "id": "fun_ta.min",
      "name": "ta.min",
      "description": "Returns the all-time low value of\n                        source from the beginning of the chart up to the current bar.",
      "syntax": "ta.min(source) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.mode": {
      "id": "fun_ta.mode",
      "name": "ta.mode",
      "description": "Returns the mode of the\n                        series. If there are several values with the same frequency, it returns the smallest value.",
      "syntax": "ta.mode(source, length) → series int",
      "arguments": [
        {
          "name": "source",
          "type": "series int",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.mom": {
      "id": "fun_ta.mom",
      "name": "ta.mom",
      "description": "Momentum of source price and source\n                        price length bars ago. This is simply a difference: source - source[length].",
      "syntax": "ta.mom(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Offset"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.change",
          "href": "fun_ta.change"
        }
      ]
    },
    "fun_ta.percentile_linear_interpolation": {
      "id": "fun_ta.percentile_linear_interpolation",
      "name": "ta.percentile_linear_interpolation",
      "description": "Calculates percentile using method of linear\n                        interpolation between the two nearest ranks.",
      "syntax": "ta.percentile_linear_interpolation(source, length, percentage) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "percentage",
          "type": "simple int/float",
          "description": "Percentage,"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.percentile_nearest_rank",
          "href": "fun_ta.percentile_nearest_rank"
        }
      ]
    },
    "fun_ta.percentile_nearest_rank": {
      "id": "fun_ta.percentile_nearest_rank",
      "name": "ta.percentile_nearest_rank",
      "description": "Calculates percentile using method of Nearest\n                        Rank.",
      "syntax": "ta.percentile_nearest_rank(source, length, percentage) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "percentage",
          "type": "simple int/float",
          "description": "Percentage,"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.percentile_linear_interpolation",
          "href": "fun_ta.percentile_linear_interpolation"
        },
        {
          "name": "",
          "href": "#"
        }
      ]
    },
    "fun_ta.percentrank": {
      "id": "fun_ta.percentrank",
      "name": "ta.percentrank",
      "description": "Percent rank is the percents of how many previous\n                        values was less than or equal to the current value of given series.",
      "syntax": "ta.percentrank(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.pivot_point_levels": {
      "id": "fun_ta.pivot_point_levels",
      "name": "ta.pivot_point_levels",
      "description": "Calculates the pivot point levels using the\n                        specified type and anchor.",
      "syntax": "ta.pivot_point_levels(type, anchor, developing) → array<float>",
      "arguments": [
        {
          "name": "type",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "anchor",
          "type": "series bool",
          "description": "The"
        },
        {
          "name": "developing",
          "type": "series bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)timeframe = \"1W\"typeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])weekChange = timeframe.change(timeframe)pivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)if weekChange    for pivotLevel in pivotPointsArray        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.pivothigh": {
      "id": "fun_ta.pivothigh",
      "name": "ta.pivothigh",
      "description": "This function returns price of the pivot high\n                        point. It returns 'NaN', if there was no pivot high point.",
      "syntax": "ta.pivothigh(leftbars, rightbars) → series float",
      "arguments": [
        {
          "name": "leftbars",
          "type": "series int/float",
          "description": "Left"
        },
        {
          "name": "rightbars",
          "type": "series int/float",
          "description": "Right"
        }
      ],
      "examples": [
        "//@version=6indicator(\"PivotHigh\", overlay=true)leftBars = input(2)rightBars=input(2)ph = ta.pivothigh(leftBars, rightBars)plot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.pivotlow": {
      "id": "fun_ta.pivotlow",
      "name": "ta.pivotlow",
      "description": "This function returns price of the pivot low\n                        point. It returns 'NaN', if there was no pivot low point.",
      "syntax": "ta.pivotlow(leftbars, rightbars) → series float",
      "arguments": [
        {
          "name": "leftbars",
          "type": "series int/float",
          "description": "Left"
        },
        {
          "name": "rightbars",
          "type": "series int/float",
          "description": "Right"
        }
      ],
      "examples": [
        "//@version=6indicator(\"PivotLow\", overlay=true)leftBars = input(2)rightBars=input(2)pl = ta.pivotlow(close, leftBars, rightBars)plot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.range": {
      "id": "fun_ta.range",
      "name": "ta.range",
      "description": "Returns the difference between the min and max\n                        values in a series.",
      "syntax": "ta.range(source, length) → series int",
      "arguments": [
        {
          "name": "source",
          "type": "series int",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.rci": {
      "id": "fun_ta.rci",
      "name": "ta.rci",
      "description": "Calculates the Rank Correlation Index (RCI), which\n                        measures the directional consistency of price movements. It evaluates the monotonic relationship\n                        between a source series and the bar index over length bars using\n                        Spearman's rank correlation coefficient. The resulting value is scaled to a range of -100 to\n                        100, where 100 indicates the source consistently increased over the period, and\n                        -100 indicates it consistently decreased. Values between -100 and 100 reflect varying degrees of\n                        upward or downward consistency.",
      "syntax": "ta.rci(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.rising": {
      "id": "fun_ta.rising",
      "name": "ta.rising",
      "description": "Test if the source series is now\n                        rising for length bars long.",
      "syntax": "ta.rising(source, length) → series bool",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.falling",
          "href": "fun_ta.falling"
        }
      ]
    },
    "fun_ta.rma": {
      "id": "fun_ta.rma",
      "name": "ta.rma",
      "description": "Moving average used in RSI. It is the\n                        exponentially weighted moving average with alpha = 1 / length.",
      "syntax": "ta.rma(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.rma\")plot(ta.rma(close, 15))//the same on pinepine_rma(src, length) =>    alpha = 1/length    sum = 0.0    sum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])plot(pine_rma(close, 15))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        },
        {
          "name": "ta.rsi",
          "href": "fun_ta.rsi"
        }
      ]
    },
    "fun_ta.roc": {
      "id": "fun_ta.roc",
      "name": "ta.roc",
      "description": "Calculates the percentage of change (rate of\n                        change) between the current value of source and its value length bars\n                        ago.",
      "syntax": "ta.roc(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.rsi": {
      "id": "fun_ta.rsi",
      "name": "ta.rsi",
      "description": "Relative strength index. It is calculated using\n                        the ta.rma() of upward and downward changes of source over the last\n                        length bars.",
      "syntax": "ta.rsi(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.rsi\")plot(ta.rsi(close, 7))// same on pine, but less efficientpine_rsi(x, y) =>     u = math.max(x - x[1], 0) // upward ta.change    d = math.max(x[1] - x, 0) // downward ta.change    rs = ta.rma(u, y) / ta.rma(d, y)    res = 100 - 100 / (1 + rs)    resplot(pine_rsi(close, 7))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        }
      ]
    },
    "fun_ta.sar": {
      "id": "fun_ta.sar",
      "name": "ta.sar",
      "description": "Parabolic SAR (parabolic stop and reverse) is a\n                        method devised by J. Welles Wilder, Jr., to find potential reversals in the market price\n                        direction of traded goods.",
      "syntax": "ta.sar(start, inc, max) → series float",
      "arguments": [
        {
          "name": "start",
          "type": "simple int/float",
          "description": "Start."
        },
        {
          "name": "inc",
          "type": "simple int/float",
          "description": "Increment."
        },
        {
          "name": "max",
          "type": "simple int/float",
          "description": "Maximum."
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.sar\")plot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)// The same on Pine Script®pine_sar(start, inc, max) =>    var float result = na    var float maxMin = na    var float acceleration = na    var bool isBelow = false    bool isFirstTrendBar = false        if bar_index == 1        if close > close[1]            isBelow := true            maxMin := high            result := low[1]        else            isBelow := false            maxMin := low            result := high[1]        isFirstTrendBar := true        acceleration := start        result := result + acceleration * (maxMin - result)        if isBelow        if result > low            isFirstTrendBar := true            isBelow := false            result := math.max(high, maxMin)            maxMin := low            acceleration := start    else        if result < high            isFirstTrendBar := true            isBelow := true            result := math.min(low, maxMin)            maxMin := high            acceleration := start                if not isFirstTrendBar        if isBelow            if high > maxMin                maxMin := high                acceleration := math.min(acceleration + inc, max)        else            if low < maxMin                maxMin := low                acceleration := math.min(acceleration + inc, max)        if isBelow        result := math.min(result, low[1])        if bar_index > 1            result := math.min(result, low[2])            else        result := math.max(result, high[1])        if bar_index > 1            result := math.max(result, high[2])        result    plot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.sma": {
      "id": "fun_ta.sma",
      "name": "ta.sma",
      "description": "The sma function returns the moving average, that\n                        is the sum of last y values of x, divided by y.",
      "syntax": "ta.sma(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.sma\")plot(ta.sma(close, 15))// same on pine, but much less efficientpine_sma(x, y) =>    sum = 0.0    for i = 0 to y - 1        sum := sum + x[i] / y    sumplot(pine_sma(close, 15))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        }
      ]
    },
    "fun_ta.stdev": {
      "id": "fun_ta.stdev",
      "name": "ta.stdev",
      "description": "source (series int/float) Series\n                        of values to process.",
      "syntax": "ta.stdev(source, length, biased) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "biased",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.stdev\")plot(ta.stdev(close, 5))//the same on pineisZero(val, eps) => math.abs(val) <= epsSUM(fst, snd) =>    EPS = 1e-10    res = fst + snd    if isZero(res, EPS)        res := 0    else        if not isZero(res, 1e-4)            res := res        else            15pine_stdev(src, length) =>    avg = ta.sma(src, length)    sumOfSquareDeviations = 0.0    for i = 0 to length - 1        sum = SUM(src[i], -avg)        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum    stdev = math.sqrt(sumOfSquareDeviations / length)plot(pine_stdev(close, 5))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.dev",
          "href": "fun_ta.dev"
        },
        {
          "name": "ta.variance",
          "href": "fun_ta.variance"
        }
      ]
    },
    "fun_ta.stoch": {
      "id": "fun_ta.stoch",
      "name": "ta.stoch",
      "description": "Stochastic. It is calculated by a formula: 100 *\n                        (close - lowest(low, length)) / (highest(high, length) - lowest(low, length)).",
      "syntax": "ta.stoch(source, high, low, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        },
        {
          "name": "high",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "low",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Length"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.cog",
          "href": "fun_ta.cog"
        }
      ]
    },
    "fun_ta.supertrend": {
      "id": "fun_ta.supertrend",
      "name": "ta.supertrend",
      "description": "The Supertrend Indicator. The Supertrend is a\n                        trend following indicator.",
      "syntax": "ta.supertrend(factor, atrPeriod) → [series float, series float]",
      "arguments": [
        {
          "name": "factor",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "atrPeriod",
          "type": "simple int",
          "description": "Length"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Pine Script® Supertrend\")[supertrend, direction] = ta.supertrend(3, 10)plot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)plot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)// The same on Pine Script®pine_supertrend(factor, atrPeriod) =>    src = hl2    atr = ta.atr(atrPeriod)    upperBand = src + factor * atr    lowerBand = src - factor * atr    prevLowerBand = nz(lowerBand[1])    prevUpperBand = nz(upperBand[1])    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand    int _direction = na    float superTrend = na    prevSuperTrend = superTrend[1]    if na(atr[1])        _direction := 1    else if prevSuperTrend == prevUpperBand        _direction := close > upperBand ? -1 : 1    else        _direction := close < lowerBand ? 1 : -1    superTrend := _direction == -1 ? lowerBand : upperBand    [superTrend, _direction][Pine_Supertrend, pineDirection] = pine_supertrend(3, 10)plot(pineDirection < 0 ? Pine_Supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)plot(pineDirection > 0 ? Pine_Supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.macd",
          "href": "fun_ta.macd"
        }
      ]
    },
    "fun_ta.swma": {
      "id": "fun_ta.swma",
      "name": "ta.swma",
      "description": "Symmetrically weighted moving average with fixed\n                        length: 4. Weights: [1/6, 2/6, 2/6, 1/6].",
      "syntax": "ta.swma(source) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.swma\")plot(ta.swma(close))// same on pine, but less efficientpine_swma(x) =>    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6plot(pine_swma(close))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        }
      ]
    },
    "fun_ta.tr": {
      "id": "fun_ta.tr",
      "name": "ta.tr",
      "description": "Calculates the current bar's true range. Unlike a\n                        bar's actual range (high - low), true range accounts for potential gaps by taking\n                        the maximum of the current bar's actual range and the absolute distances from the previous bar's\n                        close to the current bar's\n                        high and low.\n                        The formula is: math.max(high - low, math.abs(high - close[1]), math.abs(low -\n                            close[1]))",
      "syntax": "ta.tr(handle_na) → series float",
      "arguments": [
        {
          "name": "handle_na",
          "type": "simple bool",
          "description": "Defines"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.tr",
          "href": "var_ta.tr"
        },
        {
          "name": "ta.atr",
          "href": "fun_ta.atr"
        }
      ]
    },
    "fun_ta.tsi": {
      "id": "fun_ta.tsi",
      "name": "ta.tsi",
      "description": "True strength index. It uses moving averages of\n                        the underlying momentum of a financial instrument.",
      "syntax": "ta.tsi(source, short_length, long_length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        },
        {
          "name": "short_length",
          "type": "simple int",
          "description": "Short"
        },
        {
          "name": "long_length",
          "type": "simple int",
          "description": "Long"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "fun_ta.valuewhen": {
      "id": "fun_ta.valuewhen",
      "name": "ta.valuewhen",
      "description": "Returns the value of the source\n                        series on the bar where the condition was true on the nth most recent occurrence.",
      "syntax": "ta.valuewhen(condition, source, occurrence) → series color",
      "arguments": [
        {
          "name": "condition",
          "type": "series bool",
          "description": "The"
        },
        {
          "name": "source",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "occurrence",
          "type": "simple int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.valuewhen\")slow = ta.sma(close, 7)fast = ta.sma(close, 14)// Get value of `close` on second most recent crossplot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.lowestbars",
          "href": "fun_ta.lowestbars"
        },
        {
          "name": "ta.highestbars",
          "href": "fun_ta.highestbars"
        },
        {
          "name": "ta.barssince",
          "href": "fun_ta.barssince"
        },
        {
          "name": "ta.highest",
          "href": "fun_ta.highest"
        },
        {
          "name": "ta.lowest",
          "href": "fun_ta.lowest"
        }
      ]
    },
    "fun_ta.variance": {
      "id": "fun_ta.variance",
      "name": "ta.variance",
      "description": "Variance is the expectation of the squared\n                        deviation of a series from its mean (ta.sma), and it informally\n                        measures how far a set of numbers are spread out from their mean.",
      "syntax": "ta.variance(source, length, biased) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        },
        {
          "name": "biased",
          "type": "series bool",
          "description": "Determines"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.dev",
          "href": "fun_ta.dev"
        },
        {
          "name": "ta.stdev",
          "href": "fun_ta.stdev"
        }
      ]
    },
    "fun_ta.vwap": {
      "id": "fun_ta.vwap",
      "name": "ta.vwap",
      "description": "Volume weighted average price.",
      "syntax": "ta.vwap(source) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Source"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Simple VWAP\")vwap = ta.vwap(open)plot(vwap)",
        "//@version=6indicator(\"Advanced VWAP\")vwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])stdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")anchorTimeframe = switch vwapAnchorInput    \"Daily\"   => \"1D\"    \"Weekly\"  => \"1W\"    \"Monthly\" => \"1M\"anchor = timeframe.change(anchorTimeframe)[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)plot(vwap)plot(upper, color = color.green)plot(lower, color = color.green)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.vwap",
          "href": "var_ta.vwap"
        }
      ]
    },
    "fun_ta.vwma": {
      "id": "fun_ta.vwma",
      "name": "ta.vwma",
      "description": "The vwma function returns volume-weighted moving\n                        average of source for length bars back. It is the same as: sma(source\n                        * volume, length) / sma(volume, length).",
      "syntax": "ta.vwma(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.vwma\")plot(ta.vwma(close, 15))// same on pine, but less efficientpine_vwma(x, y) =>    ta.sma(x * volume, y) / ta.sma(volume, y)plot(pine_vwma(close, 15))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.wma",
          "href": "fun_ta.wma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        }
      ]
    },
    "fun_ta.wma": {
      "id": "fun_ta.wma",
      "name": "ta.wma",
      "description": "The wma function returns weighted moving average\n                        of source for length bars back. In wma weighting factors decrease in\n                        arithmetical progression.",
      "syntax": "ta.wma(source, length) → series float",
      "arguments": [
        {
          "name": "source",
          "type": "series int/float",
          "description": "Series"
        },
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ta.wma\")plot(ta.wma(close, 15))// same on pine, but much less efficientpine_wma(x, y) =>    norm = 0.0    sum = 0.0    for i = 0 to y - 1        weight = (y - i) * y        norm := norm + weight        sum := sum + x[i] * weight    sum / normplot(pine_wma(close, 15))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.sma",
          "href": "fun_ta.sma"
        },
        {
          "name": "ta.ema",
          "href": "fun_ta.ema"
        },
        {
          "name": "ta.rma",
          "href": "fun_ta.rma"
        },
        {
          "name": "ta.vwma",
          "href": "fun_ta.vwma"
        },
        {
          "name": "ta.swma",
          "href": "fun_ta.swma"
        },
        {
          "name": "ta.alma",
          "href": "fun_ta.alma"
        }
      ]
    },
    "fun_ta.wpr": {
      "id": "fun_ta.wpr",
      "name": "ta.wpr",
      "description": "Williams %R. The oscillator shows the current\n                        closing price in relation to the high and low of the past 'length' bars.",
      "syntax": "ta.wpr(length) → series float",
      "arguments": [
        {
          "name": "length",
          "type": "series int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)plot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "ta.mfi",
          "href": "fun_ta.mfi"
        },
        {
          "name": "ta.cmo",
          "href": "fun_ta.cmo"
        }
      ]
    },
    "fun_table": {
      "id": "fun_table",
      "name": "table",
      "description": "Casts na to table",
      "syntax": "table(x) → series table",
      "arguments": [
        {
          "name": "x",
          "type": "series table",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "float",
          "href": "fun_float"
        },
        {
          "name": "int",
          "href": "fun_int"
        },
        {
          "name": "bool",
          "href": "fun_bool"
        },
        {
          "name": "color",
          "href": "fun_color"
        },
        {
          "name": "string",
          "href": "fun_string"
        },
        {
          "name": "line",
          "href": "fun_line"
        },
        {
          "name": "label",
          "href": "fun_label"
        }
      ]
    },
    "fun_table.cell": {
      "id": "fun_table.cell",
      "name": "table.cell",
      "description": "The function defines a cell in the table and sets\n                        its attributes.",
      "syntax": "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family, text_formatting) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "width",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "height",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "text_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "text_halign",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_valign",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_size",
          "type": "series int/string",
          "description": "Size"
        },
        {
          "name": "bgcolor",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "tooltip",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_formatting",
          "href": "fun_table.cell_set_text_formatting"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_bgcolor": {
      "id": "fun_table.cell_set_bgcolor",
      "name": "table.cell_set_bgcolor",
      "description": "The function sets the background color of the\n                        cell.",
      "syntax": "table.cell_set_bgcolor(table_id, column, row, bgcolor) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "bgcolor",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_height": {
      "id": "fun_table.cell_set_height",
      "name": "table.cell_set_height",
      "description": "The function sets the height of cell.",
      "syntax": "table.cell_set_height(table_id, column, row, height) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "height",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_text": {
      "id": "fun_table.cell_set_text",
      "name": "table.cell_set_text",
      "description": "The function sets the text in the specified\n                        cell.",
      "syntax": "table.cell_set_text(table_id, column, row, text) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"TABLE example\")var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)table.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        },
        {
          "name": "table.cell_set_text_formatting",
          "href": "fun_table.cell_set_text_formatting"
        }
      ]
    },
    "fun_table.cell_set_text_color": {
      "id": "fun_table.cell_set_text_color",
      "name": "table.cell_set_text_color",
      "description": "The function sets the color of the text inside the\n                        cell.",
      "syntax": "table.cell_set_text_color(table_id, column, row, text_color) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_text_font_family": {
      "id": "fun_table.cell_set_text_font_family",
      "name": "table.cell_set_text_font_family",
      "description": "The function sets the font family of the text\n                        inside the cell.",
      "syntax": "table.cell_set_text_font_family(table_id, column, row, text_font_family) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_font_family",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Example of setting the table cell font\")var t = table.new(position.top_left, rows = 1, columns = 1)table.cell(t, 0, 0, \"monospace\", text_color = color.blue)table.cell_set_text_font_family(t, 0, 0, font.family_monospace)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "font.family_default",
          "href": "const_font.family_default"
        },
        {
          "name": "font.family_monospace",
          "href": "const_font.family_monospace"
        }
      ]
    },
    "fun_table.cell_set_text_formatting": {
      "id": "fun_table.cell_set_text_formatting",
      "name": "table.cell_set_text_formatting",
      "description": "Sets the formatting attributes the drawing applies\n                        to displayed text.",
      "syntax": "table.cell_set_text_formatting(table_id, column, row, text_formatting) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_formatting",
          "type": "const text_format",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        }
      ]
    },
    "fun_table.cell_set_text_halign": {
      "id": "fun_table.cell_set_text_halign",
      "name": "table.cell_set_text_halign",
      "description": "The function sets the horizontal alignment of the\n                        cell's text.",
      "syntax": "table.cell_set_text_halign(table_id, column, row, text_halign) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_halign",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_text_size": {
      "id": "fun_table.cell_set_text_size",
      "name": "table.cell_set_text_size",
      "description": "The function sets the size of the cell's text.",
      "syntax": "table.cell_set_text_size(table_id, column, row, text_size) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_size",
          "type": "series int/string",
          "description": "Size"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_text_valign": {
      "id": "fun_table.cell_set_text_valign",
      "name": "table.cell_set_text_valign",
      "description": "The function sets the vertical alignment of a\n                        cell's text.",
      "syntax": "table.cell_set_text_valign(table_id, column, row, text_valign) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "text_valign",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.cell_set_tooltip": {
      "id": "fun_table.cell_set_tooltip",
      "name": "table.cell_set_tooltip",
      "description": "The function sets the tooltip in the specified\n                        cell.",
      "syntax": "table.cell_set_tooltip(table_id, column, row, tooltip) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "tooltip",
          "type": "series string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"TABLE example\")var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)table.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_width",
          "href": "fun_table.cell_set_width"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        }
      ]
    },
    "fun_table.cell_set_width": {
      "id": "fun_table.cell_set_width",
      "name": "table.cell_set_width",
      "description": "The function sets the width of the cell.",
      "syntax": "table.cell_set_width(table_id, column, row, width) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "width",
          "type": "series int/float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell_set_bgcolor",
          "href": "fun_table.cell_set_bgcolor"
        },
        {
          "name": "table.cell_set_height",
          "href": "fun_table.cell_set_height"
        },
        {
          "name": "table.cell_set_text",
          "href": "fun_table.cell_set_text"
        },
        {
          "name": "table.cell_set_text_color",
          "href": "fun_table.cell_set_text_color"
        },
        {
          "name": "table.cell_set_text_halign",
          "href": "fun_table.cell_set_text_halign"
        },
        {
          "name": "table.cell_set_text_size",
          "href": "fun_table.cell_set_text_size"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "table.cell_set_tooltip",
          "href": "fun_table.cell_set_tooltip"
        }
      ]
    },
    "fun_table.clear": {
      "id": "fun_table.clear",
      "name": "table.clear",
      "description": "The function removes a cell or a sequence of cells\n                        from the table. The cells are removed in a rectangle shape where the start_column and start_row\n                        specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
      "syntax": "table.clear(table_id, start_column, start_row, end_column, end_row) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "start_column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "start_row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "end_column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "end_row",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"A donut\", overlay=true)if barstate.islast    colNum = 8, rowNum = 8    padding = \"◯\"    donutTable = table.new(position.middle_right, colNum, rowNum)    for c = 0 to colNum - 1        for r = 0 to rowNum - 1            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))    table.clear(donutTable, 2, 2, 5, 5)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        }
      ]
    },
    "fun_table.delete": {
      "id": "fun_table.delete",
      "name": "table.delete",
      "description": "The function deletes a table.",
      "syntax": "table.delete(table_id) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"table.delete example\")var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)if barstate.islast    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)if barstate.isrealtime    table.delete(testTable)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        }
      ]
    },
    "fun_table.merge_cells": {
      "id": "fun_table.merge_cells",
      "name": "table.merge_cells",
      "description": "The function merges a sequence of cells in the\n                        table into one cell. The cells are merged in a rectangle shape where the start_column and\n                        start_row specify the top-left corner, and end_column and end_row specify the bottom-right\n                        corner.",
      "syntax": "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "start_column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "start_row",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "end_column",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "end_row",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"table.merge_cells example\")SMA50  = ta.sma(close, 50)SMA100 = ta.sma(close, 100)SMA200 = ta.sma(close, 200)if barstate.islast    maTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)    // Header    table.cell(maTable, 0, 0, text = \"SMA Table\")    table.merge_cells(maTable, 0, 0, 2, 0)    // Cell Titles    table.cell(maTable, 0, 1, text = \"SMA 50\")    table.cell(maTable, 1, 1, text = \"SMA 100\")    table.cell(maTable, 2, 1, text = \"SMA 200\")    // Values    table.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))    table.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))    table.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        }
      ]
    },
    "fun_table.new": {
      "id": "fun_table.new",
      "name": "table.new",
      "description": "The function creates a new table.",
      "syntax": "table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width, force_overlay) → series table",
      "arguments": [
        {
          "name": "position",
          "type": "series string",
          "description": "Position"
        },
        {
          "name": "columns",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "rows",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "bgcolor",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "frame_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "frame_width",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "border_color",
          "type": "series color",
          "description": "The"
        },
        {
          "name": "border_width",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "force_overlay",
          "type": "const bool",
          "description": "If"
        }
      ],
      "examples": [
        "//@version=6indicator(\"table.new example\")var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)if barstate.islast    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_bgcolor": {
      "id": "fun_table.set_bgcolor",
      "name": "table.set_bgcolor",
      "description": "The function sets the background color of a\n                        table.",
      "syntax": "table.set_bgcolor(table_id, bgcolor) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "bgcolor",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_border_color": {
      "id": "fun_table.set_border_color",
      "name": "table.set_border_color",
      "description": "The function sets the color of the borders\n                        (excluding the outer frame) of the table's cells.",
      "syntax": "table.set_border_color(table_id, border_color) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "border_color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_border_width": {
      "id": "fun_table.set_border_width",
      "name": "table.set_border_width",
      "description": "The function sets the width of the borders\n                        (excluding the outer frame) of the table's cells.",
      "syntax": "table.set_border_width(table_id, border_width) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "border_width",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_frame_color": {
      "id": "fun_table.set_frame_color",
      "name": "table.set_frame_color",
      "description": "The function sets the color of the outer frame of\n                        a table.",
      "syntax": "table.set_frame_color(table_id, frame_color) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "frame_color",
          "type": "series color",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_frame_width": {
      "id": "fun_table.set_frame_width",
      "name": "table.set_frame_width",
      "description": "The function set the width of the outer frame of a\n                        table.",
      "syntax": "table.set_frame_width(table_id, frame_width) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "frame_width",
          "type": "series int",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        }
      ]
    },
    "fun_table.set_position": {
      "id": "fun_table.set_position",
      "name": "table.set_position",
      "description": "The function sets the position of a table.",
      "syntax": "table.set_position(table_id, position) → void",
      "arguments": [
        {
          "name": "table_id",
          "type": "series table",
          "description": "A"
        },
        {
          "name": "position",
          "type": "series string",
          "description": "Position"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "table.clear",
          "href": "fun_table.clear"
        },
        {
          "name": "table.delete",
          "href": "fun_table.delete"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.set_bgcolor",
          "href": "fun_table.set_bgcolor"
        },
        {
          "name": "table.set_border_color",
          "href": "fun_table.set_border_color"
        },
        {
          "name": "table.set_border_width",
          "href": "fun_table.set_border_width"
        },
        {
          "name": "table.set_frame_color",
          "href": "fun_table.set_frame_color"
        },
        {
          "name": "table.set_frame_width",
          "href": "fun_table.set_frame_width"
        }
      ]
    },
    "fun_ticker.heikinashi": {
      "id": "fun_ticker.heikinashi",
      "name": "ticker.heikinashi",
      "description": "Creates a ticker identifier for requesting Heikin\n                        Ashi bar values.",
      "syntax": "ticker.heikinashi(symbol) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.heikinashi\", overlay=true) heikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)heikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)plot(heikinashi_close)plot(heikinashi_aapl_60_close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "ticker.renko",
          "href": "fun_ticker.renko"
        },
        {
          "name": "ticker.linebreak",
          "href": "fun_ticker.linebreak"
        },
        {
          "name": "ticker.kagi",
          "href": "fun_ticker.kagi"
        },
        {
          "name": "ticker.pointfigure",
          "href": "fun_ticker.pointfigure"
        }
      ]
    },
    "fun_ticker.inherit": {
      "id": "fun_ticker.inherit",
      "name": "ticker.inherit",
      "description": "Constructs a ticker ID for the specified symbol\n                        with additional parameters inherited from the ticker ID passed into the function call, allowing\n                        the script to request a symbol's data using the same modifiers that the\n                        from_tickerid has, including extended session, dividend adjustment, currency\n                        conversion, non-standard chart types, back-adjustment, settlement-as-close, etc.",
      "syntax": "ticker.inherit(from_tickerid, symbol) → simple string",
      "arguments": [
        {
          "name": "from_tickerid",
          "type": "simple string",
          "description": "The"
        },
        {
          "name": "symbol",
          "type": "simple string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.inherit\")//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.tickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.HAtickerExtHours = ticker.heikinashi(tickerExtHours)//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.testSymbol = \"NASDAQ:MSFT\"//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.testSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers. secData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers. compareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)plot(secData, color = color.green)plot(compareData)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_ticker.kagi": {
      "id": "fun_ticker.kagi",
      "name": "ticker.kagi",
      "description": "Creates a ticker identifier for requesting Kagi\n                        values.",
      "syntax": "ticker.kagi(symbol, reversal) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol"
        },
        {
          "name": "reversal",
          "type": "simple int/float",
          "description": "Reversal"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.kagi\", overlay=true) kagi_tickerid = ticker.kagi(syminfo.tickerid, 3)kagi_close = request.security(kagi_tickerid, timeframe.period, close)plot(kagi_close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "ticker.renko",
          "href": "fun_ticker.renko"
        },
        {
          "name": "ticker.linebreak",
          "href": "fun_ticker.linebreak"
        },
        {
          "name": "ticker.pointfigure",
          "href": "fun_ticker.pointfigure"
        }
      ]
    },
    "fun_ticker.linebreak": {
      "id": "fun_ticker.linebreak",
      "name": "ticker.linebreak",
      "description": "Creates a ticker identifier for requesting Line\n                        Break values.",
      "syntax": "ticker.linebreak(symbol, number_of_lines) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol"
        },
        {
          "name": "number_of_lines",
          "type": "simple int",
          "description": "Number"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.linebreak\", overlay=true) linebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)linebreak_close = request.security(linebreak_tickerid, timeframe.period, close)plot(linebreak_close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "ticker.renko",
          "href": "fun_ticker.renko"
        },
        {
          "name": "ticker.kagi",
          "href": "fun_ticker.kagi"
        },
        {
          "name": "ticker.pointfigure",
          "href": "fun_ticker.pointfigure"
        }
      ]
    },
    "fun_ticker.modify": {
      "id": "fun_ticker.modify",
      "name": "ticker.modify",
      "description": "Creates a ticker identifier for requesting\n                        additional data for the script.",
      "syntax": "ticker.modify(tickerid, session, adjustment) → series string",
      "arguments": [
        {
          "name": "tickerid",
          "type": "series string",
          "description": "Symbol"
        },
        {
          "name": "session",
          "type": "series string",
          "description": "Session"
        },
        {
          "name": "adjustment",
          "type": "series string",
          "description": "Adjustment"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker_modify\", overlay=true)t1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)c1 = request.security(t1, \"D\", close)t2 = ticker.modify(t1, session.extended)c2 = request.security(t2, \"2D\", close)plot(c1)plot(c2)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.session",
          "href": "var_syminfo.session"
        },
        {
          "name": "session.extended",
          "href": "const_session.extended"
        },
        {
          "name": "session.regular",
          "href": "const_session.regular"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "adjustment.none",
          "href": "const_adjustment.none"
        },
        {
          "name": "adjustment.splits",
          "href": "const_adjustment.splits"
        },
        {
          "name": "adjustment.dividends",
          "href": "const_adjustment.dividends"
        },
        {
          "name": "backadjustment.inherit",
          "href": "const_backadjustment.inherit"
        },
        {
          "name": "backadjustment.on",
          "href": "const_backadjustment.on"
        },
        {
          "name": "backadjustment.off",
          "href": "const_backadjustment.off"
        },
        {
          "name": "settlement_as_close.inherit",
          "href": "const_settlement_as_close.inherit"
        },
        {
          "name": "settlement_as_close.on",
          "href": "const_settlement_as_close.on"
        },
        {
          "name": "settlement_as_close.off",
          "href": "const_settlement_as_close.off"
        }
      ]
    },
    "fun_ticker.new": {
      "id": "fun_ticker.new",
      "name": "ticker.new",
      "description": "Creates a ticker identifier for requesting\n                        additional data for the script.",
      "syntax": "ticker.new(prefix, ticker, session, adjustment) → series string",
      "arguments": [
        {
          "name": "prefix",
          "type": "series string",
          "description": "Exchange"
        },
        {
          "name": "ticker",
          "type": "series string",
          "description": "Ticker"
        },
        {
          "name": "session",
          "type": "series string",
          "description": "Session"
        },
        {
          "name": "adjustment",
          "type": "series string",
          "description": "Adjustment"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.new\", overlay=true) t = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)t2 = ticker.heikinashi(t)c = request.security(t2, timeframe.period, low, barmerge.gaps_on)plot(c, style=plot.style_linebr)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.session",
          "href": "var_syminfo.session"
        },
        {
          "name": "session.extended",
          "href": "const_session.extended"
        },
        {
          "name": "session.regular",
          "href": "const_session.regular"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "adjustment.none",
          "href": "var_adjustment.none"
        },
        {
          "name": "adjustment.splits",
          "href": "var_adjustment.splits"
        },
        {
          "name": "adjustment.dividends",
          "href": "var_adjustment.dividends"
        },
        {
          "name": "backadjustment.inherit",
          "href": "const_backadjustment.inherit"
        },
        {
          "name": "backadjustment.on",
          "href": "const_backadjustment.on"
        },
        {
          "name": "backadjustment.off",
          "href": "const_backadjustment.off"
        },
        {
          "name": "settlement_as_close.inherit",
          "href": "const_settlement_as_close.inherit"
        },
        {
          "name": "settlement_as_close.on",
          "href": "const_settlement_as_close.on"
        },
        {
          "name": "settlement_as_close.off",
          "href": "const_settlement_as_close.off"
        }
      ]
    },
    "fun_ticker.pointfigure": {
      "id": "fun_ticker.pointfigure",
      "name": "ticker.pointfigure",
      "description": "Creates a ticker identifier for requesting Point\n                        & Figure values.",
      "syntax": "ticker.pointfigure(symbol, source, style, param, reversal) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol"
        },
        {
          "name": "source",
          "type": "simple string",
          "description": "The"
        },
        {
          "name": "style",
          "type": "simple string",
          "description": "Specifies"
        },
        {
          "name": "param",
          "type": "simple int/float",
          "description": "Represents"
        },
        {
          "name": "reversal",
          "type": "simple int",
          "description": "Reversal"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.pointfigure\", overlay=true) pnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)pnf_close = request.security(pnf_tickerid, timeframe.period, close)plot(pnf_close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "ticker.renko",
          "href": "fun_ticker.renko"
        },
        {
          "name": "ticker.linebreak",
          "href": "fun_ticker.linebreak"
        },
        {
          "name": "ticker.kagi",
          "href": "fun_ticker.kagi"
        }
      ]
    },
    "fun_ticker.renko": {
      "id": "fun_ticker.renko",
      "name": "ticker.renko",
      "description": "Creates a ticker identifier for requesting Renko\n                        values.",
      "syntax": "ticker.renko(symbol, style, param, request_wicks, source) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "Symbol"
        },
        {
          "name": "style",
          "type": "simple string",
          "description": "Specifies"
        },
        {
          "name": "param",
          "type": "simple int/float",
          "description": "Represents"
        },
        {
          "name": "request_wicks",
          "type": "simple bool",
          "description": "Specifies"
        },
        {
          "name": "source",
          "type": "simple string",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.renko\", overlay=true) renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)renko_close = request.security(renko_tickerid, timeframe.period, close)plot(renko_close)",
        "//@version=6indicator(\"Renko candles\", overlay=false)renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])plotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "ticker.heikinashi",
          "href": "fun_ticker.heikinashi"
        },
        {
          "name": "ticker.linebreak",
          "href": "fun_ticker.linebreak"
        },
        {
          "name": "ticker.kagi",
          "href": "fun_ticker.kagi"
        },
        {
          "name": "ticker.pointfigure",
          "href": "fun_ticker.pointfigure"
        }
      ]
    },
    "fun_ticker.standard": {
      "id": "fun_ticker.standard",
      "name": "ticker.standard",
      "description": "Creates a ticker to request data from a standard\n                        chart that is unaffected by modifiers like extended session, dividend adjustment, currency\n                        conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc. Among\n                        other things, this makes it possible to retrieve standard chart values when the script is\n                        running on a non-standard chart.",
      "syntax": "ticker.standard(symbol) → simple string",
      "arguments": [
        {
          "name": "symbol",
          "type": "simple string",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"ticker.standard\", overlay = true)// This script should be run on a non-standard chart such as HA, Renko...// Requests data from the chart type the script is running on.chartTypeValue = request.security(syminfo.tickerid, \"1D\", close)// Request data from the standard chart type, regardless of the chart type the script is running on.standardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).standardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)plot(chartTypeValue)plot(standardChartValue, color = color.green)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        }
      ]
    },
    "fun_time": {
      "id": "fun_time",
      "name": "time",
      "description": "The time function returns the UNIX time of the\n                        current bar for the specified timeframe and session or NaN if the time point is out of session.",
      "syntax": "time(timeframe, bars_back) → series int",
      "arguments": [
        {
          "name": "timeframe",
          "type": "series string",
          "description": "Timeframe."
        },
        {
          "name": "bars_back",
          "type": "series int",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"Time\", overlay=true)// Try this on chart AAPL,1timeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0plot(timeinrange(\"1\", \"1300-1400\"), color=color.red)// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:newbar(res) => ta.change(time(res)) == 0 ? 0 : 1plot(newbar(\"10\"))",
        "//@version=6indicator(\"Time\", overlay=true)t1 = time(timeframe.period, \"0000-0000:23456\")bgcolor(not na(t1) ? color.new(color.blue, 90) : na)",
        "//@version=6indicator(\"Time\", overlay=true)t1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "time",
          "href": "var_time"
        }
      ]
    },
    "fun_time_close": {
      "id": "fun_time_close",
      "name": "time_close",
      "description": "Returns the UNIX time of the current bar's close\n                        for the specified timeframe and session, or na if the time point is outside the session. On tick\n                        charts and price-based charts such as Renko, line break, Kagi, point & figure, and range,\n                        this function returns an na\n                        timestamp for the latest realtime bar (because the future closing time is unpredictable), but a\n                        valid timestamp for any previous bar.",
      "syntax": "time_close(timeframe, bars_back) → series int",
      "arguments": [
        {
          "name": "timeframe",
          "type": "series string",
          "description": "Resolution."
        },
        {
          "name": "bars_back",
          "type": "series int",
          "description": "Optional."
        }
      ],
      "examples": [
        "//@version=6indicator(\"Time\", overlay=true)t1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "time_close",
          "href": "var_time_close"
        }
      ]
    },
    "fun_timeframe.change": {
      "id": "fun_timeframe.change",
      "name": "timeframe.change",
      "description": "Detects changes in the specified\n                        timeframe.",
      "syntax": "timeframe.change(timeframe) → series bool",
      "arguments": [
        {
          "name": "timeframe",
          "type": "series string",
          "description": "String"
        }
      ],
      "examples": [
        "//@version=6// Run this script on an intraday chart.indicator(\"New day started\", overlay = true)// Highlights the first bar of the new day.isNewDay = timeframe.change(\"1D\")bgcolor(isNewDay ? color.new(color.green, 80) : na)"
      ],
      "type": "",
      "seeAlso": []
    },
    "fun_timeframe.from_seconds": {
      "id": "fun_timeframe.from_seconds",
      "name": "timeframe.from_seconds",
      "description": "Converts a number of seconds into a valid\n                        timeframe string.",
      "syntax": "timeframe.from_seconds(seconds) → simple string",
      "arguments": [
        {
          "name": "seconds",
          "type": "simple int",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"HTF Close\", \"\", true)int chartTf = timeframe.in_seconds()string tfTimes5 = timeframe.from_seconds(chartTf * 5)float htfClose = request.security(syminfo.tickerid, tfTimes5, close)plot(htfClose)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "timeframe.in_seconds",
          "href": "fun_timeframe.in_seconds"
        },
        {
          "name": "request.security",
          "href": "var_request.security"
        },
        {
          "name": "request.security_lower_tf",
          "href": "var_request.security_lower_tf"
        }
      ]
    },
    "fun_timeframe.in_seconds": {
      "id": "fun_timeframe.in_seconds",
      "name": "timeframe.in_seconds",
      "description": "Converts a timeframe string into seconds.",
      "syntax": "timeframe.in_seconds(timeframe) → simple int",
      "arguments": [
        {
          "name": "timeframe",
          "type": "simple string",
          "description": "Timeframe"
        }
      ],
      "examples": [
        "//@version=6indicator(\"`timeframe_in_seconds()`\")// Get a user-selected timeframe.tfInput = input.timeframe(\"1D\")// Convert it into an \"int\" number of seconds.secondsInTf = timeframe.in_seconds(tfInput)plot(secondsInTf)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "input.timeframe",
          "href": "fun_input.timeframe"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.from_seconds",
          "href": "fun_timeframe.from_seconds"
        }
      ]
    },
    "fun_timestamp": {
      "id": "fun_timestamp",
      "name": "timestamp",
      "description": "Function timestamp returns UNIX time of specified\n                        date and time.",
      "syntax": "timestamp(dateString) → const int",
      "arguments": [
        {
          "name": "dateString",
          "type": "const string",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"timestamp\")plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)plot(timestamp(\"Feb 01 2020 22:10:05\"))plot(timestamp(\"2011-10-10T14:48:00\"))plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "time",
          "href": "fun_time"
        }
      ]
    },
    "fun_weekofyear": {
      "id": "fun_weekofyear",
      "name": "weekofyear",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "weekofyear(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    },
    "fun_year": {
      "id": "fun_year",
      "name": "year",
      "description": "time (series int) UNIX\n                        time in milliseconds.",
      "syntax": "year(time) → series int",
      "arguments": [
        {
          "name": "time",
          "type": "series int",
          "description": "UNIX"
        },
        {
          "name": "Year",
          "type": "in exchange timezone",
          "description": "for provided UNIX"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "second",
          "href": "fun_second"
        }
      ]
    }
  },
  "variables": {
    "var_ask": {
      "id": "var_ask",
      "name": "ask",
      "description": "The ask price at the time of the current tick,\n                        which represents the lowest price an active seller will accept for the instrument at its current\n                        value. This information is available only on the \"1T\" timeframe. On other timeframes, the\n                        variable's value is na.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_bar_index": {
      "id": "var_bar_index",
      "name": "bar_index",
      "description": "Current bar index. Numbering is zero-based, index\n                        of the first bar is 0.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"bar_index\")plot(bar_index)plot(bar_index > 5000 ? close : 0)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "last_bar_index",
          "href": "var_last_bar_index"
        },
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        }
      ]
    },
    "var_barstate.isconfirmed": {
      "id": "var_barstate.isconfirmed",
      "name": "barstate.isconfirmed",
      "description": "Returns true if the script is calculating the last\n                        (closing) update of the current bar. The next script calculation will be on the new bar data.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_barstate.isfirst": {
      "id": "var_barstate.isfirst",
      "name": "barstate.isfirst",
      "description": "Returns true if current bar is first bar in\n                        barset, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        },
        {
          "name": "barstate.isconfirmed",
          "href": "var_barstate.isconfirmed"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_barstate.ishistory": {
      "id": "var_barstate.ishistory",
      "name": "barstate.ishistory",
      "description": "Returns true if current bar is a historical bar,\n                        false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        },
        {
          "name": "barstate.isconfirmed",
          "href": "var_barstate.isconfirmed"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_barstate.islast": {
      "id": "var_barstate.islast",
      "name": "barstate.islast",
      "description": "Returns true if current bar is the last bar in\n                        barset, false otherwise. This condition is true for all real-time bars in barset.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        },
        {
          "name": "barstate.isconfirmed",
          "href": "var_barstate.isconfirmed"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_barstate.islastconfirmedhistory": {
      "id": "var_barstate.islastconfirmedhistory",
      "name": "barstate.islastconfirmedhistory",
      "description": "Returns true if script is executing on the\n                        dataset's last bar when market is closed, or script is executing on the bar immediately\n                        preceding the real-time bar, if market is open. Returns false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        }
      ]
    },
    "var_barstate.isnew": {
      "id": "var_barstate.isnew",
      "name": "barstate.isnew",
      "description": "Returns true if script is currently calculating on\n                        new bar, false otherwise. This variable is true when calculating on historical bars or on first\n                        update of a newly generated real-time bar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        },
        {
          "name": "barstate.isconfirmed",
          "href": "var_barstate.isconfirmed"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_barstate.isrealtime": {
      "id": "var_barstate.isrealtime",
      "name": "barstate.isrealtime",
      "description": "Returns true if current bar is a real-time bar,\n                        false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "barstate.isfirst",
          "href": "var_barstate.isfirst"
        },
        {
          "name": "barstate.islast",
          "href": "var_barstate.islast"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isnew",
          "href": "var_barstate.isnew"
        },
        {
          "name": "barstate.isconfirmed",
          "href": "var_barstate.isconfirmed"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "href": "var_barstate.islastconfirmedhistory"
        }
      ]
    },
    "var_bid": {
      "id": "var_bid",
      "name": "bid",
      "description": "The bid price at the time of the current tick,\n                        which represents the highest price an active buyer is willing to pay for the instrument at its\n                        current value. This information is available only on the \"1T\" timeframe. On other timeframes,\n                        the variable's value is na.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        }
      ]
    },
    "var_box.all": {
      "id": "var_box.all",
      "name": "box.all",
      "description": "Returns an array filled with all the current boxes\n                        drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"box.all\")//delete all boxesbox.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)a_allBoxes = box.allif array.size(a_allBoxes) > 0    for i = 0 to array.size(a_allBoxes) - 1        box.delete(array.get(a_allBoxes, i))"
      ],
      "type": "array<box>",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "line.all",
          "href": "var_line.all"
        },
        {
          "name": "label.all",
          "href": "var_label.all"
        },
        {
          "name": "table.all",
          "href": "var_table.all"
        }
      ]
    },
    "var_chart.bg_color": {
      "id": "var_chart.bg_color",
      "name": "chart.bg_color",
      "description": "Returns the color of the chart's background from\n                        the \"Chart settings/Appearance/Background\" field. When a gradient is selected, the middle point\n                        of the gradient is returned.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "input color",
      "seeAlso": [
        {
          "name": "chart.fg_color",
          "href": "var_chart.fg_color"
        }
      ]
    },
    "var_chart.fg_color": {
      "id": "var_chart.fg_color",
      "name": "chart.fg_color",
      "description": "Returns a color providing optimal contrast with chart.bg_color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "input color",
      "seeAlso": [
        {
          "name": "chart.bg_color",
          "href": "var_chart.bg_color"
        }
      ]
    },
    "var_chart.is_heikinashi": {
      "id": "var_chart.is_heikinashi",
      "name": "chart.is_heikinashi",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        }
      ]
    },
    "var_chart.is_kagi": {
      "id": "var_chart.is_kagi",
      "name": "chart.is_kagi",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        }
      ]
    },
    "var_chart.is_linebreak": {
      "id": "var_chart.is_linebreak",
      "name": "chart.is_linebreak",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        }
      ]
    },
    "var_chart.is_pnf": {
      "id": "var_chart.is_pnf",
      "name": "chart.is_pnf",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        }
      ]
    },
    "var_chart.is_range": {
      "id": "var_chart.is_range",
      "name": "chart.is_range",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        }
      ]
    },
    "var_chart.is_renko": {
      "id": "var_chart.is_renko",
      "name": "chart.is_renko",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        }
      ]
    },
    "var_chart.is_standard": {
      "id": "var_chart.is_standard",
      "name": "chart.is_standard",
      "description": "simple bool",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "chart.is_renko",
          "href": "var_chart.is_renko"
        },
        {
          "name": "chart.is_linebreak",
          "href": "var_chart.is_linebreak"
        },
        {
          "name": "chart.is_kagi",
          "href": "var_chart.is_kagi"
        },
        {
          "name": "chart.is_pnf",
          "href": "var_chart.is_pnf"
        },
        {
          "name": "chart.is_range",
          "href": "var_chart.is_range"
        },
        {
          "name": "chart.is_heikinashi",
          "href": "var_chart.is_heikinashi"
        }
      ]
    },
    "var_chart.left_visible_bar_time": {
      "id": "var_chart.left_visible_bar_time",
      "name": "chart.left_visible_bar_time",
      "description": "The time of the\n                        leftmost bar currently visible on the chart.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "input int",
      "seeAlso": [
        {
          "name": "chart.right_visible_bar_time",
          "href": "var_chart.right_visible_bar_time"
        }
      ]
    },
    "var_chart.right_visible_bar_time": {
      "id": "var_chart.right_visible_bar_time",
      "name": "chart.right_visible_bar_time",
      "description": "The time of the\n                        rightmost bar currently visible on the chart.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "input int",
      "seeAlso": [
        {
          "name": "chart.left_visible_bar_time",
          "href": "var_chart.left_visible_bar_time"
        }
      ]
    },
    "var_close": {
      "id": "var_close",
      "name": "close",
      "description": "Close price of the current bar when it has closed,\n                        or last traded price of a yet incomplete, realtime bar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_dayofmonth": {
      "id": "var_dayofmonth",
      "name": "dayofmonth",
      "description": "Date of current bar time in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "dayofmonth",
          "href": "fun_dayofmonth"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_dayofweek": {
      "id": "var_dayofweek",
      "name": "dayofweek",
      "description": "Day of week for current bar time in exchange\n                        timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "dayofweek",
          "href": "fun_dayofweek"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_dividends.future_amount": {
      "id": "var_dividends.future_amount",
      "name": "dividends.future_amount",
      "description": "Returns the payment amount of the upcoming\n                        dividend in the currency of the current instrument, or na if this data\n                        isn't available.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": []
    },
    "var_dividends.future_ex_date": {
      "id": "var_dividends.future_ex_date",
      "name": "dividends.future_ex_date",
      "description": "Returns the Ex-dividend date (Ex-date) of the\n                        current instrument's next dividend payment, or na if this data isn't\n                        available. Ex-dividend date signifies when investors are no longer entitled to a payout from the\n                        most recent dividend. Only those who purchased shares before this day are entitled to the\n                        dividend payment.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": []
    },
    "var_dividends.future_pay_date": {
      "id": "var_dividends.future_pay_date",
      "name": "dividends.future_pay_date",
      "description": "Returns the Payment date (Pay date) of the current\n                        instrument's next dividend payment, or na if this data isn't\n                        available. Payment date signifies the day when eligible investors will receive the dividend\n                        payment.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": []
    },
    "var_earnings.future_eps": {
      "id": "var_earnings.future_eps",
      "name": "earnings.future_eps",
      "description": "Returns the estimated Earnings per Share of the\n                        next earnings report in the currency of the instrument, or na if this\n                        data isn't available.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "var_earnings.future_period_end_time": {
      "id": "var_earnings.future_period_end_time",
      "name": "earnings.future_period_end_time",
      "description": "Checks the data for the next earnings report and\n                        returns the UNIX timestamp of the day when the financial period covered by those earnings ends,\n                        or na if this data isn't\n                        available.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "var_earnings.future_revenue": {
      "id": "var_earnings.future_revenue",
      "name": "earnings.future_revenue",
      "description": "Returns the estimated Revenue of the next earnings\n                        report in the currency of the instrument, or na if this data isn't\n                        available.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "var_earnings.future_time": {
      "id": "var_earnings.future_time",
      "name": "earnings.future_time",
      "description": "Returns a UNIX timestamp indicating the expected\n                        time of the next earnings report, or na\n                        if this data isn't available.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "var_high": {
      "id": "var_high",
      "name": "high",
      "description": "Current high price.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_hl2": {
      "id": "var_hl2",
      "name": "hl2",
      "description": "Is a shortcut for (high + low)/2",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_hlc3": {
      "id": "var_hlc3",
      "name": "hlc3",
      "description": "Is a shortcut for (high + low + close)/3",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_hlcc4": {
      "id": "var_hlcc4",
      "name": "hlcc4",
      "description": "Is a shortcut for (high + low + close + close)/4",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_hour": {
      "id": "var_hour",
      "name": "hour",
      "description": "Current bar hour in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "hour",
          "href": "fun_hour"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_label.all": {
      "id": "var_label.all",
      "name": "label.all",
      "description": "Returns an array filled with all the current\n                        labels drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"label.all\")//delete all labelslabel.new(bar_index, close)a_allLabels = label.allif array.size(a_allLabels) > 0    for i = 0 to array.size(a_allLabels) - 1        label.delete(array.get(a_allLabels, i))"
      ],
      "type": "array<label>",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "line.all",
          "href": "var_line.all"
        },
        {
          "name": "box.all",
          "href": "var_box.all"
        },
        {
          "name": "table.all",
          "href": "var_table.all"
        }
      ]
    },
    "var_last_bar_index": {
      "id": "var_last_bar_index",
      "name": "last_bar_index",
      "description": "Bar index of the last chart bar. Bar indices begin\n                        at zero on the first bar.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)lastBarsFilterInput = input.int(100, \"Bars Count:\")// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.var lastbar = last_bar_index// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.allowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtimebgcolor(allowedToTrade ? color.new(color.green, 80) : na)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "bar_index",
          "href": "var_bar_index"
        },
        {
          "name": "last_bar_time",
          "href": "var_last_bar_time"
        },
        {
          "name": "barstate.ishistory",
          "href": "var_barstate.ishistory"
        },
        {
          "name": "barstate.isrealtime",
          "href": "var_barstate.isrealtime"
        }
      ]
    },
    "var_last_bar_time": {
      "id": "var_last_bar_time",
      "name": "last_bar_time",
      "description": "Time in UNIX format of the last chart bar. It is\n                        the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "timenow",
          "href": "var_timenow"
        },
        {
          "name": "timestamp",
          "href": "fun_timestamp"
        },
        {
          "name": "last_bar_index",
          "href": "var_last_bar_index"
        }
      ]
    },
    "var_line.all": {
      "id": "var_line.all",
      "name": "line.all",
      "description": "Returns an array filled with all the current lines\n                        drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"line.all\")//delete all linesline.new(bar_index - 10, close, bar_index, close)a_allLines = line.allif array.size(a_allLines) > 0    for i = 0 to array.size(a_allLines) - 1        line.delete(array.get(a_allLines, i))"
      ],
      "type": "array<line>",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "label.all",
          "href": "var_label.all"
        },
        {
          "name": "box.all",
          "href": "var_box.all"
        },
        {
          "name": "table.all",
          "href": "var_table.all"
        }
      ]
    },
    "var_linefill.all": {
      "id": "var_linefill.all",
      "name": "linefill.all",
      "description": "Returns an array filled with all the current\n                        linefill objects drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "array<linefill>",
      "seeAlso": []
    },
    "var_low": {
      "id": "var_low",
      "name": "low",
      "description": "Current low price.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_minute": {
      "id": "var_minute",
      "name": "minute",
      "description": "Current bar minute in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "minute",
          "href": "fun_minute"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_month": {
      "id": "var_month",
      "name": "month",
      "description": "Current bar month in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "month",
          "href": "fun_month"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_na": {
      "id": "var_na",
      "name": "na",
      "description": "A keyword signifying \"not available\", indicating\n                        that a variable has no assigned value.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"na\")// CORRECT// Plot no value when on bars zero to nine. Plot `close` on other bars.plot(bar_index < 10 ? na : close)// CORRECT ALTERNATIVE// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.float a = naif bar_index >= 10    a := closeplot(a)// INCORRECT// Trying to test the preceding bar's `close` for `na`.// The next line, if uncommented, will cause a compilation error, because direct comparison with `na` is not allowed.// plot(close[1] == na ? close : close[1])// CORRECT// Use the `na()` function to test for `na`.plot(na(close[1]) ? close : close[1])// CORRECT ALTERNATIVE// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.plot(nz(close[1], close))"
      ],
      "type": "simple na",
      "seeAlso": [
        {
          "name": "na",
          "href": "fun_na"
        },
        {
          "name": "nz",
          "href": "fun_nz"
        },
        {
          "name": "fixnan",
          "href": "fun_fixnan"
        }
      ]
    },
    "var_ohlc4": {
      "id": "var_ohlc4",
      "name": "ohlc4",
      "description": "Is a shortcut for (open + high + low + close)/4",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        }
      ]
    },
    "var_open": {
      "id": "var_open",
      "name": "open",
      "description": "Current open price.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "volume",
          "href": "var_volume"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_polyline.all": {
      "id": "var_polyline.all",
      "name": "polyline.all",
      "description": "Returns an array containing all current polyline instances\n                        drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "array<polyline>",
      "seeAlso": []
    },
    "var_second": {
      "id": "var_second",
      "name": "second",
      "description": "Current bar second in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "second",
          "href": "fun_second"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        }
      ]
    },
    "var_session.isfirstbar": {
      "id": "var_session.isfirstbar",
      "name": "session.isfirstbar",
      "description": "Returns true if the\n                        current bar is the first bar of the day's session, false\n                        otherwise. If extended session information is used, only returns true on the first\n                        bar of the pre-market bars.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"`session.isfirstbar` Example\", overlay = true)longCondition = year >= 2022// Place a long order at the `close` of the trading session's first bar.if session.isfirstbar and longCondition     strategy.entry(\"Long\", strategy.long)// Close the long position at the `close` of the trading session's last bar.if session.islastbar and barstate.isconfirmed    strategy.close(\"Long\", immediately = true)"
      ],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.isfirstbar_regular",
          "href": "var_session.isfirstbar_regular"
        },
        {
          "name": "session.islastbar",
          "href": "var_session.islastbar"
        },
        {
          "name": "session.islastbar_regular",
          "href": "var_session.islastbar_regular"
        }
      ]
    },
    "var_session.isfirstbar_regular": {
      "id": "var_session.isfirstbar_regular",
      "name": "session.isfirstbar_regular",
      "description": "Returns true on the\n                        first regular session bar of the day, false otherwise. The result\n                        is the same whether extended session information is used or not.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"`session.isfirstbar_regular` Example\", overlay = true)longCondition = year >= 2022// Place a long order at the `close` of the trading session's first bar.if session.isfirstbar and longCondition    strategy.entry(\"Long\", strategy.long)// Close the long position at the `close` of the trading session's last bar.if session.islastbar_regular and barstate.isconfirmed    strategy.close(\"Long\", immediately = true)"
      ],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.isfirstbar",
          "href": "var_session.isfirstbar"
        },
        {
          "name": "session.islastbar",
          "href": "var_session.islastbar"
        }
      ]
    },
    "var_session.islastbar": {
      "id": "var_session.islastbar",
      "name": "session.islastbar",
      "description": "Returns true if the\n                        current bar is the last bar of the day's session, false\n                        otherwise. If extended session information is used, only returns true on the last\n                        bar of the post-market bars.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"`session.islastbar` Example\", overlay = true)longCondition = year >= 2022// Place a long order at the `close` of the trading session's last bar.// The position will enter on the `open` of next session's first bar.if session.islastbar and longCondition    strategy.entry(\"Long\", strategy.long) // Close 'Long' position at the close of the last bar of the trading sessionif session.islastbar and barstate.isconfirmed    strategy.close(\"Long\", immediately = true)"
      ],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.isfirstbar",
          "href": "var_session.isfirstbar"
        },
        {
          "name": "session.islastbar_regular",
          "href": "var_session.islastbar_regular"
        }
      ]
    },
    "var_session.islastbar_regular": {
      "id": "var_session.islastbar_regular",
      "name": "session.islastbar_regular",
      "description": "Returns true on the\n                        last regular session bar of the day, false otherwise. The result\n                        is the same whether extended session information is used or not.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"`session.islastbar_regular` Example\", overlay = true)longCondition = year >= 2022// Place a long order at the `close` of the trading session's first bar.if session.isfirstbar and longCondition    strategy.entry(\"Long\", strategy.long)// Close the long position at the `close` of the trading session's last bar.if session.islastbar_regular and barstate.isconfirmed    strategy.close(\"Long\", immediately = true)"
      ],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.isfirstbar",
          "href": "var_session.isfirstbar"
        },
        {
          "name": "session.islastbar",
          "href": "var_session.islastbar"
        },
        {
          "name": "session.isfirstbar_regular",
          "href": "var_session.isfirstbar_regular"
        }
      ]
    },
    "var_session.ismarket": {
      "id": "var_session.ismarket",
      "name": "session.ismarket",
      "description": "Returns true if the\n                        current bar is a part of the regular trading hours (i.e. market hours), false\n                        otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.ispremarket",
          "href": "var_session.ispremarket"
        },
        {
          "name": "session.ispostmarket",
          "href": "var_session.ispostmarket"
        }
      ]
    },
    "var_session.ispostmarket": {
      "id": "var_session.ispostmarket",
      "name": "session.ispostmarket",
      "description": "Returns true if the\n                        current bar is a part of the post-market, false otherwise. On\n                        non-intraday charts always returns false.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.ismarket",
          "href": "var_session.ismarket"
        },
        {
          "name": "session.ispremarket",
          "href": "var_session.ispremarket"
        }
      ]
    },
    "var_session.ispremarket": {
      "id": "var_session.ispremarket",
      "name": "session.ispremarket",
      "description": "Returns true if the\n                        current bar is a part of the pre-market, false otherwise. On\n                        non-intraday charts always returns false.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series bool",
      "seeAlso": [
        {
          "name": "session.ismarket",
          "href": "var_session.ismarket"
        },
        {
          "name": "session.ispostmarket",
          "href": "var_session.ispostmarket"
        }
      ]
    },
    "var_strategy.account_currency": {
      "id": "var_strategy.account_currency",
      "name": "strategy.account_currency",
      "description": "Returns the currency used to calculate results,\n                        which can be set in the strategy's properties.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        },
        {
          "name": "strategy.convert_to_account",
          "href": "fun_strategy.convert_to_account"
        },
        {
          "name": "strategy.convert_to_symbol",
          "href": "fun_strategy.convert_to_symbol"
        }
      ]
    },
    "var_strategy.avg_losing_trade": {
      "id": "var_strategy.avg_losing_trade",
      "name": "strategy.avg_losing_trade",
      "description": "Returns the average amount of money lost per\n                        losing trade. Calculated as the sum of losses divided by the number of losing trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_losing_trade_percent",
          "href": "var_strategy.avg_losing_trade_percent"
        }
      ]
    },
    "var_strategy.avg_losing_trade_percent": {
      "id": "var_strategy.avg_losing_trade_percent",
      "name": "strategy.avg_losing_trade_percent",
      "description": "Returns the average percentage loss per losing\n                        trade. Calculated as the sum of loss percentages divided by the number of losing trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_losing_trade",
          "href": "var_strategy.avg_losing_trade"
        }
      ]
    },
    "var_strategy.avg_trade": {
      "id": "var_strategy.avg_trade",
      "name": "strategy.avg_trade",
      "description": "Returns the average amount of money gained or lost\n                        per trade. Calculated as the sum of all profits and losses divided by the number of closed\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_trade_percent",
          "href": "var_strategy.avg_trade_percent"
        }
      ]
    },
    "var_strategy.avg_trade_percent": {
      "id": "var_strategy.avg_trade_percent",
      "name": "strategy.avg_trade_percent",
      "description": "Returns the average percentage gain or loss per\n                        trade. Calculated as the sum of all profit and loss percentages divided by the number of closed\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_trade",
          "href": "var_strategy.avg_trade"
        }
      ]
    },
    "var_strategy.avg_winning_trade": {
      "id": "var_strategy.avg_winning_trade",
      "name": "strategy.avg_winning_trade",
      "description": "Returns the average amount of money gained per\n                        winning trade. Calculated as the sum of profits divided by the number of winning trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_winning_trade_percent",
          "href": "var_strategy.avg_winning_trade_percent"
        }
      ]
    },
    "var_strategy.avg_winning_trade_percent": {
      "id": "var_strategy.avg_winning_trade_percent",
      "name": "strategy.avg_winning_trade_percent",
      "description": "Returns the average percentage gain per winning\n                        trade. Calculated as the sum of profit percentages divided by the number of winning trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.avg_winning_trade",
          "href": "var_strategy.avg_winning_trade"
        }
      ]
    },
    "var_strategy.closedtrades": {
      "id": "var_strategy.closedtrades",
      "name": "strategy.closedtrades",
      "description": "Number of trades, which were closed for the whole\n                        trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.wintrades",
          "href": "var_strategy.wintrades"
        },
        {
          "name": "strategy.losstrades",
          "href": "var_strategy.losstrades"
        },
        {
          "name": "strategy.eventrades",
          "href": "var_strategy.eventrades"
        }
      ]
    },
    "var_strategy.closedtrades.first_index": {
      "id": "var_strategy.closedtrades.first_index",
      "name": "strategy.closedtrades.first_index",
      "description": "The index, or trade number, of the first (oldest)\n                        trade listed in the List of Trades. This number is usually zero. If more trades than the allowed\n                        limit have been closed, the oldest trades are removed, and this number is the index of the\n                        oldest remaining trade.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.wintrades",
          "href": "var_strategy.wintrades"
        },
        {
          "name": "strategy.losstrades",
          "href": "var_strategy.losstrades"
        },
        {
          "name": "strategy.eventrades",
          "href": "var_strategy.eventrades"
        }
      ]
    },
    "var_strategy.equity": {
      "id": "var_strategy.equity",
      "name": "strategy.equity",
      "description": "Current equity (strategy.initial_capital + strategy.netprofit\n                        + strategy.openprofit).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.openprofit",
          "href": "var_strategy.openprofit"
        },
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        }
      ]
    },
    "var_strategy.eventrades": {
      "id": "var_strategy.eventrades",
      "name": "strategy.eventrades",
      "description": "Number of breakeven trades for the whole trading\n                        range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        },
        {
          "name": "strategy.wintrades",
          "href": "var_strategy.wintrades"
        },
        {
          "name": "strategy.losstrades",
          "href": "var_strategy.losstrades"
        }
      ]
    },
    "var_strategy.grossloss": {
      "id": "var_strategy.grossloss",
      "name": "strategy.grossloss",
      "description": "Total currency value of all completed losing\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.grossprofit",
          "href": "var_strategy.grossprofit"
        }
      ]
    },
    "var_strategy.grossloss_percent": {
      "id": "var_strategy.grossloss_percent",
      "name": "strategy.grossloss_percent",
      "description": "The total value of all completed losing trades,\n                        expressed as a percentage of the initial capital.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.grossloss",
          "href": "var_strategy.grossloss"
        }
      ]
    },
    "var_strategy.grossprofit": {
      "id": "var_strategy.grossprofit",
      "name": "strategy.grossprofit",
      "description": "Total currency value of all completed winning\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.grossloss",
          "href": "var_strategy.grossloss"
        }
      ]
    },
    "var_strategy.grossprofit_percent": {
      "id": "var_strategy.grossprofit_percent",
      "name": "strategy.grossprofit_percent",
      "description": "The total currency value of all completed winning\n                        trades, expressed as a percentage of the initial capital.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.grossprofit",
          "href": "var_strategy.grossprofit"
        }
      ]
    },
    "var_strategy.initial_capital": {
      "id": "var_strategy.initial_capital",
      "name": "strategy.initial_capital",
      "description": "The amount of initial capital set in the strategy\n                        properties.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "var_strategy.losstrades": {
      "id": "var_strategy.losstrades",
      "name": "strategy.losstrades",
      "description": "Number of unprofitable trades for the whole\n                        trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        },
        {
          "name": "strategy.wintrades",
          "href": "var_strategy.wintrades"
        },
        {
          "name": "strategy.eventrades",
          "href": "var_strategy.eventrades"
        }
      ]
    },
    "var_strategy.margin_liquidation_price": {
      "id": "var_strategy.margin_liquidation_price",
      "name": "strategy.margin_liquidation_price",
      "description": "When margin is used in a strategy, returns the\n                        price point where a simulated margin call will occur and liquidate enough of the position to\n                        meet the margin requirements.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25,   default_qty_type = strategy.percent_of_equity, default_qty_value = 395)float maFast = ta.sma(close, 14)float maSlow = ta.sma(close, 28)if ta.crossover(maFast, maSlow)    strategy.entry(\"Long\", strategy.long)if ta.crossunder(maFast, maSlow)    strategy.entry(\"Short\", strategy.short)changePercent(v1, v2) =>     float result = (v1 - v2) * 100 / math.abs(v2)// exit when we're 10% away from a margin call, to prevent it.if math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10    strategy.close(\"Long\")    strategy.close(\"Short\")"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_strategy.max_contracts_held_all": {
      "id": "var_strategy.max_contracts_held_all",
      "name": "strategy.max_contracts_held_all",
      "description": "Maximum number of contracts/shares/lots/units in\n                        one trade for the whole trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.max_contracts_held_long",
          "href": "var_strategy.max_contracts_held_long"
        },
        {
          "name": "strategy.max_contracts_held_short",
          "href": "var_strategy.max_contracts_held_short"
        }
      ]
    },
    "var_strategy.max_contracts_held_long": {
      "id": "var_strategy.max_contracts_held_long",
      "name": "strategy.max_contracts_held_long",
      "description": "Maximum number of contracts/shares/lots/units in\n                        one long trade for the whole trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.max_contracts_held_all",
          "href": "var_strategy.max_contracts_held_all"
        },
        {
          "name": "strategy.max_contracts_held_short",
          "href": "var_strategy.max_contracts_held_short"
        }
      ]
    },
    "var_strategy.max_contracts_held_short": {
      "id": "var_strategy.max_contracts_held_short",
      "name": "strategy.max_contracts_held_short",
      "description": "Maximum number of contracts/shares/lots/units in\n                        one short trade for the whole trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.max_contracts_held_all",
          "href": "var_strategy.max_contracts_held_all"
        },
        {
          "name": "strategy.max_contracts_held_long",
          "href": "var_strategy.max_contracts_held_long"
        }
      ]
    },
    "var_strategy.max_drawdown": {
      "id": "var_strategy.max_drawdown",
      "name": "strategy.max_drawdown",
      "description": "Maximum equity drawdown value for the whole\n                        trading range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.equity",
          "href": "var_strategy.equity"
        },
        {
          "name": "strategy.max_runup",
          "href": "var_strategy.max_runup"
        }
      ]
    },
    "var_strategy.max_drawdown_percent": {
      "id": "var_strategy.max_drawdown_percent",
      "name": "strategy.max_drawdown_percent",
      "description": "The maximum equity drawdown value for the whole\n                        trading range, expressed as a percentage and calculated by formula: Lowest Value During\n                            Trade / (Entry Price x Quantity) * 100.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "var_strategy.max_runup": {
      "id": "var_strategy.max_runup",
      "name": "strategy.max_runup",
      "description": "Maximum equity run-up value for the whole trading\n                        range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.equity",
          "href": "var_strategy.equity"
        },
        {
          "name": "strategy.max_drawdown",
          "href": "var_strategy.max_drawdown"
        }
      ]
    },
    "var_strategy.max_runup_percent": {
      "id": "var_strategy.max_runup_percent",
      "name": "strategy.max_runup_percent",
      "description": "The maximum equity run-up value for the whole\n                        trading range, expressed as a percentage and calculated by formula: Highest Value During\n                            Trade / (Entry Price x Quantity) * 100.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.max_runup",
          "href": "var_strategy.max_runup"
        }
      ]
    },
    "var_strategy.netprofit": {
      "id": "var_strategy.netprofit",
      "name": "strategy.netprofit",
      "description": "Total currency value of all completed trades.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.openprofit",
          "href": "var_strategy.openprofit"
        },
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.grossprofit",
          "href": "var_strategy.grossprofit"
        },
        {
          "name": "strategy.grossloss",
          "href": "var_strategy.grossloss"
        }
      ]
    },
    "var_strategy.netprofit_percent": {
      "id": "var_strategy.netprofit_percent",
      "name": "strategy.netprofit_percent",
      "description": "The total value of all completed trades, expressed\n                        as a percentage of the initial capital.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        }
      ]
    },
    "var_strategy.openprofit": {
      "id": "var_strategy.openprofit",
      "name": "strategy.openprofit",
      "description": "Current unrealized profit or loss for all open\n                        positions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.netprofit",
          "href": "var_strategy.netprofit"
        },
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        }
      ]
    },
    "var_strategy.openprofit_percent": {
      "id": "var_strategy.openprofit_percent",
      "name": "strategy.openprofit_percent",
      "description": "The current unrealized profit or loss for all open\n                        positions, expressed as a percentage and calculated by formula: openPL / realizedEquity *\n                            100.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.openprofit",
          "href": "var_strategy.openprofit"
        }
      ]
    },
    "var_strategy.opentrades": {
      "id": "var_strategy.opentrades",
      "name": "strategy.opentrades",
      "description": "Number of market position entries, which were not\n                        closed and remain opened. If there is no open market position, 0 is returned.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        }
      ]
    },
    "var_strategy.opentrades.capital_held": {
      "id": "var_strategy.opentrades.capital_held",
      "name": "strategy.opentrades.capital_held",
      "description": "Returns the capital amount currently held by open\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(   \"strategy.opentrades.capital_held example\", overlay=false, margin_long=50, margin_short=50,    default_qty_type = strategy.percent_of_equity, default_qty_value = 100 )// Enter a short position on the first bar.if barstate.isfirst    strategy.entry(\"Short\", strategy.short)// Plot the capital held by the short position.plot(strategy.opentrades.capital_held, \"Capital held\")// Highlight the chart background if the position is completely closed by margin calls.bgcolor(bar_index > 0 and strategy.opentrades.capital_held == 0 ? color.new(color.red, 60) : na)"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_strategy.position_avg_price": {
      "id": "var_strategy.position_avg_price",
      "name": "strategy.position_avg_price",
      "description": "Average entry price of current market position. If\n                        the market position is flat, 'NaN' is returned.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        }
      ]
    },
    "var_strategy.position_entry_name": {
      "id": "var_strategy.position_entry_name",
      "name": "strategy.position_entry_name",
      "description": "Name of the order that initially opened current\n                        market position.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series string",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        }
      ]
    },
    "var_strategy.position_size": {
      "id": "var_strategy.position_size",
      "name": "strategy.position_size",
      "description": "Direction and size of the current market position.\n                        If the value is > 0, the market position is long. If the value is < 0, the market position\n                        is short. The absolute value is the number of contracts/shares/lots/units in trade (position\n                        size).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "strategy.position_avg_price",
          "href": "var_strategy.position_avg_price"
        }
      ]
    },
    "var_strategy.wintrades": {
      "id": "var_strategy.wintrades",
      "name": "strategy.wintrades",
      "description": "Number of profitable trades for the whole trading\n                        range.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "strategy.position_size",
          "href": "var_strategy.position_size"
        },
        {
          "name": "strategy.opentrades",
          "href": "var_strategy.opentrades"
        },
        {
          "name": "strategy.closedtrades",
          "href": "var_strategy.closedtrades"
        },
        {
          "name": "strategy.losstrades",
          "href": "var_strategy.losstrades"
        },
        {
          "name": "strategy.eventrades",
          "href": "var_strategy.eventrades"
        }
      ]
    },
    "var_syminfo.basecurrency": {
      "id": "var_syminfo.basecurrency",
      "name": "syminfo.basecurrency",
      "description": "Returns a string containing the code representing\n                        the symbol's base currency (i.e., the traded currency or coin) if the instrument is a Forex or\n                        Crypto pair or a derivative based on such a pair. Otherwise, it returns an empty string. For\n                        example, this variable returns \"EUR\" for \"EURJPY\", \"BTC\" for \"BTCUSDT\", \"CAD\" for \"CME:6C1!\",\n                        and \"\" for \"NASDAQ:AAPL\".",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.currency",
          "href": "var_syminfo.currency"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        }
      ]
    },
    "var_syminfo.country": {
      "id": "var_syminfo.country",
      "name": "syminfo.country",
      "description": "Returns the two-letter code of the country where\n                        the symbol is traded, in the ISO 3166-1 alpha-2 format, or na if the exchange is not\n                        directly tied to a specific country. For example, on \"NASDAQ:AAPL\" it will return \"US\", on\n                        \"LSE:AAPL\" it will return \"GB\", and on \"BITSTAMP:BTCUSD it will return na.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": []
    },
    "var_syminfo.currency": {
      "id": "var_syminfo.currency",
      "name": "syminfo.currency",
      "description": "Returns a string containing the code representing\n                        the currency of the symbol's prices. For example, this variable returns \"USD\" for \"NASDAQ:AAPL\"\n                        and \"JPY\" for \"EURJPY\".",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.basecurrency",
          "href": "var_syminfo.basecurrency"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "currency.USD",
          "href": "const_currency.USD"
        },
        {
          "name": "currency.EUR",
          "href": "const_currency.EUR"
        }
      ]
    },
    "var_syminfo.current_contract": {
      "id": "var_syminfo.current_contract",
      "name": "syminfo.current_contract",
      "description": "The ticker identifier of the underlying contract,\n                        if the current symbol is a continuous futures contract; na otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.description",
          "href": "var_syminfo.description"
        }
      ]
    },
    "var_syminfo.description": {
      "id": "var_syminfo.description",
      "name": "syminfo.description",
      "description": "Description for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.prefix",
          "href": "var_syminfo.prefix"
        }
      ]
    },
    "var_syminfo.employees": {
      "id": "var_syminfo.employees",
      "name": "syminfo.employees",
      "description": "The number of employees the company has.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo simple\")//@variable A table containing information about a company's employees, shareholders, and shares.var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)if barstate.islastconfirmedhistory    // Add header cells    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")    // Add employee info cells.    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))    // Add shareholder cells.    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))    // Add float shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))    // Add total shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "syminfo.shareholders",
          "href": "var_syminfo.shareholders"
        },
        {
          "name": "syminfo.shares_outstanding_float",
          "href": "var_syminfo.shares_outstanding_float"
        },
        {
          "name": "syminfo.shares_outstanding_total",
          "href": "var_syminfo.shares_outstanding_total"
        }
      ]
    },
    "var_syminfo.expiration_date": {
      "id": "var_syminfo.expiration_date",
      "name": "syminfo.expiration_date",
      "description": "A UNIX timestamp representing the start of the\n                        last day of the current futures contract. This variable is only compatible with non-continuous\n                        futures symbols. On other symbols, it returns na.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple int",
      "seeAlso": []
    },
    "var_syminfo.industry": {
      "id": "var_syminfo.industry",
      "name": "syminfo.industry",
      "description": "Returns the industry of the symbol, or na if the symbol has no industry.\n                        Example: \"Internet Software/Services\", \"Packaged software\", \"Integrated Oil\", \"Motor Vehicles\",\n                        etc. These are the same values one can see in the chart's \"Symbol info\" window.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": []
    },
    "var_syminfo.main_tickerid": {
      "id": "var_syminfo.main_tickerid",
      "name": "syminfo.main_tickerid",
      "description": "A ticker identifier representing the current\n                        chart's symbol. The value contains an exchange prefix and a symbol name, separated by a colon\n                        (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend\n                        adjustment, non-standard chart type, currency conversion, etc. Unlike syminfo.tickerid,\n                        this variable's value does not change when used in the expression argument of a\n                        request.*() function call.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "timeframe.main_period",
          "href": "var_timeframe.main_period"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        },
        {
          "name": "syminfo.root",
          "href": "var_syminfo.root"
        }
      ]
    },
    "var_syminfo.mincontract": {
      "id": "var_syminfo.mincontract",
      "name": "syminfo.mincontract",
      "description": "The smallest amount of the current symbol that can\n                        be traded. This limit is set by the exchange. For cryptocurrencies, it is often less than 1\n                        token. For most other types of asset, it is often 1.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple float",
      "seeAlso": [
        {
          "name": "syminfo.mintick",
          "href": "var_syminfo.mintick"
        },
        {
          "name": "syminfo.pointvalue",
          "href": "var_syminfo.pointvalue"
        }
      ]
    },
    "var_syminfo.minmove": {
      "id": "var_syminfo.minmove",
      "name": "syminfo.minmove",
      "description": "Returns a whole number used to calculate the\n                        smallest increment between a symbol's price movements (syminfo.mintick).\n                        It is the numerator in the syminfo.mintick formula:\n                        syminfo.minmove / syminfo.pricescale = syminfo.mintick.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        },
        {
          "name": "syminfo.root",
          "href": "var_syminfo.root"
        }
      ]
    },
    "var_syminfo.mintick": {
      "id": "var_syminfo.mintick",
      "name": "syminfo.mintick",
      "description": "Min tick value for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple float",
      "seeAlso": [
        {
          "name": "syminfo.pointvalue",
          "href": "var_syminfo.pointvalue"
        },
        {
          "name": "syminfo.mincontract",
          "href": "var_syminfo.mincontract"
        }
      ]
    },
    "var_syminfo.pointvalue": {
      "id": "var_syminfo.pointvalue",
      "name": "syminfo.pointvalue",
      "description": "Point value for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple float",
      "seeAlso": [
        {
          "name": "syminfo.mintick",
          "href": "var_syminfo.mintick"
        },
        {
          "name": "syminfo.mincontract",
          "href": "var_syminfo.mincontract"
        }
      ]
    },
    "var_syminfo.prefix": {
      "id": "var_syminfo.prefix",
      "name": "syminfo.prefix",
      "description": "Prefix of current symbol name (i.e. for\n                        'CME_EOD:TICKER' prefix is 'CME_EOD').",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo.prefix\")// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.if barstate.islastconfirmedhistory    label.new(bar_index, high, text=syminfo.prefix)"
      ],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "var_syminfo.pricescale": {
      "id": "var_syminfo.pricescale",
      "name": "syminfo.pricescale",
      "description": "Returns a whole number used to calculate the\n                        smallest increment between a symbol's price movements (syminfo.mintick).\n                        It is the denominator in the syminfo.mintick formula:\n                        syminfo.minmove / syminfo.pricescale = syminfo.mintick.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        },
        {
          "name": "syminfo.root",
          "href": "var_syminfo.root"
        }
      ]
    },
    "var_syminfo.recommendations_buy": {
      "id": "var_syminfo.recommendations_buy",
      "name": "syminfo.recommendations_buy",
      "description": "The number of analysts who gave the current symbol\n                        a \"Buy\" rating.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.recommendations_buy_strong": {
      "id": "var_syminfo.recommendations_buy_strong",
      "name": "syminfo.recommendations_buy_strong",
      "description": "The number of analysts who gave the current symbol\n                        a \"Strong Buy\" rating.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.recommendations_date": {
      "id": "var_syminfo.recommendations_date",
      "name": "syminfo.recommendations_date",
      "description": "The starting date of the last set of\n                        recommendations for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.recommendations_hold": {
      "id": "var_syminfo.recommendations_hold",
      "name": "syminfo.recommendations_hold",
      "description": "The number of analysts who gave the current symbol\n                        a \"Hold\" rating.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.recommendations_sell": {
      "id": "var_syminfo.recommendations_sell",
      "name": "syminfo.recommendations_sell",
      "description": "The number of analysts who gave the current symbol\n                        a \"Sell\" rating.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.recommendations_sell_strong": {
      "id": "var_syminfo.recommendations_sell_strong",
      "name": "syminfo.recommendations_sell_strong",
      "description": "The number of analysts who gave the current symbol\n                        a \"Strong Sell\" rating.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_total",
          "href": "var_syminfo.recommendations_total"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        }
      ]
    },
    "var_syminfo.recommendations_total": {
      "id": "var_syminfo.recommendations_total",
      "name": "syminfo.recommendations_total",
      "description": "The total number of recommendations for the\n                        current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo recommendations\", overlay = true)//@variable A table containing information about analyst recommendations.var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    // Add header cells.    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)    // Recommendation strings    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")    string buyRatings        = str.tostring(syminfo.recommendations_buy)    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)    string sellRatings       = str.tostring(syminfo.recommendations_sell)    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)    string holdRatings       = str.tostring(syminfo.recommendations_hold)    string totalRatings      = str.tostring(syminfo.recommendations_total)    // Add value cells    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.recommendations_buy",
          "href": "var_syminfo.recommendations_buy"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "href": "var_syminfo.recommendations_buy_strong"
        },
        {
          "name": "syminfo.recommendations_date",
          "href": "var_syminfo.recommendations_date"
        },
        {
          "name": "syminfo.recommendations_hold",
          "href": "var_syminfo.recommendations_hold"
        },
        {
          "name": "syminfo.recommendations_sell",
          "href": "var_syminfo.recommendations_sell"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "href": "var_syminfo.recommendations_sell_strong"
        }
      ]
    },
    "var_syminfo.root": {
      "id": "var_syminfo.root",
      "name": "syminfo.root",
      "description": "Root for derivatives like futures contract. For\n                        other symbols returns the same value as syminfo.ticker.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo.root\")// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.if barstate.islastconfirmedhistory    label.new(bar_index, high, syminfo.root)"
      ],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        }
      ]
    },
    "var_syminfo.sector": {
      "id": "var_syminfo.sector",
      "name": "syminfo.sector",
      "description": "Returns the sector of the symbol, or na if the symbol has no sector.\n                        Example: \"Electronic Technology\", \"Technology services\", \"Energy Minerals\", \"Consumer Durables\",\n                        etc. These are the same values one can see in the chart's \"Symbol info\" window.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": []
    },
    "var_syminfo.session": {
      "id": "var_syminfo.session",
      "name": "syminfo.session",
      "description": "Session type of the chart main series. Possible\n                        values are session.regular, session.extended.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "session.regular",
          "href": "const_session.regular"
        },
        {
          "name": "session.extended",
          "href": "const_session.extended"
        }
      ]
    },
    "var_syminfo.shareholders": {
      "id": "var_syminfo.shareholders",
      "name": "syminfo.shareholders",
      "description": "The number of shareholders the company has.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo simple\")//@variable A table containing information about a company's employees, shareholders, and shares.var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)if barstate.islastconfirmedhistory    // Add header cells    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")    // Add employee info cells.    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))    // Add shareholder cells.    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))    // Add float shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))    // Add total shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "syminfo.employees",
          "href": "var_syminfo.employees"
        },
        {
          "name": "syminfo.shares_outstanding_float",
          "href": "var_syminfo.shares_outstanding_float"
        },
        {
          "name": "syminfo.shares_outstanding_total",
          "href": "var_syminfo.shares_outstanding_total"
        }
      ]
    },
    "var_syminfo.shares_outstanding_float": {
      "id": "var_syminfo.shares_outstanding_float",
      "name": "syminfo.shares_outstanding_float",
      "description": "The total number of shares outstanding a company\n                        has available, excluding any of its restricted shares.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo simple\")//@variable A table containing information about a company's employees, shareholders, and shares.var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)if barstate.islastconfirmedhistory    // Add header cells    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")    // Add employee info cells.    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))    // Add shareholder cells.    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))    // Add float shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))    // Add total shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ],
      "type": "simple float",
      "seeAlso": [
        {
          "name": "syminfo.employees",
          "href": "var_syminfo.employees"
        },
        {
          "name": "syminfo.shareholders",
          "href": "var_syminfo.shareholders"
        },
        {
          "name": "syminfo.shares_outstanding_total",
          "href": "var_syminfo.shares_outstanding_total"
        }
      ]
    },
    "var_syminfo.shares_outstanding_total": {
      "id": "var_syminfo.shares_outstanding_total",
      "name": "syminfo.shares_outstanding_total",
      "description": "The total number of shares outstanding a company\n                        has available, including restricted shares held by insiders, major shareholders, and employees.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo simple\")//@variable A table containing information about a company's employees, shareholders, and shares.var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)if barstate.islastconfirmedhistory    // Add header cells    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")    // Add employee info cells.    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))    // Add shareholder cells.    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))    // Add float shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))    // Add total shares outstanding cells.    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "syminfo.employees",
          "href": "var_syminfo.employees"
        },
        {
          "name": "syminfo.shareholders",
          "href": "var_syminfo.shareholders"
        },
        {
          "name": "syminfo.shares_outstanding_float",
          "href": "var_syminfo.shares_outstanding_float"
        }
      ]
    },
    "var_syminfo.target_price_average": {
      "id": "var_syminfo.target_price_average",
      "name": "syminfo.target_price_average",
      "description": "The average of the last yearly price targets for\n                        the symbol predicted by analysts.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series float",
      "seeAlso": [
        {
          "name": "syminfo.target_price_date",
          "href": "var_syminfo.target_price_date"
        },
        {
          "name": "syminfo.target_price_estimates",
          "href": "var_syminfo.target_price_estimates"
        },
        {
          "name": "syminfo.target_price_high",
          "href": "var_syminfo.target_price_high"
        },
        {
          "name": "syminfo.target_price_low",
          "href": "var_syminfo.target_price_low"
        },
        {
          "name": "syminfo.target_price_median",
          "href": "var_syminfo.target_price_median"
        }
      ]
    },
    "var_syminfo.target_price_date": {
      "id": "var_syminfo.target_price_date",
      "name": "syminfo.target_price_date",
      "description": "The starting date of the last price target\n                        prediction for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series int",
      "seeAlso": [
        {
          "name": "syminfo.target_price_average",
          "href": "var_syminfo.target_price_average"
        },
        {
          "name": "syminfo.target_price_estimates",
          "href": "var_syminfo.target_price_estimates"
        },
        {
          "name": "syminfo.target_price_high",
          "href": "var_syminfo.target_price_high"
        },
        {
          "name": "syminfo.target_price_low",
          "href": "var_syminfo.target_price_low"
        },
        {
          "name": "syminfo.target_price_median",
          "href": "var_syminfo.target_price_median"
        }
      ]
    },
    "var_syminfo.target_price_estimates": {
      "id": "var_syminfo.target_price_estimates",
      "name": "syminfo.target_price_estimates",
      "description": "The latest total number of price target\n                        predictions for the current symbol.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series float",
      "seeAlso": [
        {
          "name": "syminfo.target_price_average",
          "href": "var_syminfo.target_price_average"
        },
        {
          "name": "syminfo.target_price_date",
          "href": "var_syminfo.target_price_date"
        },
        {
          "name": "syminfo.target_price_high",
          "href": "var_syminfo.target_price_high"
        },
        {
          "name": "syminfo.target_price_low",
          "href": "var_syminfo.target_price_low"
        },
        {
          "name": "syminfo.target_price_median",
          "href": "var_syminfo.target_price_median"
        }
      ]
    },
    "var_syminfo.target_price_high": {
      "id": "var_syminfo.target_price_high",
      "name": "syminfo.target_price_high",
      "description": "The last highest yearly price target for the\n                        symbol predicted by analysts.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series float",
      "seeAlso": [
        {
          "name": "syminfo.target_price_average",
          "href": "var_syminfo.target_price_average"
        },
        {
          "name": "syminfo.target_price_date",
          "href": "var_syminfo.target_price_date"
        },
        {
          "name": "syminfo.target_price_estimates",
          "href": "var_syminfo.target_price_estimates"
        },
        {
          "name": "syminfo.target_price_low",
          "href": "var_syminfo.target_price_low"
        },
        {
          "name": "syminfo.target_price_median",
          "href": "var_syminfo.target_price_median"
        }
      ]
    },
    "var_syminfo.target_price_low": {
      "id": "var_syminfo.target_price_low",
      "name": "syminfo.target_price_low",
      "description": "The last lowest yearly price target for the symbol\n                        predicted by analysts.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series float",
      "seeAlso": [
        {
          "name": "syminfo.target_price_average",
          "href": "var_syminfo.target_price_average"
        },
        {
          "name": "syminfo.target_price_date",
          "href": "var_syminfo.target_price_date"
        },
        {
          "name": "syminfo.target_price_estimates",
          "href": "var_syminfo.target_price_estimates"
        },
        {
          "name": "syminfo.target_price_high",
          "href": "var_syminfo.target_price_high"
        },
        {
          "name": "syminfo.target_price_median",
          "href": "var_syminfo.target_price_median"
        }
      ]
    },
    "var_syminfo.target_price_median": {
      "id": "var_syminfo.target_price_median",
      "name": "syminfo.target_price_median",
      "description": "The median of the last yearly price targets for\n                        the symbol predicted by analysts.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"syminfo target_price\")if barstate.islastconfirmedhistory    //@variable The time value one year from the date of the last analyst recommendations.    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000    //@variable A line connecting the current `close` to the highest yearly price estimate.    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the lowest yearly price estimate.    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the median yearly price estimate.    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)    //@variable A line connecting the current `close` to the average yearly price estimate.    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)    // Fill the space between targets    linefill.new(lowLine, medianLine, color.new(color.red, 90))    linefill.new(medianLine, highLine, color.new(color.green, 90))    // Create a label displaying the total number of analyst estimates.    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ],
      "type": "series float",
      "seeAlso": [
        {
          "name": "syminfo.target_price_average",
          "href": "var_syminfo.target_price_average"
        },
        {
          "name": "syminfo.target_price_date",
          "href": "var_syminfo.target_price_date"
        },
        {
          "name": "syminfo.target_price_estimates",
          "href": "var_syminfo.target_price_estimates"
        },
        {
          "name": "syminfo.target_price_high",
          "href": "var_syminfo.target_price_high"
        },
        {
          "name": "syminfo.target_price_low",
          "href": "var_syminfo.target_price_low"
        }
      ]
    },
    "var_syminfo.ticker": {
      "id": "var_syminfo.ticker",
      "name": "syminfo.ticker",
      "description": "Symbol name without exchange prefix, e.g.\n                        'MSFT'.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        },
        {
          "name": "syminfo.root",
          "href": "var_syminfo.root"
        }
      ]
    },
    "var_syminfo.tickerid": {
      "id": "var_syminfo.tickerid",
      "name": "syminfo.tickerid",
      "description": "A ticker identifier representing the chart's\n                        symbol or a requested symbol, depending on how the script uses it. The variable's value\n                        represents a requested dataset's ticker ID when used in the expression argument of\n                        a request.*() function call. Otherwise, it represents the chart's ticker ID. The\n                        value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\").\n                        It can also include information about data modifications such as dividend adjustment,\n                        non-standard chart type, currency conversion, etc.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "syminfo.main_tickerid",
          "href": "var_syminfo.main_tickerid"
        },
        {
          "name": "timeframe.main_period",
          "href": "var_timeframe.main_period"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        },
        {
          "name": "syminfo.root",
          "href": "var_syminfo.root"
        }
      ]
    },
    "var_syminfo.timezone": {
      "id": "var_syminfo.timezone",
      "name": "syminfo.timezone",
      "description": "Timezone of the exchange of the chart main series.\n                        Possible values see in timestamp.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "timestamp",
          "href": "fun_timestamp"
        }
      ]
    },
    "var_syminfo.type": {
      "id": "var_syminfo.type",
      "name": "syminfo.type",
      "description": "The type of market the symbol belongs to. The\n                        values are \"stock\", \"fund\", \"dr\", \"right\", \"bond\", \"warrant\", \"structured\", \"index\", \"forex\",\n                        \"futures\", \"spread\", \"economic\", \"fundamental\", \"crypto\", \"spot\", \"swap\", \"option\", \"commodity\".",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        }
      ]
    },
    "var_syminfo.volumetype": {
      "id": "var_syminfo.volumetype",
      "name": "syminfo.volumetype",
      "description": "Volume type of the current symbol. Possible values\n                        are: \"base\" for base currency, \"quote\" for quote currency, \"tick\" for the number of\n                        transactions, and \"n/a\" when there is no volume or its type is not specified.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "syminfo.type",
          "href": "var_syminfo.type"
        }
      ]
    },
    "var_ta.accdist": {
      "id": "var_ta.accdist",
      "name": "ta.accdist",
      "description": "Accumulation/distribution index.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.iii": {
      "id": "var_ta.iii",
      "name": "ta.iii",
      "description": "Intraday Intensity Index.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Intraday Intensity Index\")plot(ta.iii, color=color.yellow)// the same on pinef_iii() =>    (2 * close - high - low) / ((high - low) * volume)plot(f_iii())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.nvi": {
      "id": "var_ta.nvi",
      "name": "ta.nvi",
      "description": "Negative Volume Index.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Negative Volume Index\")plot(ta.nvi, color=color.yellow)// the same on pinef_nvi() =>    float ta_nvi = 1.0    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0) ? 1.0 : ta_nvi[1]    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0        ta_nvi := prevNvi    else        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi    result = ta_nviplot(f_nvi())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.obv": {
      "id": "var_ta.obv",
      "name": "ta.obv",
      "description": "On Balance Volume.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"On Balance Volume\")plot(ta.obv, color=color.yellow)// the same on pinef_obv() =>    ta.cum(math.sign(ta.change(close)) * volume)plot(f_obv())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.pvi": {
      "id": "var_ta.pvi",
      "name": "ta.pvi",
      "description": "Positive Volume Index.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Positive Volume Index\")plot(ta.pvi, color=color.yellow)// the same on pinef_pvi() =>    float ta_pvi = 1.0    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0) ? 1.0 : ta_pvi[1]    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0        ta_pvi := prevPvi    else        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi    result = ta_pviplot(f_pvi())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.pvt": {
      "id": "var_ta.pvt",
      "name": "ta.pvt",
      "description": "Price-Volume Trend.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Price-Volume Trend\")plot(ta.pvt, color=color.yellow)// the same on pinef_pvt() =>    ta.cum((ta.change(close) / close[1]) * volume)plot(f_pvt())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.tr": {
      "id": "var_ta.tr",
      "name": "ta.tr",
      "description": "True range, equivalent to ta.tr(handle_na =\n                        false). It is calculated as math.max(high - low, math.abs(high - close[1]),\n                        math.abs(low - close[1])).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "ta.tr",
          "href": "fun_ta.tr"
        },
        {
          "name": "ta.atr",
          "href": "fun_ta.atr"
        }
      ]
    },
    "var_ta.vwap": {
      "id": "var_ta.vwap",
      "name": "ta.vwap",
      "description": "Volume Weighted Average Price. It uses hlc3 as its source series.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "ta.vwap",
          "href": "fun_ta.vwap"
        }
      ]
    },
    "var_ta.wad": {
      "id": "var_ta.wad",
      "name": "ta.wad",
      "description": "Williams Accumulation/Distribution.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Williams Accumulation/Distribution\")plot(ta.wad, color=color.yellow)// the same on pinef_wad() =>    trueHigh = math.max(high, close[1])    trueLow = math.min(low, close[1])    mom = ta.change(close)    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0    ta.cum(gain)plot(f_wad())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_ta.wvad": {
      "id": "var_ta.wvad",
      "name": "ta.wvad",
      "description": "Williams Variable Accumulation/Distribution.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Williams Variable Accumulation/Distribution\")plot(ta.wvad, color=color.yellow)// the same on pinef_wvad() =>    (close - open) / (high - low) * volumeplot(f_wvad())"
      ],
      "type": "series float",
      "seeAlso": []
    },
    "var_table.all": {
      "id": "var_table.all",
      "name": "table.all",
      "description": "Returns an array filled with all the current\n                        tables drawn by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"table.all\")//delete all tablestable.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)a_allTables = table.allif array.size(a_allTables) > 0    for i = 0 to array.size(a_allTables) - 1        table.delete(array.get(a_allTables, i))"
      ],
      "type": "array<table>",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "line.all",
          "href": "var_line.all"
        },
        {
          "name": "label.all",
          "href": "var_label.all"
        },
        {
          "name": "box.all",
          "href": "var_box.all"
        }
      ]
    },
    "var_time": {
      "id": "var_time",
      "name": "time",
      "description": "Current bar time in UNIX format. It is the number\n                        of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "time_close",
          "href": "var_time_close"
        },
        {
          "name": "timenow",
          "href": "var_timenow"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_time_close": {
      "id": "var_time_close",
      "name": "time_close",
      "description": "The time of the current bar's close in UNIX\n                        format. It represents the number of milliseconds elapsed since 00:00:00 UTC, 1 January 1970. On\n                        tick charts and price-based charts such as Renko, line break, Kagi, point & figure, and\n                        range, this variable's series holds an na timestamp for the latest\n                        realtime bar (because the future closing time is unpredictable), but valid timestamps for all\n                        previous bars.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "timenow",
          "href": "var_timenow"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_time_tradingday": {
      "id": "var_time_tradingday",
      "name": "time_tradingday",
      "description": "The beginning time of the trading day the current\n                        bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC,\n                        1 January 1970).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "time_close",
          "href": "var_time_close"
        }
      ]
    },
    "var_timeframe.isdaily": {
      "id": "var_timeframe.isdaily",
      "name": "timeframe.isdaily",
      "description": "Returns true if current resolution is a daily\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.isdwm": {
      "id": "var_timeframe.isdwm",
      "name": "timeframe.isdwm",
      "description": "Returns true if current resolution is a daily or\n                        weekly or monthly resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.isintraday": {
      "id": "var_timeframe.isintraday",
      "name": "timeframe.isintraday",
      "description": "Returns true if current resolution is an intraday\n                        (minutes or seconds) resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.isminutes": {
      "id": "var_timeframe.isminutes",
      "name": "timeframe.isminutes",
      "description": "Returns true if current resolution is a minutes\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.ismonthly": {
      "id": "var_timeframe.ismonthly",
      "name": "timeframe.ismonthly",
      "description": "Returns true if current resolution is a monthly\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        }
      ]
    },
    "var_timeframe.isseconds": {
      "id": "var_timeframe.isseconds",
      "name": "timeframe.isseconds",
      "description": "Returns true if current resolution is a seconds\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.isticks": {
      "id": "var_timeframe.isticks",
      "name": "timeframe.isticks",
      "description": "Returns true if current resolution is a ticks\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.isweekly",
          "href": "var_timeframe.isweekly"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.isweekly": {
      "id": "var_timeframe.isweekly",
      "name": "timeframe.isweekly",
      "description": "Returns true if current resolution is a weekly\n                        resolution, false otherwise.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple bool",
      "seeAlso": [
        {
          "name": "timeframe.isdwm",
          "href": "var_timeframe.isdwm"
        },
        {
          "name": "timeframe.isintraday",
          "href": "var_timeframe.isintraday"
        },
        {
          "name": "timeframe.isminutes",
          "href": "var_timeframe.isminutes"
        },
        {
          "name": "timeframe.isseconds",
          "href": "var_timeframe.isseconds"
        },
        {
          "name": "timeframe.isticks",
          "href": "var_timeframe.isticks"
        },
        {
          "name": "timeframe.isdaily",
          "href": "var_timeframe.isdaily"
        },
        {
          "name": "timeframe.ismonthly",
          "href": "var_timeframe.ismonthly"
        }
      ]
    },
    "var_timeframe.main_period": {
      "id": "var_timeframe.main_period",
      "name": "timeframe.main_period",
      "description": "A string representation of the script's main\n                        timeframe. If the script is an indicator that specifies a\n                        timeframe value in its declaration statement, this variable holds that value.\n                        Otherwise, its value represents the chart's timeframe. Unlike timeframe.period,\n                        this variable's value does not change when used in the expression argument of a\n                        request.*() function call.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        },
        {
          "name": "syminfo.main_tickerid",
          "href": "var_syminfo.main_tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        }
      ]
    },
    "var_timeframe.multiplier": {
      "id": "var_timeframe.multiplier",
      "name": "timeframe.multiplier",
      "description": "Multiplier of resolution, e.g. '60' - 60, 'D' - 1,\n                        '5D' - 5, '12M' - 12.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple int",
      "seeAlso": [
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.period",
          "href": "var_timeframe.period"
        }
      ]
    },
    "var_timeframe.period": {
      "id": "var_timeframe.period",
      "name": "timeframe.period",
      "description": "A string representation of the script's main\n                        timeframe or a requested timeframe, depending on how the script uses it. The variable's value\n                        represents the timeframe of a requested dataset when used in the expression\n                        argument of a request.*() function call. Otherwise, its value represents the\n                        script's main timeframe (timeframe.main_period),\n                        which equals either the timeframe argument of the indicator\n                        declaration statement or the chart's timeframe.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "simple string",
      "seeAlso": [
        {
          "name": "timeframe.main_period",
          "href": "var_timeframe.main_period"
        },
        {
          "name": "syminfo.main_tickerid",
          "href": "var_syminfo.main_tickerid"
        },
        {
          "name": "syminfo.ticker",
          "href": "var_syminfo.ticker"
        },
        {
          "name": "syminfo.tickerid",
          "href": "var_syminfo.tickerid"
        },
        {
          "name": "timeframe.multiplier",
          "href": "var_timeframe.multiplier"
        }
      ]
    },
    "var_timenow": {
      "id": "var_timenow",
      "name": "timenow",
      "description": "Current time in UNIX format. It is the number of\n                        milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "timestamp",
          "href": "fun_timestamp"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "time_close",
          "href": "var_time_close"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_volume": {
      "id": "var_volume",
      "name": "volume",
      "description": "Current bar volume.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series float",
      "seeAlso": [
        {
          "name": "open",
          "href": "var_open"
        },
        {
          "name": "high",
          "href": "var_high"
        },
        {
          "name": "low",
          "href": "var_low"
        },
        {
          "name": "close",
          "href": "var_close"
        },
        {
          "name": "time",
          "href": "fun_time"
        },
        {
          "name": "hl2",
          "href": "var_hl2"
        },
        {
          "name": "hlc3",
          "href": "var_hlc3"
        },
        {
          "name": "hlcc4",
          "href": "var_hlcc4"
        },
        {
          "name": "ohlc4",
          "href": "var_ohlc4"
        },
        {
          "name": "ask",
          "href": "var_ask"
        },
        {
          "name": "bid",
          "href": "var_bid"
        }
      ]
    },
    "var_weekofyear": {
      "id": "var_weekofyear",
      "name": "weekofyear",
      "description": "Week number of current bar time in exchange\n                        timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "weekofyear",
          "href": "fun_weekofyear"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "year",
          "href": "var_year"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "var_year": {
      "id": "var_year",
      "name": "year",
      "description": "Current bar year in exchange timezone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "series int",
      "seeAlso": [
        {
          "name": "year",
          "href": "fun_year"
        },
        {
          "name": "time",
          "href": "var_time"
        },
        {
          "name": "month",
          "href": "var_month"
        },
        {
          "name": "weekofyear",
          "href": "var_weekofyear"
        },
        {
          "name": "dayofmonth",
          "href": "var_dayofmonth"
        },
        {
          "name": "dayofweek",
          "href": "var_dayofweek"
        },
        {
          "name": "hour",
          "href": "var_hour"
        },
        {
          "name": "minute",
          "href": "var_minute"
        },
        {
          "name": "second",
          "href": "var_second"
        }
      ]
    },
    "const_adjustment.dividends": {
      "id": "const_adjustment.dividends",
      "name": "adjustment.dividends",
      "description": "Constant for dividends adjustment type (dividends\n                        adjustment is applied).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "adjustment.none",
          "href": "const_adjustment.none"
        },
        {
          "name": "adjustment.splits",
          "href": "const_adjustment.splits"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        }
      ]
    },
    "const_adjustment.none": {
      "id": "const_adjustment.none",
      "name": "adjustment.none",
      "description": "Constant for none adjustment type (no adjustment\n                        is applied).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "adjustment.splits",
          "href": "const_adjustment.splits"
        },
        {
          "name": "adjustment.dividends",
          "href": "const_adjustment.dividends"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        }
      ]
    },
    "const_adjustment.splits": {
      "id": "const_adjustment.splits",
      "name": "adjustment.splits",
      "description": "Constant for splits adjustment type (splits\n                        adjustment is applied).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "adjustment.none",
          "href": "const_adjustment.none"
        },
        {
          "name": "adjustment.dividends",
          "href": "const_adjustment.dividends"
        },
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        }
      ]
    },
    "const_alert.freq_all": {
      "id": "const_alert.freq_all",
      "name": "alert.freq_all",
      "description": "A named constant for use with the\n                        freq parameter of the alert() function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "alert",
          "href": "fun_alert"
        }
      ]
    },
    "const_alert.freq_once_per_bar": {
      "id": "const_alert.freq_once_per_bar",
      "name": "alert.freq_once_per_bar",
      "description": "A named constant for use with the\n                        freq parameter of the alert() function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "alert",
          "href": "fun_alert"
        }
      ]
    },
    "const_alert.freq_once_per_bar_close": {
      "id": "const_alert.freq_once_per_bar_close",
      "name": "alert.freq_once_per_bar_close",
      "description": "A named constant for use with the\n                        freq parameter of the alert() function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "alert",
          "href": "fun_alert"
        }
      ]
    },
    "const_backadjustment.inherit": {
      "id": "const_backadjustment.inherit",
      "name": "backadjustment.inherit",
      "description": "A constant to specify the value of the backadjustment\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const backadjustment",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "backadjustment.on",
          "href": "const_backadjustment.on"
        },
        {
          "name": "backadjustment.off",
          "href": "const_backadjustment.off"
        }
      ]
    },
    "const_backadjustment.off": {
      "id": "const_backadjustment.off",
      "name": "backadjustment.off",
      "description": "A constant to specify the value of the backadjustment\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const backadjustment",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "backadjustment.on",
          "href": "const_backadjustment.on"
        },
        {
          "name": "backadjustment.inherit",
          "href": "const_backadjustment.inherit"
        }
      ]
    },
    "const_backadjustment.on": {
      "id": "const_backadjustment.on",
      "name": "backadjustment.on",
      "description": "A constant to specify the value of the backadjustment\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const backadjustment",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "backadjustment.inherit",
          "href": "const_backadjustment.inherit"
        },
        {
          "name": "backadjustment.off",
          "href": "const_backadjustment.off"
        }
      ]
    },
    "const_barmerge.gaps_off": {
      "id": "const_barmerge.gaps_off",
      "name": "barmerge.gaps_off",
      "description": "Merge strategy for requested data. Data is merged\n                        continuously without gaps, all the gaps are filled with the previous nearest existing value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const barmerge_gaps",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "barmerge.gaps_on",
          "href": "const_barmerge.gaps_on"
        }
      ]
    },
    "const_barmerge.gaps_on": {
      "id": "const_barmerge.gaps_on",
      "name": "barmerge.gaps_on",
      "description": "Merge strategy for requested data. Data is merged\n                        with possible gaps (na values).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const barmerge_gaps",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "barmerge.gaps_off",
          "href": "const_barmerge.gaps_off"
        }
      ]
    },
    "const_barmerge.lookahead_off": {
      "id": "const_barmerge.lookahead_off",
      "name": "barmerge.lookahead_off",
      "description": "Merge strategy for the requested data position.\n                        Requested barset is merged with current barset in the order of sorting bars by their close time.\n                        This merge strategy disables effect of getting data from \"future\" on calculation on history.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const barmerge_lookahead",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "barmerge.lookahead_on",
          "href": "const_barmerge.lookahead_on"
        }
      ]
    },
    "const_barmerge.lookahead_on": {
      "id": "const_barmerge.lookahead_on",
      "name": "barmerge.lookahead_on",
      "description": "Merge strategy for the requested data position.\n                        Requested barset is merged with current barset in the order of sorting bars by their opening\n                        time. This merge strategy can lead to undesirable effect of getting data from \"future\" on\n                        calculation on history. This is unacceptable in backtesting strategies, but can be useful in\n                        indicators.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const barmerge_lookahead",
      "seeAlso": [
        {
          "name": "request.security",
          "href": "fun_request.security"
        },
        {
          "name": "barmerge.lookahead_off",
          "href": "const_barmerge.lookahead_off"
        }
      ]
    },
    "const_color.aqua": {
      "id": "const_color.aqua",
      "name": "color.aqua",
      "description": "Is a named constant for #00BCD4 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.black": {
      "id": "const_color.black",
      "name": "color.black",
      "description": "Is a named constant for #363A45 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.blue": {
      "id": "const_color.blue",
      "name": "color.blue",
      "description": "Is a named constant for #2962ff color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.fuchsia": {
      "id": "const_color.fuchsia",
      "name": "color.fuchsia",
      "description": "Is a named constant for #E040FB color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.gray": {
      "id": "const_color.gray",
      "name": "color.gray",
      "description": "Is a named constant for #787B86 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.green": {
      "id": "const_color.green",
      "name": "color.green",
      "description": "Is a named constant for #4CAF50 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.lime": {
      "id": "const_color.lime",
      "name": "color.lime",
      "description": "Is a named constant for #00E676 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.maroon": {
      "id": "const_color.maroon",
      "name": "color.maroon",
      "description": "Is a named constant for #880E4F color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.navy": {
      "id": "const_color.navy",
      "name": "color.navy",
      "description": "Is a named constant for #311B92 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.olive": {
      "id": "const_color.olive",
      "name": "color.olive",
      "description": "Is a named constant for #808000 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.orange": {
      "id": "const_color.orange",
      "name": "color.orange",
      "description": "Is a named constant for #FF9800 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        }
      ]
    },
    "const_color.purple": {
      "id": "const_color.purple",
      "name": "color.purple",
      "description": "Is a named constant for #9C27B0 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.red": {
      "id": "const_color.red",
      "name": "color.red",
      "description": "Is a named constant for #F23645 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.silver": {
      "id": "const_color.silver",
      "name": "color.silver",
      "description": "Is a named constant for #B2B5BE color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.teal": {
      "id": "const_color.teal",
      "name": "color.teal",
      "description": "Is a named constant for #089981 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.white": {
      "id": "const_color.white",
      "name": "color.white",
      "description": "Is a named constant for #FFFFFF color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.yellow",
          "href": "const_color.yellow"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_color.yellow": {
      "id": "const_color.yellow",
      "name": "color.yellow",
      "description": "Is a named constant for #FDD835 color.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const color",
      "seeAlso": [
        {
          "name": "color.black",
          "href": "const_color.black"
        },
        {
          "name": "color.silver",
          "href": "const_color.silver"
        },
        {
          "name": "color.gray",
          "href": "const_color.gray"
        },
        {
          "name": "color.white",
          "href": "const_color.white"
        },
        {
          "name": "color.maroon",
          "href": "const_color.maroon"
        },
        {
          "name": "color.red",
          "href": "const_color.red"
        },
        {
          "name": "color.purple",
          "href": "const_color.purple"
        },
        {
          "name": "color.fuchsia",
          "href": "const_color.fuchsia"
        },
        {
          "name": "color.green",
          "href": "const_color.green"
        },
        {
          "name": "color.lime",
          "href": "const_color.lime"
        },
        {
          "name": "color.olive",
          "href": "const_color.olive"
        },
        {
          "name": "color.navy",
          "href": "const_color.navy"
        },
        {
          "name": "color.blue",
          "href": "const_color.blue"
        },
        {
          "name": "color.teal",
          "href": "const_color.teal"
        },
        {
          "name": "color.aqua",
          "href": "const_color.aqua"
        },
        {
          "name": "color.orange",
          "href": "const_color.orange"
        }
      ]
    },
    "const_currency.AUD": {
      "id": "const_currency.AUD",
      "name": "currency.AUD",
      "description": "Australian dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.BTC": {
      "id": "const_currency.BTC",
      "name": "currency.BTC",
      "description": "Bitcoin.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.CAD": {
      "id": "const_currency.CAD",
      "name": "currency.CAD",
      "description": "Canadian dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.CHF": {
      "id": "const_currency.CHF",
      "name": "currency.CHF",
      "description": "Swiss franc.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.EGP": {
      "id": "const_currency.EGP",
      "name": "currency.EGP",
      "description": "Egyptian pound.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.ETH": {
      "id": "const_currency.ETH",
      "name": "currency.ETH",
      "description": "Ethereum.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.EUR": {
      "id": "const_currency.EUR",
      "name": "currency.EUR",
      "description": "Euro.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.GBP": {
      "id": "const_currency.GBP",
      "name": "currency.GBP",
      "description": "Pound sterling.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.HKD": {
      "id": "const_currency.HKD",
      "name": "currency.HKD",
      "description": "Hong Kong dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.INR": {
      "id": "const_currency.INR",
      "name": "currency.INR",
      "description": "Indian rupee.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.JPY": {
      "id": "const_currency.JPY",
      "name": "currency.JPY",
      "description": "Japanese yen.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.KRW": {
      "id": "const_currency.KRW",
      "name": "currency.KRW",
      "description": "South Korean won.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.MYR": {
      "id": "const_currency.MYR",
      "name": "currency.MYR",
      "description": "Malaysian ringgit.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.NOK": {
      "id": "const_currency.NOK",
      "name": "currency.NOK",
      "description": "Norwegian krone.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.NONE": {
      "id": "const_currency.NONE",
      "name": "currency.NONE",
      "description": "Unspecified currency.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.NZD": {
      "id": "const_currency.NZD",
      "name": "currency.NZD",
      "description": "New Zealand dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.PKR": {
      "id": "const_currency.PKR",
      "name": "currency.PKR",
      "description": "Pakistani rupee.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.PLN": {
      "id": "const_currency.PLN",
      "name": "currency.PLN",
      "description": "Polish zloty.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.RUB": {
      "id": "const_currency.RUB",
      "name": "currency.RUB",
      "description": "Russian ruble.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.SEK": {
      "id": "const_currency.SEK",
      "name": "currency.SEK",
      "description": "Swedish krona.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.SGD": {
      "id": "const_currency.SGD",
      "name": "currency.SGD",
      "description": "Singapore dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.TRY": {
      "id": "const_currency.TRY",
      "name": "currency.TRY",
      "description": "Turkish lira.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.USD": {
      "id": "const_currency.USD",
      "name": "currency.USD",
      "description": "United States dollar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.USDT": {
      "id": "const_currency.USDT",
      "name": "currency.USDT",
      "description": "Tether.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_currency.ZAR": {
      "id": "const_currency.ZAR",
      "name": "currency.ZAR",
      "description": "South African rand.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_dayofweek.friday": {
      "id": "const_dayofweek.friday",
      "name": "dayofweek.friday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_dayofweek.monday": {
      "id": "const_dayofweek.monday",
      "name": "dayofweek.monday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_dayofweek.saturday": {
      "id": "const_dayofweek.saturday",
      "name": "dayofweek.saturday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        }
      ]
    },
    "const_dayofweek.sunday": {
      "id": "const_dayofweek.sunday",
      "name": "dayofweek.sunday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_dayofweek.thursday": {
      "id": "const_dayofweek.thursday",
      "name": "dayofweek.thursday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_dayofweek.tuesday": {
      "id": "const_dayofweek.tuesday",
      "name": "dayofweek.tuesday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.wednesday",
          "href": "const_dayofweek.wednesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_dayofweek.wednesday": {
      "id": "const_dayofweek.wednesday",
      "name": "dayofweek.wednesday",
      "description": "Is a named constant for return value of dayofweek function\n                        and value of dayofweek variable.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const int",
      "seeAlso": [
        {
          "name": "dayofweek.sunday",
          "href": "const_dayofweek.sunday"
        },
        {
          "name": "dayofweek.monday",
          "href": "const_dayofweek.monday"
        },
        {
          "name": "dayofweek.tuesday",
          "href": "const_dayofweek.tuesday"
        },
        {
          "name": "dayofweek.thursday",
          "href": "const_dayofweek.thursday"
        },
        {
          "name": "dayofweek.friday",
          "href": "const_dayofweek.friday"
        },
        {
          "name": "dayofweek.saturday",
          "href": "const_dayofweek.saturday"
        }
      ]
    },
    "const_display.all": {
      "id": "const_display.all",
      "name": "display.all",
      "description": "A named constant for use with the\n                        display parameter of plot*() and input*() functions.\n                        Displays plotted or input values in all possible locations.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_simple_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_display.data_window": {
      "id": "const_display.data_window",
      "name": "display.data_window",
      "description": "A named constant for use with the\n                        display parameter of plot*() and input*() functions.\n                        Displays plotted or input values in the Data Window, a menu accessible from the chart's right\n                        sidebar.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_display.none": {
      "id": "const_display.none",
      "name": "display.none",
      "description": "A named constant for use with the\n                        display parameter of plot*() and input*() functions.\n                        plot*() functions using this will not display their plotted values anywhere.\n                        However, alert template messages and fill functions can still use\n                        the values, and they will appear in exported chart data. input*() functions using\n                        this constant will only display their values within the script's settings.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_simple_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_display.pane": {
      "id": "const_display.pane",
      "name": "display.pane",
      "description": "A named constant for use with the\n                        display parameter of plot*() functions. Displays plotted values in the\n                        chart pane used by the script.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_display.price_scale": {
      "id": "const_display.price_scale",
      "name": "display.price_scale",
      "description": "A named constant for use with the\n                        display parameter of plot*() functions. Displays the plot’s label and\n                        value on the price scale if the chart's settings allow it.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_display.status_line": {
      "id": "const_display.status_line",
      "name": "display.status_line",
      "description": "A named constant for use with the\n                        display parameter of plot*() and input*() functions.\n                        Displays plotted or input values in the status line next to the script's name on the chart if\n                        the chart's settings allow it.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_display",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "plotarrow",
          "href": "fun_plotarrow"
        },
        {
          "name": "plotbar",
          "href": "fun_plotbar"
        },
        {
          "name": "plotcandle",
          "href": "fun_plotcandle"
        }
      ]
    },
    "const_dividends.gross": {
      "id": "const_dividends.gross",
      "name": "dividends.gross",
      "description": "A named constant for the request.dividends\n                        function. Is used to request the dividends return on a stock before deductions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        }
      ]
    },
    "const_dividends.net": {
      "id": "const_dividends.net",
      "name": "dividends.net",
      "description": "A named constant for the request.dividends\n                        function. Is used to request the dividends return on a stock after deductions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.dividends",
          "href": "fun_request.dividends"
        }
      ]
    },
    "const_earnings.actual": {
      "id": "const_earnings.actual",
      "name": "earnings.actual",
      "description": "A named constant for the request.earnings\n                        function. Is used to request the earnings value as it was reported.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "const_earnings.estimate": {
      "id": "const_earnings.estimate",
      "name": "earnings.estimate",
      "description": "A named constant for the request.earnings\n                        function. Is used to request the estimated earnings value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "const_earnings.standardized": {
      "id": "const_earnings.standardized",
      "name": "earnings.standardized",
      "description": "A named constant for the request.earnings\n                        function. Is used to request the standardized earnings value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.earnings",
          "href": "fun_request.earnings"
        }
      ]
    },
    "const_extend.both": {
      "id": "const_extend.both",
      "name": "extend.both",
      "description": "A named constant for line.new\n                        and line.set_extend\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_extend",
          "href": "fun_line.set_extend"
        },
        {
          "name": "extend.none",
          "href": "const_extend.none"
        },
        {
          "name": "extend.left",
          "href": "const_extend.left"
        },
        {
          "name": "extend.right",
          "href": "const_extend.right"
        }
      ]
    },
    "const_extend.left": {
      "id": "const_extend.left",
      "name": "extend.left",
      "description": "A named constant for line.new\n                        and line.set_extend\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_extend",
          "href": "fun_line.set_extend"
        },
        {
          "name": "extend.none",
          "href": "const_extend.none"
        },
        {
          "name": "extend.right",
          "href": "const_extend.right"
        },
        {
          "name": "extend.both",
          "href": "const_extend.both"
        }
      ]
    },
    "const_extend.none": {
      "id": "const_extend.none",
      "name": "extend.none",
      "description": "A named constant for line.new\n                        and line.set_extend\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_extend",
          "href": "fun_line.set_extend"
        },
        {
          "name": "extend.left",
          "href": "const_extend.left"
        },
        {
          "name": "extend.right",
          "href": "const_extend.right"
        },
        {
          "name": "extend.both",
          "href": "const_extend.both"
        }
      ]
    },
    "const_extend.right": {
      "id": "const_extend.right",
      "name": "extend.right",
      "description": "A named constant for line.new\n                        and line.set_extend\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_extend",
          "href": "fun_line.set_extend"
        },
        {
          "name": "extend.none",
          "href": "const_extend.none"
        },
        {
          "name": "extend.left",
          "href": "const_extend.left"
        },
        {
          "name": "extend.both",
          "href": "const_extend.both"
        }
      ]
    },
    "const_false": {
      "id": "const_false",
      "name": "false",
      "description": "Literal representing a bool\n                        value, and result of a comparison operation.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "bool",
          "href": "type_bool"
        }
      ]
    },
    "const_font.family_default": {
      "id": "const_font.family_default",
      "name": "font.family_default",
      "description": "Default text font for box.new,\n                        box.set_text_font_family, label.new, label.set_text_font_family, table.cell\n                        and table.cell_set_text_font_family\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_text_font_family",
          "href": "fun_box.set_text_font_family"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_text_font_family",
          "href": "fun_label.set_text_font_family"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.cell_set_text_font_family",
          "href": "fun_table.cell_set_text_font_family"
        },
        {
          "name": "font.family_monospace",
          "href": "const_font.family_monospace"
        }
      ]
    },
    "const_font.family_monospace": {
      "id": "const_font.family_monospace",
      "name": "font.family_monospace",
      "description": "Monospace text font for box.new,\n                        box.set_text_font_family, label.new, label.set_text_font_family, table.cell\n                        and table.cell_set_text_font_family\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_text_font_family",
          "href": "fun_box.set_text_font_family"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_text_font_family",
          "href": "fun_label.set_text_font_family"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.cell_set_text_font_family",
          "href": "fun_table.cell_set_text_font_family"
        },
        {
          "name": "font.family_default",
          "href": "const_font.family_default"
        }
      ]
    },
    "const_format.inherit": {
      "id": "const_format.inherit",
      "name": "format.inherit",
      "description": "Is a named constant for selecting the formatting\n                        of the script output values from the parent series in the indicator\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "format.price",
          "href": "const_format.price"
        },
        {
          "name": "format.volume",
          "href": "const_format.volume"
        },
        {
          "name": "format.percent",
          "href": "const_format.percent"
        }
      ]
    },
    "const_format.mintick": {
      "id": "const_format.mintick",
      "name": "format.mintick",
      "description": "Is a named constant to use with the str.tostring\n                        function. Passing a number to str.tostring with this\n                        argument rounds the number to the nearest value that can be divided by syminfo.mintick,\n                        without the remainder, with ties rounding up, and returns the string version of said value with\n                        trailing zeros.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "format.inherit",
          "href": "const_format.inherit"
        },
        {
          "name": "format.price",
          "href": "const_format.price"
        },
        {
          "name": "format.volume",
          "href": "const_format.volume"
        }
      ]
    },
    "const_format.percent": {
      "id": "const_format.percent",
      "name": "format.percent",
      "description": "Is a named constant for selecting the formatting\n                        of the script output values as a percentage in the indicator function. It adds a percent sign\n                        after values.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "format.inherit",
          "href": "const_format.inherit"
        },
        {
          "name": "format.price",
          "href": "const_format.price"
        },
        {
          "name": "format.volume",
          "href": "const_format.volume"
        }
      ]
    },
    "const_format.price": {
      "id": "const_format.price",
      "name": "format.price",
      "description": "Is a named constant for selecting the formatting\n                        of the script output values as prices in the indicator\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "format.inherit",
          "href": "const_format.inherit"
        },
        {
          "name": "format.volume",
          "href": "const_format.volume"
        },
        {
          "name": "format.percent",
          "href": "const_format.percent"
        }
      ]
    },
    "const_format.volume": {
      "id": "const_format.volume",
      "name": "format.volume",
      "description": "Is a named constant for selecting the formatting\n                        of the script output values as volume in the indicator\n                        function, e.g. '5183' will be formatted as '5.183K'.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        },
        {
          "name": "format.inherit",
          "href": "const_format.inherit"
        },
        {
          "name": "format.price",
          "href": "const_format.price"
        },
        {
          "name": "format.percent",
          "href": "const_format.percent"
        }
      ]
    },
    "const_hline.style_dashed": {
      "id": "const_hline.style_dashed",
      "name": "hline.style_dashed",
      "description": "Is a named constant for dashed linestyle of hline function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const hline_style",
      "seeAlso": [
        {
          "name": "hline.style_solid",
          "href": "const_hline.style_solid"
        },
        {
          "name": "hline.style_dotted",
          "href": "const_hline.style_dotted"
        }
      ]
    },
    "const_hline.style_dotted": {
      "id": "const_hline.style_dotted",
      "name": "hline.style_dotted",
      "description": "Is a named constant for dotted linestyle of hline function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const hline_style",
      "seeAlso": [
        {
          "name": "hline.style_solid",
          "href": "const_hline.style_solid"
        },
        {
          "name": "hline.style_dashed",
          "href": "const_hline.style_dashed"
        }
      ]
    },
    "const_hline.style_solid": {
      "id": "const_hline.style_solid",
      "name": "hline.style_solid",
      "description": "Is a named constant for solid linestyle of hline function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const hline_style",
      "seeAlso": [
        {
          "name": "hline.style_dotted",
          "href": "const_hline.style_dotted"
        },
        {
          "name": "hline.style_dashed",
          "href": "const_hline.style_dashed"
        }
      ]
    },
    "const_label.style_arrowdown": {
      "id": "const_label.style_arrowdown",
      "name": "label.style_arrowdown",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_arrowup": {
      "id": "const_label.style_arrowup",
      "name": "label.style_arrowup",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_circle": {
      "id": "const_label.style_circle",
      "name": "label.style_circle",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_cross": {
      "id": "const_label.style_cross",
      "name": "label.style_cross",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_diamond": {
      "id": "const_label.style_diamond",
      "name": "label.style_diamond",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        }
      ]
    },
    "const_label.style_flag": {
      "id": "const_label.style_flag",
      "name": "label.style_flag",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_center": {
      "id": "const_label.style_label_center",
      "name": "label.style_label_center",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_down": {
      "id": "const_label.style_label_down",
      "name": "label.style_label_down",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_left": {
      "id": "const_label.style_label_left",
      "name": "label.style_label_left",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_lower_left": {
      "id": "const_label.style_label_lower_left",
      "name": "label.style_label_lower_left",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_lower_right": {
      "id": "const_label.style_label_lower_right",
      "name": "label.style_label_lower_right",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_right": {
      "id": "const_label.style_label_right",
      "name": "label.style_label_right",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_up": {
      "id": "const_label.style_label_up",
      "name": "label.style_label_up",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_upper_left": {
      "id": "const_label.style_label_upper_left",
      "name": "label.style_label_upper_left",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_label_upper_right": {
      "id": "const_label.style_label_upper_right",
      "name": "label.style_label_upper_right",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_none": {
      "id": "const_label.style_none",
      "name": "label.style_none",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_square": {
      "id": "const_label.style_square",
      "name": "label.style_square",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_text_outline": {
      "id": "const_label.style_text_outline",
      "name": "label.style_text_outline",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_triangledown": {
      "id": "const_label.style_triangledown",
      "name": "label.style_triangledown",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_triangleup": {
      "id": "const_label.style_triangleup",
      "name": "label.style_triangleup",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_xcross",
          "href": "const_label.style_xcross"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_lower_left",
          "href": "const_label.style_label_lower_left"
        },
        {
          "name": "label.style_label_lower_right",
          "href": "const_label.style_label_lower_right"
        },
        {
          "name": "label.style_label_upper_left",
          "href": "const_label.style_label_upper_left"
        },
        {
          "name": "label.style_label_upper_right",
          "href": "const_label.style_label_upper_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_label.style_xcross": {
      "id": "const_label.style_xcross",
      "name": "label.style_xcross",
      "description": "Label style for label.new\n                        and label.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "label.set_textalign",
          "href": "fun_label.set_textalign"
        },
        {
          "name": "label.style_none",
          "href": "const_label.style_none"
        },
        {
          "name": "label.style_cross",
          "href": "const_label.style_cross"
        },
        {
          "name": "label.style_triangleup",
          "href": "const_label.style_triangleup"
        },
        {
          "name": "label.style_triangledown",
          "href": "const_label.style_triangledown"
        },
        {
          "name": "label.style_flag",
          "href": "const_label.style_flag"
        },
        {
          "name": "label.style_circle",
          "href": "const_label.style_circle"
        },
        {
          "name": "label.style_arrowup",
          "href": "const_label.style_arrowup"
        },
        {
          "name": "label.style_arrowdown",
          "href": "const_label.style_arrowdown"
        },
        {
          "name": "label.style_label_up",
          "href": "const_label.style_label_up"
        },
        {
          "name": "label.style_label_down",
          "href": "const_label.style_label_down"
        },
        {
          "name": "label.style_label_left",
          "href": "const_label.style_label_left"
        },
        {
          "name": "label.style_label_right",
          "href": "const_label.style_label_right"
        },
        {
          "name": "label.style_label_center",
          "href": "const_label.style_label_center"
        },
        {
          "name": "label.style_square",
          "href": "const_label.style_square"
        },
        {
          "name": "label.style_diamond",
          "href": "const_label.style_diamond"
        }
      ]
    },
    "const_line.style_arrow_both": {
      "id": "const_line.style_arrow_both",
      "name": "line.style_arrow_both",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions. Solid line with arrows on both points.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        }
      ]
    },
    "const_line.style_arrow_left": {
      "id": "const_line.style_arrow_left",
      "name": "line.style_arrow_left",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions. Solid line with arrow on the first point.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        }
      ]
    },
    "const_line.style_arrow_right": {
      "id": "const_line.style_arrow_right",
      "name": "line.style_arrow_right",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions. Solid line with arrow on the second point.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        }
      ]
    },
    "const_line.style_dashed": {
      "id": "const_line.style_dashed",
      "name": "line.style_dashed",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        }
      ]
    },
    "const_line.style_dotted": {
      "id": "const_line.style_dotted",
      "name": "line.style_dotted",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_solid",
          "href": "const_line.style_solid"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        }
      ]
    },
    "const_line.style_solid": {
      "id": "const_line.style_solid",
      "name": "line.style_solid",
      "description": "Line style for line.new\n                        and line.set_style\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "line.set_style",
          "href": "fun_line.set_style"
        },
        {
          "name": "line.style_dotted",
          "href": "const_line.style_dotted"
        },
        {
          "name": "line.style_dashed",
          "href": "const_line.style_dashed"
        },
        {
          "name": "line.style_arrow_left",
          "href": "const_line.style_arrow_left"
        },
        {
          "name": "line.style_arrow_right",
          "href": "const_line.style_arrow_right"
        },
        {
          "name": "line.style_arrow_both",
          "href": "const_line.style_arrow_both"
        }
      ]
    },
    "const_location.abovebar": {
      "id": "const_location.abovebar",
      "name": "location.abovebar",
      "description": "Location value for plotshape,\n                        plotchar functions.\n                        Shape is plotted above main series bars.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "location.belowbar",
          "href": "const_location.belowbar"
        },
        {
          "name": "location.top",
          "href": "const_location.top"
        },
        {
          "name": "location.bottom",
          "href": "const_location.bottom"
        },
        {
          "name": "location.absolute",
          "href": "const_location.absolute"
        }
      ]
    },
    "const_location.absolute": {
      "id": "const_location.absolute",
      "name": "location.absolute",
      "description": "Location value for plotshape,\n                        plotchar functions.\n                        Shape is plotted on chart using indicator value as a price coordinate.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "location.abovebar",
          "href": "const_location.abovebar"
        },
        {
          "name": "location.belowbar",
          "href": "const_location.belowbar"
        },
        {
          "name": "location.top",
          "href": "const_location.top"
        },
        {
          "name": "location.bottom",
          "href": "const_location.bottom"
        }
      ]
    },
    "const_location.belowbar": {
      "id": "const_location.belowbar",
      "name": "location.belowbar",
      "description": "Location value for plotshape,\n                        plotchar functions.\n                        Shape is plotted below main series bars.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "location.abovebar",
          "href": "const_location.abovebar"
        },
        {
          "name": "location.top",
          "href": "const_location.top"
        },
        {
          "name": "location.bottom",
          "href": "const_location.bottom"
        },
        {
          "name": "location.absolute",
          "href": "const_location.absolute"
        }
      ]
    },
    "const_location.bottom": {
      "id": "const_location.bottom",
      "name": "location.bottom",
      "description": "Location value for plotshape,\n                        plotchar functions.\n                        Shape is plotted near the bottom chart border.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "location.abovebar",
          "href": "const_location.abovebar"
        },
        {
          "name": "location.belowbar",
          "href": "const_location.belowbar"
        },
        {
          "name": "location.top",
          "href": "const_location.top"
        },
        {
          "name": "location.absolute",
          "href": "const_location.absolute"
        }
      ]
    },
    "const_location.top": {
      "id": "const_location.top",
      "name": "location.top",
      "description": "Location value for plotshape,\n                        plotchar functions.\n                        Shape is plotted near the top chart border.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "location.abovebar",
          "href": "const_location.abovebar"
        },
        {
          "name": "location.belowbar",
          "href": "const_location.belowbar"
        },
        {
          "name": "location.bottom",
          "href": "const_location.bottom"
        },
        {
          "name": "location.absolute",
          "href": "const_location.absolute"
        }
      ]
    },
    "const_math.e": {
      "id": "const_math.e",
      "name": "math.e",
      "description": "Is a named constant for Euler's\n                        number. It is equal to 2.7182818284590452.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const float",
      "seeAlso": [
        {
          "name": "math.phi",
          "href": "const_math.phi"
        },
        {
          "name": "math.pi",
          "href": "const_math.pi"
        },
        {
          "name": "math.rphi",
          "href": "const_math.rphi"
        }
      ]
    },
    "const_math.phi": {
      "id": "const_math.phi",
      "name": "math.phi",
      "description": "Is a named constant for the golden ratio. It is\n                        equal to 1.6180339887498948.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const float",
      "seeAlso": [
        {
          "name": "math.e",
          "href": "const_math.e"
        },
        {
          "name": "math.pi",
          "href": "const_math.pi"
        },
        {
          "name": "math.rphi",
          "href": "const_math.rphi"
        }
      ]
    },
    "const_math.pi": {
      "id": "const_math.pi",
      "name": "math.pi",
      "description": "Is a named constant for Archimedes' constant. It is\n                        equal to 3.1415926535897932.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const float",
      "seeAlso": [
        {
          "name": "math.e",
          "href": "const_math.e"
        },
        {
          "name": "math.phi",
          "href": "const_math.phi"
        },
        {
          "name": "math.rphi",
          "href": "const_math.rphi"
        }
      ]
    },
    "const_math.rphi": {
      "id": "const_math.rphi",
      "name": "math.rphi",
      "description": "Is a named constant for the golden\n                        ratio conjugate. It is equal to 0.6180339887498948.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const float",
      "seeAlso": [
        {
          "name": "math.e",
          "href": "const_math.e"
        },
        {
          "name": "math.pi",
          "href": "const_math.pi"
        },
        {
          "name": "math.phi",
          "href": "const_math.phi"
        }
      ]
    },
    "const_order.ascending": {
      "id": "const_order.ascending",
      "name": "order.ascending",
      "description": "Determines the sort order of the array from the\n                        smallest to the largest value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const sort_order",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "const_order.descending": {
      "id": "const_order.descending",
      "name": "order.descending",
      "description": "Determines the sort order of the array from the\n                        largest to the smallest value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const sort_order",
      "seeAlso": [
        {
          "name": "array.new_float",
          "href": "fun_array.new_float"
        },
        {
          "name": "array.sort",
          "href": "fun_array.sort"
        }
      ]
    },
    "const_plot.style_area": {
      "id": "const_plot.style_area",
      "name": "plot.style_area",
      "description": "A named constant for the 'Area' style, to be used\n                        as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_areabr": {
      "id": "const_plot.style_areabr",
      "name": "plot.style_areabr",
      "description": "A named constant for the 'Area With Breaks' style,\n                        to be used as an argument for the style parameter in the plot\n                        function. Similar to plot.style_area, except the gaps\n                        in the data are not filled.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_circles": {
      "id": "const_plot.style_circles",
      "name": "plot.style_circles",
      "description": "A named constant for the 'Circles' style, to be\n                        used as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        }
      ]
    },
    "const_plot.style_columns": {
      "id": "const_plot.style_columns",
      "name": "plot.style_columns",
      "description": "A named constant for the 'Columns' style, to be\n                        used as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_cross": {
      "id": "const_plot.style_cross",
      "name": "plot.style_cross",
      "description": "A named constant for the 'Cross' style, to be used\n                        as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_histogram": {
      "id": "const_plot.style_histogram",
      "name": "plot.style_histogram",
      "description": "A named constant for the 'Histogram' style, to be\n                        used as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_line": {
      "id": "const_plot.style_line",
      "name": "plot.style_line",
      "description": "A named constant for the 'Line' style, to be used\n                        as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_linebr": {
      "id": "const_plot.style_linebr",
      "name": "plot.style_linebr",
      "description": "A named constant for the 'Line With Breaks' style,\n                        to be used as an argument for the style parameter in the plot\n                        function. Similar to plot.style_line, except the gaps\n                        in the data are not filled.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_stepline": {
      "id": "const_plot.style_stepline",
      "name": "plot.style_stepline",
      "description": "A named constant for the 'Step Line' style, to be\n                        used as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_stepline_diamond": {
      "id": "const_plot.style_stepline_diamond",
      "name": "plot.style_stepline_diamond",
      "description": "A named constant for the 'Step Line With Diamonds'\n                        style, to be used as an argument for the style parameter in the plot\n                        function. Similar to plot.style_stepline, except\n                        the data changes are also marked with the Diamond shapes.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_steplinebr",
          "href": "const_plot.style_steplinebr"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        }
      ]
    },
    "const_plot.style_steplinebr": {
      "id": "const_plot.style_steplinebr",
      "name": "plot.style_steplinebr",
      "description": "A named constant for the 'Step line with Breaks'\n                        style, to be used as an argument for the style parameter in the plot\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const plot_style",
      "seeAlso": [
        {
          "name": "plot",
          "href": "fun_plot"
        },
        {
          "name": "plot.style_circles",
          "href": "const_plot.style_circles"
        },
        {
          "name": "plot.style_line",
          "href": "const_plot.style_line"
        },
        {
          "name": "plot.style_linebr",
          "href": "const_plot.style_linebr"
        },
        {
          "name": "plot.style_stepline",
          "href": "const_plot.style_stepline"
        },
        {
          "name": "plot.style_stepline_diamond",
          "href": "const_plot.style_stepline_diamond"
        },
        {
          "name": "plot.style_histogram",
          "href": "const_plot.style_histogram"
        },
        {
          "name": "plot.style_cross",
          "href": "const_plot.style_cross"
        },
        {
          "name": "plot.style_area",
          "href": "const_plot.style_area"
        },
        {
          "name": "plot.style_areabr",
          "href": "const_plot.style_areabr"
        },
        {
          "name": "plot.style_columns",
          "href": "const_plot.style_columns"
        }
      ]
    },
    "const_position.bottom_center": {
      "id": "const_position.bottom_center",
      "name": "position.bottom_center",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        }
      ]
    },
    "const_position.bottom_left": {
      "id": "const_position.bottom_left",
      "name": "position.bottom_left",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.bottom_right": {
      "id": "const_position.bottom_right",
      "name": "position.bottom_right",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.middle_center": {
      "id": "const_position.middle_center",
      "name": "position.middle_center",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.middle_left": {
      "id": "const_position.middle_left",
      "name": "position.middle_left",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.middle_right": {
      "id": "const_position.middle_right",
      "name": "position.middle_right",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.top_center": {
      "id": "const_position.top_center",
      "name": "position.top_center",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.top_left": {
      "id": "const_position.top_left",
      "name": "position.top_left",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.top_right",
          "href": "const_position.top_right"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_position.top_right": {
      "id": "const_position.top_right",
      "name": "position.top_right",
      "description": "Table position is used in table.new,\n                        table.cell\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.new",
          "href": "fun_table.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.set_position",
          "href": "fun_table.set_position"
        },
        {
          "name": "position.top_left",
          "href": "const_position.top_left"
        },
        {
          "name": "position.top_center",
          "href": "const_position.top_center"
        },
        {
          "name": "position.middle_left",
          "href": "const_position.middle_left"
        },
        {
          "name": "position.middle_center",
          "href": "const_position.middle_center"
        },
        {
          "name": "position.middle_right",
          "href": "const_position.middle_right"
        },
        {
          "name": "position.bottom_left",
          "href": "const_position.bottom_left"
        },
        {
          "name": "position.bottom_center",
          "href": "const_position.bottom_center"
        }
      ]
    },
    "const_scale.left": {
      "id": "const_scale.left",
      "name": "scale.left",
      "description": "Scale value for indicator\n                        function. Indicator is added to the left price scale.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const scale_type",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        }
      ]
    },
    "const_scale.none": {
      "id": "const_scale.none",
      "name": "scale.none",
      "description": "Scale value for indicator\n                        function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const scale_type",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        }
      ]
    },
    "const_scale.right": {
      "id": "const_scale.right",
      "name": "scale.right",
      "description": "Scale value for indicator\n                        function. Indicator is added to the right price scale.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const scale_type",
      "seeAlso": [
        {
          "name": "indicator",
          "href": "fun_indicator"
        }
      ]
    },
    "const_session.extended": {
      "id": "const_session.extended",
      "name": "session.extended",
      "description": "Constant for extended session type (with extended\n                        hours data).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "session.regular",
          "href": "const_session.regular"
        },
        {
          "name": "syminfo.session",
          "href": "var_syminfo.session"
        }
      ]
    },
    "const_session.regular": {
      "id": "const_session.regular",
      "name": "session.regular",
      "description": "Constant for regular session type (no extended\n                        hours data).",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "session.extended",
          "href": "const_session.extended"
        },
        {
          "name": "syminfo.session",
          "href": "var_syminfo.session"
        }
      ]
    },
    "const_settlement_as_close.inherit": {
      "id": "const_settlement_as_close.inherit",
      "name": "settlement_as_close.inherit",
      "description": "A constant to specify the value of the settlement_as_close\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const settlement",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "settlement_as_close.on",
          "href": "const_settlement_as_close.on"
        },
        {
          "name": "settlement_as_close.off",
          "href": "const_settlement_as_close.off"
        }
      ]
    },
    "const_settlement_as_close.off": {
      "id": "const_settlement_as_close.off",
      "name": "settlement_as_close.off",
      "description": "A constant to specify the value of the settlement_as_close\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const settlement",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "settlement_as_close.on",
          "href": "const_settlement_as_close.on"
        },
        {
          "name": "settlement_as_close.inherit",
          "href": "const_settlement_as_close.inherit"
        }
      ]
    },
    "const_settlement_as_close.on": {
      "id": "const_settlement_as_close.on",
      "name": "settlement_as_close.on",
      "description": "A constant to specify the value of the settlement_as_close\n                        parameter in ticker.new\n                        and ticker.modify\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const settlement",
      "seeAlso": [
        {
          "name": "ticker.new",
          "href": "fun_ticker.new"
        },
        {
          "name": "ticker.modify",
          "href": "fun_ticker.modify"
        },
        {
          "name": "settlement_as_close.inherit",
          "href": "const_settlement_as_close.inherit"
        },
        {
          "name": "settlement_as_close.off",
          "href": "const_settlement_as_close.off"
        }
      ]
    },
    "const_shape.arrowdown": {
      "id": "const_shape.arrowdown",
      "name": "shape.arrowdown",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.arrowup": {
      "id": "const_shape.arrowup",
      "name": "shape.arrowup",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.circle": {
      "id": "const_shape.circle",
      "name": "shape.circle",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.cross": {
      "id": "const_shape.cross",
      "name": "shape.cross",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.diamond": {
      "id": "const_shape.diamond",
      "name": "shape.diamond",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.flag": {
      "id": "const_shape.flag",
      "name": "shape.flag",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.labeldown": {
      "id": "const_shape.labeldown",
      "name": "shape.labeldown",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.labelup": {
      "id": "const_shape.labelup",
      "name": "shape.labelup",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.square": {
      "id": "const_shape.square",
      "name": "shape.square",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.triangledown": {
      "id": "const_shape.triangledown",
      "name": "shape.triangledown",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.triangleup": {
      "id": "const_shape.triangleup",
      "name": "shape.triangleup",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_shape.xcross": {
      "id": "const_shape.xcross",
      "name": "shape.xcross",
      "description": "Shape style for plotshape\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        }
      ]
    },
    "const_size.auto": {
      "id": "const_size.auto",
      "name": "size.auto",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape automatically adapts to the size of the bars.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        }
      ]
    },
    "const_size.huge": {
      "id": "const_size.huge",
      "name": "size.huge",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape constantly huge.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        }
      ]
    },
    "const_size.large": {
      "id": "const_size.large",
      "name": "size.large",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape constantly large.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        }
      ]
    },
    "const_size.normal": {
      "id": "const_size.normal",
      "name": "size.normal",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape constantly normal.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        }
      ]
    },
    "const_size.small": {
      "id": "const_size.small",
      "name": "size.small",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape constantly small.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.tiny",
          "href": "const_size.tiny"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        }
      ]
    },
    "const_size.tiny": {
      "id": "const_size.tiny",
      "name": "size.tiny",
      "description": "Size value for plotshape,\n                        plotchar functions.\n                        The size of the shape constantly tiny.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "plotshape",
          "href": "fun_plotshape"
        },
        {
          "name": "plotchar",
          "href": "fun_plotchar"
        },
        {
          "name": "label.set_size",
          "href": "fun_label.set_size"
        },
        {
          "name": "size.auto",
          "href": "const_size.auto"
        },
        {
          "name": "size.small",
          "href": "const_size.small"
        },
        {
          "name": "size.normal",
          "href": "const_size.normal"
        },
        {
          "name": "size.large",
          "href": "const_size.large"
        },
        {
          "name": "size.huge",
          "href": "const_size.huge"
        }
      ]
    },
    "const_splits.denominator": {
      "id": "const_splits.denominator",
      "name": "splits.denominator",
      "description": "A named constant for the request.splits\n                        function. Is used to request the denominator (the number below the line in a fraction) of a\n                        splits.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        }
      ]
    },
    "const_splits.numerator": {
      "id": "const_splits.numerator",
      "name": "splits.numerator",
      "description": "A named constant for the request.splits\n                        function. Is used to request the numerator (the number above the line in a fraction) of a\n                        splits.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "request.splits",
          "href": "fun_request.splits"
        }
      ]
    },
    "const_strategy.cash": {
      "id": "const_strategy.cash",
      "name": "strategy.cash",
      "description": "This is one of the arguments that can be supplied\n                        to the default_qty_type parameter in the strategy\n                        declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry\n                        or strategy.order\n                        function calls. It specifies that an amount of cash in the\n                        strategy.account_currency will be used to enter trades.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)if bar_index == 0    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.    strategy.entry(\"EN\", strategy.long)if bar_index == 2    strategy.close(\"EN\")"
      ],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.commission.cash_per_contract": {
      "id": "const_strategy.commission.cash_per_contract",
      "name": "strategy.commission.cash_per_contract",
      "description": "Commission type for an order. Money displayed in\n                        the account currency per contract.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.commission.cash_per_order": {
      "id": "const_strategy.commission.cash_per_order",
      "name": "strategy.commission.cash_per_order",
      "description": "Commission type for an order. Money displayed in\n                        the account currency per order.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.commission.percent": {
      "id": "const_strategy.commission.percent",
      "name": "strategy.commission.percent",
      "description": "Commission type for an order. A percentage of the\n                        cash volume of order.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.direction.all": {
      "id": "const_strategy.direction.all",
      "name": "strategy.direction.all",
      "description": "It allows strategy to open both long and short\n                        positions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.risk.allow_entry_in",
          "href": "fun_strategy.risk.allow_entry_in"
        }
      ]
    },
    "const_strategy.direction.long": {
      "id": "const_strategy.direction.long",
      "name": "strategy.direction.long",
      "description": "It allows strategy to open only long positions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.risk.allow_entry_in",
          "href": "fun_strategy.risk.allow_entry_in"
        }
      ]
    },
    "const_strategy.direction.short": {
      "id": "const_strategy.direction.short",
      "name": "strategy.direction.short",
      "description": "It allows strategy to open only short positions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.risk.allow_entry_in",
          "href": "fun_strategy.risk.allow_entry_in"
        }
      ]
    },
    "const_strategy.fixed": {
      "id": "const_strategy.fixed",
      "name": "strategy.fixed",
      "description": "This is one of the arguments that can be supplied\n                        to the default_qty_type parameter in the strategy\n                        declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry\n                        or strategy.order\n                        function calls. It specifies that a number of contracts/shares/lots will be used to enter\n                        trades.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)if bar_index == 0    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.    // qty = 50    strategy.entry(\"EN\", strategy.long)if bar_index == 2    strategy.close(\"EN\")"
      ],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.long": {
      "id": "const_strategy.long",
      "name": "strategy.long",
      "description": "A named constant for use with the\n                        direction parameter of the strategy.entry and\n                        strategy.order commands. It specifies that the command\n                        creates a buy order.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const strategy_direction",
      "seeAlso": [
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.order",
          "href": "fun_strategy.order"
        }
      ]
    },
    "const_strategy.oca.cancel": {
      "id": "const_strategy.oca.cancel",
      "name": "strategy.oca.cancel",
      "description": "A named constant for use with the\n                        oca_type parameter of the strategy.entry and\n                        strategy.order commands. It specifies that the strategy\n                        cancels the unfilled order when another order with the same oca_name and oca_type\n                        executes.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.order",
          "href": "fun_strategy.order"
        }
      ]
    },
    "const_strategy.oca.none": {
      "id": "const_strategy.oca.none",
      "name": "strategy.oca.none",
      "description": "A named constant for use with the\n                        oca_type parameter of the strategy.entry and\n                        strategy.order commands. It specifies that the order\n                        executes independently of all other orders, including those with the same oca_name.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.order",
          "href": "fun_strategy.order"
        }
      ]
    },
    "const_strategy.oca.reduce": {
      "id": "const_strategy.oca.reduce",
      "name": "strategy.oca.reduce",
      "description": "A named constant for use with the\n                        oca_type parameter of the strategy.entry and\n                        strategy.order commands. It specifies that when another\n                        order with the same oca_name and oca_type executes, the strategy\n                        reduces the unfilled order by that order's size. If the unfilled order's size reaches 0 after\n                        reduction, it is the same as canceling the order entirely.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.order",
          "href": "fun_strategy.order"
        }
      ]
    },
    "const_strategy.percent_of_equity": {
      "id": "const_strategy.percent_of_equity",
      "name": "strategy.percent_of_equity",
      "description": "This is one of the arguments that can be supplied\n                        to the default_qty_type parameter in the strategy\n                        declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry\n                        or strategy.order\n                        function calls. It specifies that a percentage (0-100) of equity will be used to enter trades.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)// As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.if bar_index == 0    strategy.entry(\"EN\", strategy.long)if bar_index == 2    strategy.close(\"EN\")plot(strategy.equity) // The ‘qty’ parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).if bar_index == 4    strategy.entry(\"EN\", strategy.long, qty = 10)if bar_index == 6    strategy.close(\"EN\")"
      ],
      "type": "const string",
      "seeAlso": [
        {
          "name": "strategy",
          "href": "fun_strategy"
        }
      ]
    },
    "const_strategy.short": {
      "id": "const_strategy.short",
      "name": "strategy.short",
      "description": "A named constant for use with the\n                        direction parameter of the strategy.entry and\n                        strategy.order commands. It specifies that the command\n                        creates a sell order.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const strategy_direction",
      "seeAlso": [
        {
          "name": "strategy.entry",
          "href": "fun_strategy.entry"
        },
        {
          "name": "strategy.exit",
          "href": "fun_strategy.exit"
        },
        {
          "name": "strategy.order",
          "href": "fun_strategy.order"
        }
      ]
    },
    "const_text.align_bottom": {
      "id": "const_text.align_bottom",
      "name": "text.align_bottom",
      "description": "Vertical text alignment for box.new,\n                        box.set_text_valign,\n                        table.cell and table.cell_set_text_valign functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "text.align_center",
          "href": "const_text.align_center"
        },
        {
          "name": "text.align_left",
          "href": "const_text.align_left"
        },
        {
          "name": "text.align_right",
          "href": "const_text.align_right"
        }
      ]
    },
    "const_text.align_center": {
      "id": "const_text.align_center",
      "name": "text.align_center",
      "description": "Text alignment for box.new,\n                        box.set_text_halign,\n                        box.set_text_valign,\n                        label.new and label.set_textalign functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "text.align_left",
          "href": "const_text.align_left"
        },
        {
          "name": "text.align_right",
          "href": "const_text.align_right"
        }
      ]
    },
    "const_text.align_left": {
      "id": "const_text.align_left",
      "name": "text.align_left",
      "description": "Horizontal text alignment for box.new, box.set_text_halign,\n                        label.new and label.set_textalign functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "text.align_center",
          "href": "const_text.align_center"
        },
        {
          "name": "text.align_right",
          "href": "const_text.align_right"
        }
      ]
    },
    "const_text.align_right": {
      "id": "const_text.align_right",
      "name": "text.align_right",
      "description": "Horizontal text alignment for box.new, box.set_text_halign,\n                        label.new and label.set_textalign functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_style",
          "href": "fun_label.set_style"
        },
        {
          "name": "text.align_center",
          "href": "const_text.align_center"
        },
        {
          "name": "text.align_left",
          "href": "const_text.align_left"
        }
      ]
    },
    "const_text.align_top": {
      "id": "const_text.align_top",
      "name": "text.align_top",
      "description": "Vertical text alignment for box.new,\n                        box.set_text_valign,\n                        table.cell and table.cell_set_text_valign functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        },
        {
          "name": "table.cell_set_text_valign",
          "href": "fun_table.cell_set_text_valign"
        },
        {
          "name": "text.align_center",
          "href": "const_text.align_center"
        },
        {
          "name": "text.align_left",
          "href": "const_text.align_left"
        },
        {
          "name": "text.align_right",
          "href": "const_text.align_right"
        }
      ]
    },
    "const_text.format_bold": {
      "id": "const_text.format_bold",
      "name": "text.format_bold",
      "description": "A named constant for use with the text_formatting\n                        parameter of the label.new(), box.new(), table.cell(),\n                        and *set_text_formatting() functions. Makes the text bold.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const text_format",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        }
      ]
    },
    "const_text.format_italic": {
      "id": "const_text.format_italic",
      "name": "text.format_italic",
      "description": "A named constant for use with the text_formatting\n                        parameter of the label.new(), box.new(), table.cell(),\n                        and *set_text_formatting() functions. Italicizes the text.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const text_format",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        }
      ]
    },
    "const_text.format_none": {
      "id": "const_text.format_none",
      "name": "text.format_none",
      "description": "A named constant for use with the text_formatting\n                        parameter of the label.new(), box.new(), table.cell(),\n                        and *set_text_formatting() functions. Signifies no special text formatting.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const text_format",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "table.cell",
          "href": "fun_table.cell"
        }
      ]
    },
    "const_text.wrap_auto": {
      "id": "const_text.wrap_auto",
      "name": "text.wrap_auto",
      "description": "Automatic wrapping mode for box.new\n                        and box.set_text_wrap\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_wrap",
          "href": "fun_box.set_text_wrap"
        }
      ]
    },
    "const_text.wrap_none": {
      "id": "const_text.wrap_none",
      "name": "text.wrap_none",
      "description": "Disabled wrapping mode for box.new\n                        and box.set_text_wrap\n                        functions.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "box.set_text",
          "href": "fun_box.set_text"
        },
        {
          "name": "box.set_text_wrap",
          "href": "fun_box.set_text_wrap"
        }
      ]
    },
    "const_true": {
      "id": "const_true",
      "name": "true",
      "description": "Literal representing one of the values a bool variable can hold, or\n                        an expression can evaluate to when it uses comparison or logical operators.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "bool",
          "href": "type_bool"
        }
      ]
    },
    "const_xloc.bar_index": {
      "id": "const_xloc.bar_index",
      "name": "xloc.bar_index",
      "description": "A constant that specifies how functions that\n                        create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_index,\n                        the drawing object treats each x-coordinate as a bar_index value.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "xloc.bar_time",
          "href": "const_xloc.bar_time"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "polyline.new",
          "href": "fun_polyline.new"
        },
        {
          "name": "line.set_xloc",
          "href": "fun_line.set_xloc"
        },
        {
          "name": "label.set_xloc",
          "href": "fun_label.set_xloc"
        }
      ]
    },
    "const_xloc.bar_time": {
      "id": "const_xloc.bar_time",
      "name": "xloc.bar_time",
      "description": "A constant that specifies how functions that\n                        create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_time,\n                        the drawing object treats each x-coordinate as a UNIX timestamp, expressed in milliseconds.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "xloc.bar_index",
          "href": "const_xloc.bar_index"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        },
        {
          "name": "polyline.new",
          "href": "fun_polyline.new"
        },
        {
          "name": "line.set_xloc",
          "href": "fun_line.set_xloc"
        },
        {
          "name": "label.set_xloc",
          "href": "fun_label.set_xloc"
        },
        {
          "name": "xloc.bar_index",
          "href": "const_xloc.bar_index"
        }
      ]
    },
    "const_yloc.abovebar": {
      "id": "const_yloc.abovebar",
      "name": "yloc.abovebar",
      "description": "A named constant that specifies the algorithm of\n                        interpretation of y-value in function label.new.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_yloc",
          "href": "fun_label.set_yloc"
        },
        {
          "name": "yloc.price",
          "href": "const_yloc.price"
        },
        {
          "name": "yloc.belowbar",
          "href": "const_yloc.belowbar"
        }
      ]
    },
    "const_yloc.belowbar": {
      "id": "const_yloc.belowbar",
      "name": "yloc.belowbar",
      "description": "A named constant that specifies the algorithm of\n                        interpretation of y-value in function label.new.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_yloc",
          "href": "fun_label.set_yloc"
        },
        {
          "name": "yloc.price",
          "href": "const_yloc.price"
        },
        {
          "name": "yloc.abovebar",
          "href": "const_yloc.abovebar"
        }
      ]
    },
    "const_yloc.price": {
      "id": "const_yloc.price",
      "name": "yloc.price",
      "description": "A named constant that specifies the algorithm of\n                        interpretation of y-value in function label.new.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "const string",
      "seeAlso": [
        {
          "name": "label.new",
          "href": "fun_label.new"
        },
        {
          "name": "label.set_yloc",
          "href": "fun_label.set_yloc"
        },
        {
          "name": "yloc.abovebar",
          "href": "const_yloc.abovebar"
        },
        {
          "name": "yloc.belowbar",
          "href": "const_yloc.belowbar"
        }
      ]
    },
    "kw_and": {
      "id": "kw_and",
      "name": "and",
      "description": "Logical AND. Applicable to boolean expressions.",
      "syntax": "expr1 and expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "kw_enum": {
      "id": "kw_enum",
      "name": "enum",
      "description": "This keyword allows the creation of an\n                        enumeration, enum for short. Enums are unique constructs that hold groups of predefined\n                        constants.",
      "syntax": "[export ]enum <enumName>\n<field_1> [= <title_1>]\n<field_2> [= <title_2>]\n...\n<field_N> [= <title_N>]",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Session highlight\", overlay = true)//@enum       Contains fields with popular timezones as titles.//@field exch Has an empty string as the title to represent the chart timezone.enum tz    utc  = \"UTC\"    exch = \"\"    ny   = \"America/New_York\"    chi  = \"America/Chicago\"    lon  = \"Europe/London\"    tok  = \"Asia/Tokyo\"//@variable The session string.selectedSession = input.session(\"1200-1500\", \"Session\")//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.selectedTimezone = input.enum(tz.utc, \"Session Timezone\")//@variable Is `true` if the current bar's time is in the specified session.bool inSession = falseif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))    inSession := true// Highlight the background when `inSession` is `true`.bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")",
        "//@version=6indicator(\"Map with enum keys\")//@enum        Contains fields with titles representing ticker IDs.//@field aapl  Has an Apple ticker ID as its title.//@field tsla  Has a Tesla ticker ID as its title.//@field amzn  Has an Amazon ticker ID as its title.enum symbols    aapl = \"NASDAQ:AAPL\"    tsla = \"NASDAQ:TSLA\"    amzn = \"NASDAQ:AMZN\"//@variable A map that accepts fields from the `symbols` enum as keys and \"float\" values.map<symbols, float> data = map.new<symbols, float>()// Put key-value pairs into the `data` map.data.put(symbols.aapl, request.security(str.tostring(symbols.aapl), timeframe.period, close))data.put(symbols.tsla, request.security(str.tostring(symbols.tsla), timeframe.period, close))data.put(symbols.amzn, request.security(str.tostring(symbols.amzn), timeframe.period, close))// Plot the value from the `data` map accessed by the `symbols.aapl` key.plot(data.get(symbols.aapl))"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_export": {
      "id": "kw_export",
      "name": "export",
      "description": "Used in libraries to prefix the declaration of\n                        functions or user-defined type definitions that will be available from other scripts importing\n                        the library.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6//@description Library of debugging functions.library(\"Debugging_library\", overlay = true)//@function Displays a string as a table cell for debugging purposes.//@param txt String to display.//@returns Void.export print(string txt) =>     var table t = table.new(position.middle_right, 1, 1)    table.cell(t, 0, 0, txt, bgcolor = color.yellow)// Using the function from inside the library to show an example on the published chart.// This has no impact on scripts using the library.print(\"Library Test\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "library",
          "href": "fun_library"
        },
        {
          "name": "import",
          "href": "kw_import"
        },
        {
          "name": "simple",
          "href": "type_simple"
        },
        {
          "name": "series",
          "href": "type_series"
        },
        {
          "name": "type",
          "href": "kw_type"
        }
      ]
    },
    "kw_for": {
      "id": "kw_for",
      "name": "for",
      "description": "Creates a count-controlled loop, which uses a\n                        counter variable to manage the iterative executions of its local code block. The loop continues\n                        new iterations until the counter reaches a specified final value.",
      "syntax": "[variables =|:=] for counter = from_num to to_num [by step_num]\n    statements | continue | break\n    return_expression",
      "arguments": [
        {
          "name": "variables",
          "type": "return_expression\n                        type",
          "description": "Optional. A declared variable or tuple to hold the values or references from the"
        },
        {
          "name": "counter",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "from_num",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "to_num",
          "type": "series int/float",
          "description": "The"
        },
        {
          "name": "step_num",
          "type": "series int/float",
          "description": "Optional. A positive value specifying the amount by which the counter value"
        },
        {
          "name": "return_expression",
          "type": "any type",
          "description": "The"
        }
      ],
      "examples": [
        "//@version=6indicator(\"Basic `for` loop\")//@function Calculates the number of bars in the last `length` bars that have their `close` above the current `close`.//@param length The number of bars used in the calculation.greaterCloseCount(length) =>    int result = 0    for i = 1 to length        if close[i] > close            result += 1    resultplot(greaterCloseCount(14))",
        "//@version=6indicator(\"`for` loop with a step\")a = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)sum = 0.0for i = 0 to 9 by 5    // Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.    sum += array.get(a, i)plot(sum)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "for...in",
          "href": "kw_for...in"
        },
        {
          "name": "while",
          "href": "kw_while"
        }
      ]
    },
    "kw_for...in": {
      "id": "kw_for...in",
      "name": "for...in",
      "description": "The for...in structure allows the\n                        repeated execution of a number of statements for each element in an array. It can be used with\n                        either one argument: array_element, or with two: [index,\n                            array_element]. The second form doesn't affect the functionality of the loop. It\n                        tracks the current iteration's index in the tuple's first variable.",
      "syntax": "[var_declaration =] for array_element in array_id\n    statements | continue | break\n    return_expression\n\n[var_declaration =] for [index, array_element] in array_id\n    statements | continue | break\n    return_expression",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"for...in\")// Here we determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' valuesfloat[] ohlcValues = array.from(open, high, low, close)qtyGreaterThan(value, array) =>    int result = 0    for currentElement in array        if currentElement > value            result += 1        resultplot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))",
        "//@version=6indicator(\"for...in\")var valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)var isPos = array.new_bool(10, false)for [index, value] in valuesArray    if value > 0        array.set(isPos, index, true)if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(isPos))",
        "//@version=6indicator(\"`for ... in` matrix Example\")// Create a 2x3 matrix with values `4`.matrix1 = matrix.new<int>(2, 3, 4)sum = 0.0// Loop through every row of the matrix.for rowArray in matrix1    // Sum values of the every row     sum += array.sum(rowArray)plot(sum)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "for",
          "href": "kw_for"
        },
        {
          "name": "while",
          "href": "kw_while"
        },
        {
          "name": "array.sum",
          "href": "fun_array.sum"
        },
        {
          "name": "array.min",
          "href": "fun_array.min"
        },
        {
          "name": "array.max",
          "href": "fun_array.max"
        }
      ]
    },
    "kw_if": {
      "id": "kw_if",
      "name": "if",
      "description": "If statement defines what block of statements must\n                        be executed when conditions of the expression are satisfied.",
      "syntax": "var_declarationX = if condition\n    var_decl_then0\n    var_decl_then1\n    …\n    var_decl_thenN\nelse if [optional block]\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\nelse\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\n    return_expression_else",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"if\")// This code compilesx = if close > open    closeelse    open// This code doesn’t compile// y = if close > open//     close// else//     \"open\"plot(x)",
        "//@version=6indicator(\"if\")x = if close > open    close// If current close > current open, then x = close.// Otherwise the x = na.plot(x)",
        "//@version=6indicator(\"if\")x = if open > close    5else if high > low    closeelse    openplot(x)",
        "//@version=6strategy(\"if\")if (ta.crossover(high, low))    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")else    strategy.cancel(id=\"BBandLE\")",
        "//@version=6indicator(\"if\")float x = naif close > open    if close > close[1]        x := close    else        x := close[1]else    x := openplot(x)"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_import": {
      "id": "kw_import",
      "name": "import",
      "description": "Used to load an external library\n                        into a script and bind its functions to a namespace. The importing script can be an indicator, a\n                        strategy, or another library. A library must be published (privately or publicly) before it can\n                        be imported.",
      "syntax": "import {username}/{libraryName}/{libraryVersion} as {alias}",
      "arguments": [
        {
          "name": "username",
          "type": "literal string",
          "description": "User"
        },
        {
          "name": "libraryName",
          "type": "literal string",
          "description": "Name"
        },
        {
          "name": "libraryVersion",
          "type": "literal int",
          "description": "Version"
        },
        {
          "name": "alias",
          "type": "literal string",
          "description": "A"
        }
      ],
      "examples": [
        "//@version=6indicator(\"num_methods import\")// Import the first version of the username’s \"num_methods\" library and assign it to the \"m\" namespace\",import username/num_methods/1 as m// Call the “sinh()” function from the imported libraryy = m.sinh(3.14)// Plot value returned by the \"sinh()\" function\",plot(y)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "library",
          "href": "fun_library"
        },
        {
          "name": "export",
          "href": "kw_export"
        }
      ]
    },
    "kw_method": {
      "id": "kw_method",
      "name": "method",
      "description": "This keyword is used to prefix a function\n                        declaration, indicating it can then be invoked using dot notation by appending its name to a\n                        variable of the type of its first parameter and omitting that first parameter. Alternatively,\n                        functions declared as methods can also be invoked like normal user-defined functions. In that\n                        case, an argument must be supplied for its first parameter.",
      "syntax": "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n    <functionBlock>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"\")var prices = array.new<float>()//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.method maintainArray(array<float> id, maxSize, value) =>    id.push(value)    if id.size() > maxSize        id.shift()prices.maintainArray(50, close)// The method can also be called like a function, without using dot notation.// In this case an argument must be supplied for its first parameter.// maintainArray(prices, 50, close)// This calls the `array.avg()` built-in using dot notation with the `prices` array.// It is possible because built-in functions belonging to some namespaces that are a special Pine type// can be invoked with method notation when the function's first parameter is an ID of that type.// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.plot(prices.avg())"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_not": {
      "id": "kw_not",
      "name": "not",
      "description": "Logical negation (NOT). Applicable to boolean\n                        expressions.",
      "syntax": "not expr1",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "kw_or": {
      "id": "kw_or",
      "name": "or",
      "description": "Logical OR. Applicable to boolean expressions.",
      "syntax": "expr1 or expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "kw_switch": {
      "id": "kw_switch",
      "name": "switch",
      "description": "The switch operator transfers control to one of\n                        the several statements, depending on the values of a condition and expressions.",
      "syntax": "[variable_declaration = ] switch expression\n    value1 => local_block\n    value2 => local_block\n    …\n    => default_local_block\n\n[variable_declaration = ] switch\n    condition1 => local_block\n    condition2 => local_block\n    …\n    => default_local_block",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Switch using an expression\")string i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])float ma = switch i_maType    \"EMA\" => ta.ema(close, 10)    \"SMA\" => ta.sma(close, 10)    \"RMA\" => ta.rma(close, 10)    // Default used when the three first cases do not match.    => ta.wma(close, 10)plot(ma)",
        "//@version=6strategy(\"Switch without an expression\", overlay = true)bool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))switch    longCondition  => strategy.entry(\"Long ID\", strategy.long)    shortCondition => strategy.entry(\"Short ID\", strategy.short)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "if",
          "href": "kw_if"
        },
        {
          "name": "?:",
          "href": "op_?:"
        }
      ]
    },
    "kw_type": {
      "id": "kw_type",
      "name": "type",
      "description": "This keyword allows the declaration of\n                        user-defined types (UDT) from which scripts can instantiate objects. UDTs are composite types\n                        that contain an arbitrary number of fields of any built-in or user-defined type, including the\n                        defined UDT itself. The syntax to define a UDT is:",
      "syntax": "[export ]type <UDT_identifier>\n    [varip ]<field_type> <field_name> [= <value>]\n    …",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Multi Time Period Chart\", overlay = true)timeframeInput = input.timeframe(\"1D\")type bar    float o = open    float h = high    float l = low    float c = close    int   t = timedrawBox(bar b, right) =>    bar s = bar.new()    color boxColor = b.c >= b.o ? color.green : color.red    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))updateBox(box boxId, bar b) =>    color boxColor = b.c >= b.o ? color.green : color.red    box.set_border_color(boxId, boxColor)    box.set_bgcolor(boxId, color.new(boxColor, 90))    box.set_top(boxId, b.h)    box.set_bottom(boxId, b.l)    box.set_right(boxId, time)secBar = request.security(syminfo.tickerid, timeframeInput, bar.new())if not na(secBar)    // To avoid a runtime error, only process data when an object exists.    if not barstate.islast        if timeframe.change(timeframeInput)            // On historical bars, draw a new box in the past when the HTF closes.            drawBox(secBar, time[1])    else        var box lastBox = na        if na(lastBox) or timeframe.change(timeframeInput)            // On the last bar, only draw a new current box the first time we get there or when HTF changes.            lastBox := drawBox(secBar, time)        else            // On other chart updates, use setters to modify the current box.            updateBox(lastBox, secBar)"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_var": {
      "id": "kw_var",
      "name": "var",
      "description": "var is the keyword used for\n                        assigning and one-time initializing of the variable.",
      "syntax": "var variable_name = expression",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Var keyword example\")var a = closevar b = 0.0var c = 0.0var green_bars_count = 0if close > open    var x = close    b := x    green_bars_count := green_bars_count + 1    if green_bars_count >= 10        var y = close        c := yplot(a)plot(b)plot(c)"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_varip": {
      "id": "kw_varip",
      "name": "varip",
      "description": "varip (var intrabar persist) is\n                        the keyword used for the assignment and one-time initialization of a variable or a field of a\n                        user-defined type. It’s similar\n                        to the var keyword, but variables\n                        and fields declared with varip\n                        retain their values between executions of the script on the same bar.",
      "syntax": "varip [<variable_type> ]<variable_name> = <expression>\n\n[export ]type <UDT_identifier>\n    varip <field_type> <field_name> [= <value>]",
      "arguments": [
        {
          "name": "varip",
          "type": "var intrabar persist",
          "description": "is"
        }
      ],
      "examples": [
        "//@version=6indicator(\"varip\")varip int v = -1v := v + 1plot(v)",
        "//@version=6indicator(\"varip with types\")type barData    int index = -1    varip int ticks = -1var currBar = barData.new()currBar.index += 1currBar.ticks += 1// Will be equal to bar_index on all barsplot(currBar.index)// In real time, will increment per every tick on the chartplot(currBar.ticks)"
      ],
      "type": "",
      "seeAlso": []
    },
    "kw_while": {
      "id": "kw_while",
      "name": "while",
      "description": "The while statement allows the\n                        conditional iteration of a local code block.",
      "syntax": "variable_declaration = while condition\n    …\n    continue\n    …\n    break\n    …\n    return_expression",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"while\")// This is a simple example of calculating a factorial using a while loop.int i_n = input.int(10, \"Factorial Size\", minval=0)int counter   = i_nint factorial = 1while counter > 0    factorial := factorial * counter    counter   := counter - 1plot(factorial)"
      ],
      "type": "",
      "seeAlso": []
    },
    "type_array": {
      "id": "type_array",
      "name": "array",
      "description": "Keyword used to explicitly declare the \"array\"\n                        type of a variable or a parameter. Array objects (or IDs) can be created with the array.new<type>, array.from\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"array\", overlay=true)array<float> a = naa := array.new<float>(1, close)plot(array.get(a, 0))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "line",
          "href": "type_line"
        },
        {
          "name": "label",
          "href": "type_label"
        },
        {
          "name": "table",
          "href": "type_table"
        },
        {
          "name": "box",
          "href": "type_box"
        },
        {
          "name": "array.new<type>",
          "href": "fun_array.new<type>"
        },
        {
          "name": "array.from",
          "href": "fun_array.from"
        }
      ]
    },
    "type_bool": {
      "id": "type_bool",
      "name": "bool",
      "description": "Keyword used to explicitly declare the \"bool\"\n                        (boolean) type of a variable or a parameter. \"Bool\" variables can have values true or false.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"bool\")bool b = true    // Same as `b = true`plot(b ? open : close)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "varip",
          "href": "kw_varip"
        },
        {
          "name": "int",
          "href": "type_int"
        },
        {
          "name": "float",
          "href": "type_float"
        },
        {
          "name": "color",
          "href": "type_color"
        },
        {
          "name": "string",
          "href": "type_string"
        },
        {
          "name": "true",
          "href": "const_true"
        },
        {
          "name": "false",
          "href": "const_false"
        }
      ]
    },
    "type_box": {
      "id": "type_box",
      "name": "box",
      "description": "Keyword used to explicitly declare the \"box\" type\n                        of a variable or a parameter. Box objects (or IDs) can be created with the box.new function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"box\")// Empty `box1` box ID.var box box1 = na// `box` type is unnecessary because `box.new()` returns a \"box\" type.var box2 = box.new(na, na, na, na)box3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "line",
          "href": "type_line"
        },
        {
          "name": "label",
          "href": "type_label"
        },
        {
          "name": "table",
          "href": "type_table"
        },
        {
          "name": "box.new",
          "href": "fun_box.new"
        }
      ]
    },
    "type_chart.point": {
      "id": "type_chart.point",
      "name": "chart.point",
      "description": "Keyword to explicitly declare the type of a\n                        variable or parameter as chart.point. Scripts can produce chart.point\n                        instances using the chart.point.from_time, chart.point.from_index, chart.point.now,\n                        and chart.point.new\n                        functions.",
      "syntax": "",
      "arguments": [
        {
          "name": "index",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "time",
          "type": "series int",
          "description": "The"
        },
        {
          "name": "price",
          "type": "series float",
          "description": "The"
        }
      ],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "polyline",
          "href": "type_polyline"
        }
      ]
    },
    "type_color": {
      "id": "type_color",
      "name": "color",
      "description": "Keyword used to explicitly declare the \"color\"\n                        type of a variable or a parameter.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"color\", overlay = true)color textColor = color.greencolor labelColor = #FF000080 // Red color (FF0000) with 50% transparency (80 which is half of FF).if barstate.islastconfirmedhistory    label.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.c = color.rgb(0,255,0,0)plot(close, color = c)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "varip",
          "href": "kw_varip"
        },
        {
          "name": "int",
          "href": "type_int"
        },
        {
          "name": "float",
          "href": "type_float"
        },
        {
          "name": "string",
          "href": "type_string"
        },
        {
          "name": "color.rgb",
          "href": "fun_color.rgb"
        },
        {
          "name": "color.new",
          "href": "fun_color.new"
        }
      ]
    },
    "type_const": {
      "id": "type_const",
      "name": "const",
      "description": "The const keyword explicitly assigns\n                        the \"const\" type qualifier to variables and the parameters of non-exported functions. Variables\n                        and parameters with the \"const\" qualifier reference values established at compile time that\n                        never change in the script's execution.",
      "syntax": "[method ]<functionName>([const <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]const <variableType> <variableName> = <variableValue>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"custom plot title\")//@function Concatenates two \"const string\" values.concatStrings(const string x, const string y) =>    const string result = x + y//@variable The title of the plot.const string myTitle = concatStrings(\"My \", \"Plot\")plot(close, myTitle)",
        "//@version=6indicator(\"can't assign input to const\")//@variable A variable declared as \"const float\" that attempts to assign the result of `input.float()` as its value.//          This declaration causes an error. The \"input float\" qualified type is stronger than \"const float\".const float myVar = input.float(2.0)plot(myVar)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "simple",
          "href": "type_simple"
        },
        {
          "name": "series",
          "href": "type_series"
        }
      ]
    },
    "type_float": {
      "id": "type_float",
      "name": "float",
      "description": "Keyword used to explicitly declare the \"float\"\n                        (floating point) type of a variable or a parameter.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"float\")float f = 3.14    // Same as `f = 3.14`f := naplot(f)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "varip",
          "href": "kw_varip"
        },
        {
          "name": "int",
          "href": "type_int"
        },
        {
          "name": "bool",
          "href": "type_bool"
        },
        {
          "name": "color",
          "href": "type_color"
        },
        {
          "name": "string",
          "href": "type_string"
        }
      ]
    },
    "type_int": {
      "id": "type_int",
      "name": "int",
      "description": "Keyword used to explicitly declare the \"int\"\n                        (integer) type of a variable or a parameter.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"int\")int i = 14    // Same as `i = 14`i := naplot(i)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "varip",
          "href": "kw_varip"
        },
        {
          "name": "float",
          "href": "type_float"
        },
        {
          "name": "bool",
          "href": "type_bool"
        },
        {
          "name": "color",
          "href": "type_color"
        },
        {
          "name": "string",
          "href": "type_string"
        }
      ]
    },
    "type_label": {
      "id": "type_label",
      "name": "label",
      "description": "Keyword used to explicitly declare the \"label\"\n                        type of a variable or a parameter. Label objects (or IDs) can be created with the label.new\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"label\")// Empty `label1` label ID.var label label1 = na// `label` type is unnecessary because `label.new()` returns \"label\" type.var label2 = label.new(na, na, na)if barstate.islastconfirmedhistory    label3 = label.new(bar_index, high, text = \"label3 text\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "line",
          "href": "type_line"
        },
        {
          "name": "box",
          "href": "type_box"
        },
        {
          "name": "label.new",
          "href": "fun_label.new"
        }
      ]
    },
    "type_line": {
      "id": "type_line",
      "name": "line",
      "description": "Keyword used to explicitly declare the \"line\" type\n                        of a variable or a parameter. Line objects (or IDs) can be created with the line.new\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"line\")// Empty `line1` line ID.var line line1 = na// `line` type is unnecessary because `line.new()` returns \"line\" type.var line2 = line.new(na, na, na, na)line3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "label",
          "href": "type_label"
        },
        {
          "name": "box",
          "href": "type_box"
        },
        {
          "name": "line.new",
          "href": "fun_line.new"
        }
      ]
    },
    "type_linefill": {
      "id": "type_linefill",
      "name": "linefill",
      "description": "Keyword used to explicitly declare the \"linefill\"\n                        type of a variable or a parameter. Linefill objects (or IDs) can be created with the linefill.new function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"linefill\", overlay=true)// Empty `linefill1` line ID.var linefill linefill1 = na// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.var linefill2 = linefill.new(na, na, na)if barstate.islastconfirmedhistory    line1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)    line2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)    linefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "line",
          "href": "type_line"
        },
        {
          "name": "label",
          "href": "type_label"
        },
        {
          "name": "table",
          "href": "type_table"
        },
        {
          "name": "box",
          "href": "type_box"
        },
        {
          "name": "linefill.new",
          "href": "fun_linefill.new"
        }
      ]
    },
    "type_map": {
      "id": "type_map",
      "name": "map",
      "description": "Keyword used to explicitly declare the \"map\" type\n                        of a variable or a parameter. Map objects (or IDs) can be created with the map.new<type,type> function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"map\", overlay=true)map<int, float> a = naa := map.new<int, float>()a.put(bar_index, close)label.new(bar_index, a.get(bar_index), \"Current close\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "map.new<type,type>",
          "href": "fun_map.new<type,type>"
        }
      ]
    },
    "type_matrix": {
      "id": "type_matrix",
      "name": "matrix",
      "description": "Keyword used to explicitly declare the \"matrix\"\n                        type of a variable or a parameter. Matrix objects (or IDs) can be created with the matrix.new<type> function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"matrix example\")// Create `m1` matrix of `int` type.matrix<int> m1 = matrix.new<int>(2, 3, 0)// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.m2 = matrix.new<int>(2, 3, 0)// Display matrix using a label.if barstate.islastconfirmedhistory    label.new(bar_index, high, str.tostring(m2))"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "matrix.new<type>",
          "href": "fun_matrix.new<type>"
        },
        {
          "name": "array",
          "href": "type_array"
        }
      ]
    },
    "type_polyline": {
      "id": "type_polyline",
      "name": "polyline",
      "description": "Keyword to explicitly declare the type of a\n                        variable or parameter as polyline. Scripts can produce polyline\n                        instances using the polyline.new function.",
      "syntax": "",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": [
        {
          "name": "chart.point",
          "href": "type_chart.point"
        }
      ]
    },
    "type_series": {
      "id": "type_series",
      "name": "series",
      "description": "The series keyword explicitly assigns\n                        the \"series\" type qualifier to variables and function parameters. Variables and parameters that\n                        use the \"series\" qualifier can reference values that change throughout a script's execution.",
      "syntax": "export [method ]<functionName>([[series ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([series <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]series <variableType> <variableName> = <variableValue>",
      "arguments": [],
      "examples": [
        "//@version=6//@description A library with custom functions.library(\"CustomFunctions\", overlay = true)//@function Finds the highest `source` value over `length` bars, filtered by the `cond` condition.export conditionalHighest(series float source, series bool cond, series int length) =>    //@variable The highest `source` value from when the `cond` was `true` over `length` bars.    series float result = na    // Loop to find the highest value.    for i = 0 to length - 1        if cond[i]            value   = source[i]            result := math.max(nz(result, value), value)    // Return the `result`.    result//@variable Is `true` once every five bars.series bool condition = bar_index % 5 == 0//@variable The highest `close` value from every fifth bar over the last 100 bars.series float hiValue = conditionalHighest(close, condition, 100)plot(hiValue)bgcolor(condition ? color.new(color.teal, 80) : na)",
        "//@version=6indicator(\"series variable not allowed\")//@variable A variable declared as \"series int\" with a value of 5.series int myVar = 5// This call causes an error.// The `histbase` accepts \"input int/float\". It can't accept the stronger \"series int\" qualified type.plot(close, style = plot.style_histogram, histbase = myVar)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "simple",
          "href": "type_simple"
        },
        {
          "name": "const",
          "href": "type_const"
        }
      ]
    },
    "type_simple": {
      "id": "type_simple",
      "name": "simple",
      "description": "The simple keyword explicitly assigns\n                        the \"simple\" type qualifier to variables and function parameters. Variables and parameters that\n                        use the \"simple\" qualifier can reference values established at the beginning of a script's\n                        execution that do not change later.",
      "syntax": "export [method ]<functionName>([[simple ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([simple <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]simple <variableType> <variableName> = <variableValue></variableValue>",
      "arguments": [],
      "examples": [
        "//@version=6//@description A library with custom functions.library(\"CustomFunctions\", overlay = true)//@function         Calculates the length values for a ribbon of four EMAs by multiplying the `baseLength`.//@param baseLength The initial EMA length. Requires \"simple int\" because you can't use \"series int\" in `ta.ema()`.//@returns          A tuple of length values.export ribbonLengths(simple int baseLength) =>    simple int length1 = baseLength    simple int length2 = baseLength * 2    simple int length3 = baseLength * 3    simple int length4 = baseLength * 4    [length1, length2, length3, length4]// Get a tuple of \"simple int\" length values.[len1, len2, len3, len4] = ribbonLengths(14)// Plot four EMAs using the values from the tuple.plot(ta.ema(close, len1), \"EMA 1\", color = color.red)plot(ta.ema(close, len2), \"EMA 1\", color = color.orange)plot(ta.ema(close, len3), \"EMA 1\", color = color.green)plot(ta.ema(close, len4), \"EMA 1\", color = color.blue)",
        "//@version=6indicator(\"can't change simple to series\")//@variable A variable declared as \"simple float\" with a value of 5.0.simple float myVar = 5.0// This reassignment causes an error.// The `close` variable returns a \"series float\" value. Since `myVar` is restricted to \"simple\" values, it cannot// change its qualifier to \"series\".myVar := closeplot(myVar)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "series",
          "href": "type_series"
        },
        {
          "name": "const",
          "href": "type_const"
        }
      ]
    },
    "type_string": {
      "id": "type_string",
      "name": "string",
      "description": "Keyword used to explicitly declare the \"string\"\n                        type of a variable or a parameter.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"string\")string s = \"Hello World!\"    // Same as `s = \"Hello world!\"`// string s = na // same as \"\" plot(na, title=s)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "varip",
          "href": "kw_varip"
        },
        {
          "name": "int",
          "href": "type_int"
        },
        {
          "name": "float",
          "href": "type_float"
        },
        {
          "name": "bool",
          "href": "type_bool"
        },
        {
          "name": "str.tostring",
          "href": "fun_str.tostring"
        },
        {
          "name": "str.format",
          "href": "fun_str.format"
        }
      ]
    },
    "type_table": {
      "id": "type_table",
      "name": "table",
      "description": "Keyword used to explicitly declare the \"table\"\n                        type of a variable or a parameter. Table objects (or IDs) can be created with the table.new\n                        function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"table\")// Empty `table1` table ID.var table table1 = na// `table` type is unnecessary because `table.new()` returns \"table\" type.var table2 = table.new(position.top_left, na, na)if barstate.islastconfirmedhistory    var table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)    table.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "var",
          "href": "kw_var"
        },
        {
          "name": "line",
          "href": "type_line"
        },
        {
          "name": "label",
          "href": "type_label"
        },
        {
          "name": "box",
          "href": "type_box"
        },
        {
          "name": "table.new",
          "href": "fun_table.new"
        }
      ]
    },
    "op_-": {
      "id": "op_-",
      "name": "-",
      "description": "Subtraction or unary minus. Applicable to\n                        numerical expressions.",
      "syntax": "expr1 - expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_-=": {
      "id": "op_-=",
      "name": "-=",
      "description": "Subtraction assignment. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 -= expr2",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"-=\")// Equals to expr1 = expr1 - expr2.a = 2b = 3a -= b// Result: a = -1.plot(a)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_:=": {
      "id": "op_:=",
      "name": ":=",
      "description": "Reassignment operator. It is used to assign a new\n                        value to a previously declared variable.",
      "syntax": "<var_name> := <new_value>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"My script\")myVar = 10if close > open    // Modifies the existing global scope `myVar` variable by changing its value from 10 to 20.    myVar := 20    // Creates a new `myVar` variable local to the `if` condition and unreachable from the global scope.    // Does not affect the `myVar` declared in global scope.    myVar = 30plot(myVar)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_!=": {
      "id": "op_!=",
      "name": "!=",
      "description": "Not equal to. Applicable to expressions of any\n                        type.",
      "syntax": "expr1 != expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_?:": {
      "id": "op_?:",
      "name": "?:",
      "description": "Ternary conditional operator.",
      "syntax": "expr1 ? expr2 : expr3",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"?:\")// Draw circles at the bars where open crosses closes2 = ta.cross(open, close) ? math.avg(open,close) : naplot(s2, style=plot.style_circles, linewidth=2, color=color.red)// Combination of ?: operators for 'switch'-like logicc = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.grayplot(hl2, color=c)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "na",
          "href": "var_na"
        }
      ]
    },
    "op_[]": {
      "id": "op_[]",
      "name": "[]",
      "description": "Series subscript. Provides access to previous\n                        values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be\n                        rounded down.",
      "syntax": "expr1[expr2]",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"[]\")// [] can be used to \"save\" variable value between barsa = 0.0 // declare `a`a := a[1] // immediately set current value to the same as previous. `na` in the beginning of historyif high == low // if some condition - change `a` value to another    a := lowplot(a)"
      ],
      "type": "",
      "seeAlso": [
        {
          "name": "math.floor",
          "href": "fun_math.floor"
        }
      ]
    },
    "op_*": {
      "id": "op_*",
      "name": "*",
      "description": "Multiplication. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 * expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_*=": {
      "id": "op_*=",
      "name": "*=",
      "description": "Multiplication assignment. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 *= expr2",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"*=\")// Equals to expr1 = expr1 * expr2.a = 2b = 3a *= b// Result: a = 6.plot(a)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_/": {
      "id": "op_/",
      "name": "/",
      "description": "Division. Applicable to numerical expressions.",
      "syntax": "expr1 / expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_/=": {
      "id": "op_/=",
      "name": "/=",
      "description": "Division assignment. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 /= expr2",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"/=\")// Equals to expr1 = expr1 / expr2.float a = 3.0b = 3a /= b// Result: a = 1.plot(a)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_%": {
      "id": "op_%",
      "name": "%",
      "description": "Modulo (integer remainder). Applicable to\n                        numerical expressions.",
      "syntax": "expr1 % expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_%=": {
      "id": "op_%=",
      "name": "%=",
      "description": "Modulo assignment. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 %= expr2",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"%=\")// Equals to expr1 = expr1 % expr2.a = 3b = 3a %= b// Result: a = 0.plot(a)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_+": {
      "id": "op_+",
      "name": "+",
      "description": "Addition or unary plus. Applicable to numerical\n                        expressions or strings.",
      "syntax": "expr1 + expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_+=": {
      "id": "op_+=",
      "name": "+=",
      "description": "Addition assignment. Applicable to numerical\n                        expressions or strings.",
      "syntax": "expr1 += expr2",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"+=\")// Equals to expr1 = expr1 + expr2.a = 2b = 3a += b// Result: a = 5.plot(a)"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_<": {
      "id": "op_<",
      "name": "<",
      "description": "Less than. Applicable to numerical expressions.",
      "syntax": "expr1 < expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_<=": {
      "id": "op_<=",
      "name": "<=",
      "description": "Less than or equal to. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 <= expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_==": {
      "id": "op_==",
      "name": "==",
      "description": "Equal to. Applicable to expressions of any type.",
      "syntax": "expr1 == expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_=>": {
      "id": "op_=>",
      "name": "=>",
      "description": "The '=>' operator is used in user-defined\n                        function declarations and in switch\n                        statements.",
      "syntax": "<identifier>([<parameter_name>[=<default_value>]], ...) =>\n    <local_block>\n    <function_result>",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"=>\")// single-line functionf1(x, y) => x + y// multi-line functionf2(x, y) =>     sum = x + y    sumChange = ta.change(sum, 10)    // Function automatically returns the last expression used in itplot(f1(30, 8) + f2(1, 3))"
      ],
      "type": "",
      "seeAlso": []
    },
    "op_>": {
      "id": "op_>",
      "name": ">",
      "description": "Greater than. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 > expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "op_>=": {
      "id": "op_>=",
      "name": ">=",
      "description": "Greater than or equal to. Applicable to numerical\n                        expressions.",
      "syntax": "expr1 >= expr2",
      "arguments": [],
      "examples": [],
      "type": "",
      "seeAlso": []
    },
    "an_@description": {
      "id": "an_@description",
      "name": "@description",
      "description": "Sets a custom description for scripts that use the\n                        library declaration\n                        statement. The text provided with this annotation will be used to pre-fill the \"Description\"\n                        field in the publication dialogue.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6// @description Provides a tool to quickly output a label on the chart.library(\"MyLibrary\")// @function Outputs a label with `labelText` on the bar's high.// @param labelText (series string) The text to display on the label.// @returns Drawn label.export drawLabel(string labelText) =>    label.new(bar_index, high, text = labelText)"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@enum": {
      "id": "an_@enum",
      "name": "@enum",
      "description": "If placed above an enum declaration, it adds a\n                        custom description for the enum. The Pine Editor's autosuggest uses this description and\n                        displays it when a user hovers over the enum name. When used in library scripts, the\n                        descriptions of all enums using the export keyword will pre-fill\n                        the \"Description\" field in the publication dialogue.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Session highlight\", overlay = true)//@enum       Contains fields with popular timezones as titles.//@field exch Has an empty string as the title to represent the chart timezone.enum tz    utc  = \"UTC\"    exch = \"\"    ny   = \"America/New_York\"    chi  = \"America/Chicago\"    lon  = \"Europe/London\"    tok  = \"Asia/Tokyo\"//@variable The session string.selectedSession = input.session(\"1200-1500\", \"Session\")//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.selectedTimezone = input.enum(tz.utc, \"Session Timezone\")//@variable Is `true` if the current bar's time is in the specified session.bool inSession = falseif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))    inSession := true// Highlight the background when `inSession` is `true`.bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@field": {
      "id": "an_@field",
      "name": "@field",
      "description": "If placed above a type\n                        or enum declaration, it adds a\n                        custom description for a field of the type/enum. After the annotation, users should specify the\n                        field name, followed by its description.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"New high over the last 20 bars\", overlay = true)//@type A point on a chart.//@field index The index of the bar where the point is located, i.e., its `x` coordinate.//@field price The price where the point is located, i.e., its `y` coordinate.type Point    int index    float price//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.Point highest = naif ta.highestbars(high, 20) == 0    highest := Point.new(bar_index, high)    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@function": {
      "id": "an_@function",
      "name": "@function",
      "description": "If placed above a function declaration, it adds a\n                        custom description for the function.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6// @description Provides a tool to quickly output a label on the chart.library(\"MyLibrary\")// @function Outputs a label with `labelText` on the bar's high.// @param labelText (series string) The text to display on the label.// @returns Drawn label.export drawLabel(string labelText) =>    label.new(bar_index, high, text = labelText)"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@param": {
      "id": "an_@param",
      "name": "@param",
      "description": "If placed above a function declaration, it adds a\n                        custom description for a function parameter. After the annotation, users should specify the\n                        parameter name, then its description.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6// @description Provides a tool to quickly output a label on the chart.library(\"MyLibrary\")// @function Outputs a label with `labelText` on the bar's high.// @param labelText (series string) The text to display on the label.// @returns Drawn label.export drawLabel(string labelText) =>    label.new(bar_index, high, text = labelText)"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@returns": {
      "id": "an_@returns",
      "name": "@returns",
      "description": "If placed above a function declaration, it adds a\n                        custom description for what that function returns.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6// @description Provides a tool to quickly output a label on the chart.library(\"MyLibrary\")// @function Outputs a label with `labelText` on the bar's high.// @param labelText (series string) The text to display on the label.// @returns Drawn label.export drawLabel(string labelText) =>    label.new(bar_index, high, text = labelText)"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@strategy_alert_message": {
      "id": "an_@strategy_alert_message",
      "name": "@strategy_alert_message",
      "description": "If used within a strategy\n                        script, it provides a default message to pre-fill the \"Message\" field in the alert creation\n                        dialogue.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6strategy(\"My strategy\", overlay=true, margin_long=100, margin_short=100)//@strategy_alert_message Strategy alert on symbol {{ticker}}longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))if (longCondition)    strategy.entry(\"My Long Entry Id\", strategy.long)strategy.exit(\"Exit\", \"My Long Entry Id\", profit = 10 / syminfo.mintick, loss = 10 / syminfo.mintick)"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@type": {
      "id": "an_@type",
      "name": "@type",
      "description": "If placed above a type declaration, it adds a\n                        custom description for the type.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"New high over the last 20 bars\", overlay = true)//@type A point on a chart.//@field index The index of the bar where the point is located, i.e., its `x` coordinate.//@field price The price where the point is located, i.e., its `y` coordinate.type Point    int index    float price//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.Point highest = naif ta.highestbars(high, 20) == 0    highest := Point.new(bar_index, high)    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@variable": {
      "id": "an_@variable",
      "name": "@variable",
      "description": "If placed above a variable declaration, it adds a\n                        custom description for the variable.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"New high over the last 20 bars\", overlay = true)//@type A point on a chart.//@field index The index of the bar where the point is located, i.e., its `x` coordinate.//@field price The price where the point is located, i.e., its `y` coordinate.type Point    int index    float price//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.Point highest = naif ta.highestbars(high, 20) == 0    highest := Point.new(bar_index, high)    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ],
      "type": "",
      "seeAlso": []
    },
    "an_@version=": {
      "id": "an_@version=",
      "name": "@version=",
      "description": "Specifies the Pine Script® version that the script\n                        will use. The number in this annotation should not be confused with the script's version number,\n                        which updates on every saved change to the code.",
      "syntax": "",
      "arguments": [],
      "examples": [
        "//@version=6indicator(\"Pine v6 Indicator\")plot(close)",
        "//This indicator has no version annotation, so it will try to use v1.//Pine Script® v1 has no function named `indicator()`, so the script will not compile.indicator(\"Pine v1 Indicator\")plot(close)"
      ],
      "type": "",
      "seeAlso": []
    }
  },
  "metadata": {
    "source": "Pine Script® language reference manual",
    "extraction_method": "manual_html_parsing",
    "last_updated": "2025-08-16T03:56:43.800Z",
    "total_functions": 457,
    "total_variables": 427,
    "categories": {
      "built_in_variables": 258,
      "constants": 109,
      "keywords": 17,
      "types": 14,
      "operators": 19,
      "annotations": 10
    }
  }
}