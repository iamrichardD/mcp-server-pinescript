{
  "ef734917": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Execution model\n\nIntroduction\n\nPine Script® relies on an event-driven, sequential execution model to control how a script’s compiled source code runs in charts, alerts, Deep Backtesting mode, and the Pine Screener.\n\nIn contrast to the traditional execution model of most programming languages, Pine’s runtime system executes a script _repeatedly_ on the sequence of _historical bars_ and _realtime ticks_ in the dataset on which it runs, performing _separate_ calculations for _each bar_ as it progresses. After each execution on a closed bar, the necessary data from that execution becomes part of an internal time series, and the script can use that data in its calculations on subsequent bars.\n\nThis combination of sequential executions and storage enables programmers to use minimal code to write scripts with dynamic calculations that advance across a dataset bar by bar.\n\nThe execution model and time series structure closely connect to the type system — together, they define how a script behaves as it runs on a dataset. Although it’s possible to write simple scripts without understanding these foundational topics, learning about them and their nuances is key to becoming proficient in Pine Script.\n\nThis page explains the execution model in two parts: The basics and The details. The first part provides quick, actionable information about the model for beginners. The second part offers an _advanced_, in-depth breakdown of the model’s workings and unique behaviors. To make the most of the information on this page, we recommend that newcomers to Pine Script start with The basics, learn about other topics in this manual, and then come back to this page for the advanced details.\n\nThe basics\n\nThe following sections outline core principles of the execution model for beginners. If you are new to Pine Script, start here.\n\nBar-by-bar execution\n\nThe dataset for a symbol on a given timeframe, as shown on a chart, consists of a sequence of bars representing a _time series_. Each bar in the sequence represents the price and volume for a specific time period. The first (leftmost) bar on a chart corresponds to the _earliest_ period, and the last (rightmost) bar corresponds to the _most recent_ period.\n\nMuch of the power of Pine Script stems from its ability to process this time series data efficiently. When a user runs a script, its code does _not_ execute just once; it executes from start to end on _each bar_ in the symbol’s dataset individually, progressing from the first available bar to the most recent bar. Each separate script execution performs calculations or generates outputs (e.g., plots) for a _specific bar_ using the data available on that bar.\n\nA script can retrieve price, volume, and other essential data for each bar on which it executes by using the built-in variables that hold bar information, such as open, high, low, close, and volume. These variables automatically _update_ before each new execution to store the values for the _current bar_.\n\nFor example, the simple script below uses the plot() function to display the series of close values (i.e., the closing price of each bar) on the chart:\n\nPine Script®\nCopied\n\n`//@version=6\nindicator(\"Bar-by-bar execution demo\", overlay = true, behind_chart = false)\n// Plot the close series on the chart.\n// This call defines the plotted point for the current bar on each execution.\nplot(close, \"Close price\", chart.fg_color, 5)\n\nWhen a user first adds this script to their chart, its code executes _once_ for _every bar_ in the available dataset. As the script runs on the data, two primary steps occur on each bar:\n\n1. The close variable automatically updates to hold the current bar’s latest price.\n2. The plot() function call plots the updated close value at the current bar’s position.\n\nWhen the script finishes its run from the first bar to the most recent bar, the result is a simple _line plot_ showing the progression of closing prices across the chart’s history:\n\nNote that the above script evaluates the plot() function call once for every bar on the chart, not just once in total. On each separate execution, the call defines the plotted point for the current bar: the chart’s first bar during the first execution, the second bar during the next, and so on.\n\nThis pattern illustrates a key principle of Pine’s execution model: on each successive execution, a script _re-evaluates_ function calls and other expressions within its required _scopes_ to perform separate calculations for the current bar.\n\nRepeated code evaluation also applies to variable declarations. By default, a script does not declare a variable only once throughout its runtime; the script _re-declares_ that variable and assigns an initial value based on the current bar’s data during _each_ new evaluation of its scope.\n\nLet’s look at a simple example. The following script declares an x variable of the “int” type with an initial value of 0. Then, it increases the variable’s value by 10 with the addition assignment operator ( +=). The script calls plot() to display the value of x on each bar in a separate pane:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Repeated declarations demo\")\n//@variable A user-defined variable. The script declares this variable and initializes it to 0 on every execution.\nint x = 0\n// Increase the value of x by 10 on every bar.\nx += 10\n// Plot the value of x.\n// Because x begins at 0 on every execution, and the script adds 10 to that value, the plotted value is always 10.\nplot(x, \"x value\", color.blue, 3)\n\nAs shown above, the script plots a value of 10 on every bar, because the x variable _does not_ carry over from bar to bar; the script declares the variable _repeatedly_. On each bar, the script re-declares x with an initial value of 0, then adds 10 to that value, resulting in a final value of 10 for every plotted point.\n\nProgrammers can change the behavior of a variable, enabling it to _persist_ and preserve updates to its value _across bars_, by including the var keyword in its declaration, as described in the Declaration modes section of the Variable declarations page.\n\nBelow, we modify the previous script by adding var to the x declaration. Now, the script declares and initializes x only _once_ — on the _first bar_ — and that variable persists across _all_ bars that follow. The script now plots a line that _increases_ by 10 on each bar, because x preserves the result from each addition across the chart’s history. The value changes from 0 to 10 on the first bar, then to 20 on the second, and so on:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Persistent declarations demo\")\n//@variable A persistent variable. The script initializes this variable only on the first execution.\n//          The variable preserves all changes to its value on each closed bar.\nvar int x = 0\n// Increase the value of x by 10 on every bar.\nx += 10\n// Plot the x series on the chart.\n// Because the script declares x using var and then increments its value, the value never resets to 0.\n// The plotted value is 10 on the first bar, 20 on the next, and so on.\nplot(x, \"x series\", color.blue, 3)\n\nStoring and using data from previous bars\n\nAs a script runs on a dataset, the states of its variables, function calls, and other expressions are automatically _committed (saved)_ to an internal _time series_ on each bar, creating historical trails of previous bar values that the script can access during its calculations on the current bar. The script can use these previous values by doing either of the following:\n\n- Using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The number in the square brackets represents how many _bars back_ from the current bar the script looks to retrieve a past value. For instance, close[1] retrieves the close value from _one bar before_ the current bar, and close[100] retrieves the value from _100 bars back_.\n- Calling the built-in functions that calculate on past values internally, such as ta.*() functions. For instance, ta.change(close, 10) calculates the difference between the current value of close and its value from 10 bars back.\n\nThe example below uses both of the above techniques to perform calculations based on data from previous bars. The script calculates a series of bar-by-bar price returns and plots the result as color-coded columns. It declares two global variables on each bar: priceReturn for the calculated returns, and returnColor for the plot’s color. The priceReturn value is the result of dividing the current one-bar change in closing prices ( ta.change(close, 1)) by the previous bar’s closing price ( close[1]). The returnColor value is color.teal if the current value of priceReturn is higher than the value from the previous bar ( priceReturn[1]), and color.maroon otherwise:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Storing and using data from previous bars demo\")\n//@variable The one-bar price return, based on the current and previous bars' close values.\n//          This variable's final value on each bar automatically becomes part of the internal time series.\nfloat priceReturn = ta.change(close, 1) / close[1]\n//@variable Is color.teal if the priceReturn value is above the value on the previous bar; color.maroon otherwise.\ncolor returnColor = priceReturn > priceReturn[1] ? color.teal : color.maroon\n// Plot the current priceReturn value as a column, colored using the value of returnColor.\nplot(priceReturn, \"Price return\", returnColor, 1, plot.style_columns)\n\nNote that:\n\n- This script does _not_ plot a column on bar 0 (the _first_ bar). The priceReturn value is na on that bar, because there is _no previous bar_ available for the script to reference at that point.\n\nRealtime bars\n\nWhen a script first runs on a chart, all _closed_ bars in the accessed dataset are _historical bars_. These bars represent data for elapsed time periods where the final price and volume are _confirmed_. All indicators execute once per historical bar.\n\nWhen the rightmost bar on the chart is _open_, it is a _realtime bar_. Unlike a historical bar, whose values are final, a realtime bar _updates_ its values as new price or volume data becomes available. After the bar closes, it becomes an _elapsed realtime bar_, which is then no longer subject to change as the script runs.\n\nBecause the final values for a realtime bar are _unknown_ until the bar closes, an indicator executes differently on that bar than it does on historical bars. The script executes not once, but repeatedly on the realtime bar — once for each new _update (tick)_ — to _recalculate_ its results using the latest data.\n\nBefore each recalculation on the realtime bar, the data for a script’s variables, expressions, and outputs on that bar is _cleared_, or _reset_. We refer to this process as _rollback_. The purpose of rollback is to revert the script to the same confirmed state it had when the realtime bar opened. This process ensures that the script’s calculations for the bar operate only on the latest available data, without relying on _temporary data_ from the bar’s _previous ticks_.\n\nLet’s look at rollback and recalculation in action. The following script uses ta.stoch() to calculate the Stochastic oscillator based on the close, high, and low values over a specified number of bars, then plots the result in a separate pane. It also calls bgcolor() to highlight the background on each realtime bar — where barstate.isrealtime is true — for visual reference:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Recalculation on realtime bars demo\")\n//@variable The number of bars in the Stochastic calculation. Users can change this value in the \"Settings/Inputs\" tab.\nint lengthInput = input.int(10, \"Length\", 1)\n//@variable The Stochastic oscillator, based on the close, high, and low values over lengthInput bars.\nfloat stochastic = ta.stoch(close, high, low, lengthInput)\n// Plot the stochastic value for each bar.\nplot(stochastic, \"Stochastic %K\", color.teal, 3)\n// Highlight the background of each realtime bar.\nbgcolor(barstate.isrealtime ? color.new(color.purple, 80) : na, title = \"Realtime background highlight\")\n\nWhen we add the script to our chart, it executes once per bar in the chart’s history, from the leftmost bar to the rightmost bar. However, the rightmost bar on our chart is still _open_. Therefore, it is a _realtime bar_, not a historical bar. After the script reaches that bar, it begins executing once for _every new update_ to the bar’s data. Each new script execution calculates on the latest available prices and _replaces_ the bar’s previous result.\n\nFor instance, in the initial image below, the oscillator’s value 10 seconds into the open realtime bar (the one with the purple background) is 32.08:\n\nEvery time the bar updates, rollback _resets_ the script’s data for that bar, and the script _recalculates_ its result using the latest high, low, and close values. Here, halfway through the realtime bar’s period, the oscillator’s plot now shows a value of 16.71:\n\nRecalculation continues for each successive update to the bar. Then, the script reaches the bar’s closing tick, where the prices become _confirmed_. On that tick, the script calculates the oscillator’s final value of 19.35. Afterward, another realtime bar opens, and the pattern of rollback and recalculation continues on that bar:\n\nNote that:\n\n- Only the values for a realtime bar’s _final tick_ become part of the internal time series. The values from ticks _before_ the bar’s close are not saved.\n- The input.int() function returns a value of the “input int” _qualified type_. Values qualified as “input” are established _before_ the first script execution, and they remain consistent throughout the script’s runtime. If the user changes the “Length” input to a new value, the script _restarts_ to perform new calculations across the dataset using that value. See the Inputs page and the Qualifiers section of the Type system page to learn more about script inputs and the “input” qualifier.\n- If the script restarts, all the realtime bars from the previous script run become _historical bars_ in the new run. Therefore, after restarting, the script executes only once on each of those bars and does _not_ highlight their background.\n\nThe details\n\nThe following sections provide in-depth details about Pine’s execution model, including the mechanics of executions on historical bars and realtime bars, which events trigger script executions, and how the runtime system maintains data across executions in a time series format.\n\nExecutions on historical bars\n\nWhen a script loads on the chart or in another location after an execution-triggering event, its compiled source code executes on _every_ accessible bar in the current dataset in order, starting with the first bar.\n\nWhile the script loads, the runtime system performs the following steps for _each bar_ that it accesses:\n\n1. It updates the built-in variables that hold bar information. For instance, the system sets the open, high, low, and close variables to hold the OHLC price values of the bar _before_ each execution.\n2. It executes the script’s compiled code from start to end using the data available as of the current bar.\n3. After the execution ends, the system commits (saves) all necessary data for the current bar to the time series. The script can then access that data from historical buffers during its executions on subsequent bars by using the history-referencing operator or the built-in functions that reference past bars internally.\n\nThese steps repeat for every successive bar up to the most recent bar. After the runtime system completes this process across the dataset, the script’s committed _outputs_ — such as plots, drawings, Pine Logs, and Strategy Tester results — become available to the user.\n\nAll the closed bars on which the script executes while loading are _historical_, because they represent data points that were confirmed before the event that triggered the loading process. By default, all scripts execute once for each historical bar.\n\nLet’s examine a simple indicator to understand how script executions work on historical bars.\n\nThe script below calculates the 20-bar moving average of close values and plots the result on the chart. The color of the plot depends on whether the average is above or below the value on the previous bar. The script also increments an executionNum variable to count code executions, then plots the result alongside bar\\_index for comparison. Additionally, it highlights the background of historical bars in orange for visual reference:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Executions on historical bars demo\")\n//@variable The average of the latest 20 close values.\nfloat sma = ta.sma(close, 20)\n//@variable Is color.green if the sma value is above the value on the previous bar; color.red otherwise.\ncolor plotColor = sma > sma[1] ? color.green : color.red\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the executionNum value.\nexecutionNum += 1\n// Display the sma as a line plot on the main chart pane, colored by the plotColor.\nplot(sma, \"SMA\", plotColor, 3, force_overlay = true)\n// Display the executionNum and bar_index series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\n// Highlight the chart's background in translucent orange when barstate.ishistory is true.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\n\nThe statements and expressions in this source code might appear static at first glance. However, they have _dynamic_ behavior across bars because the system executes the script _repeatedly_ — once for each successive data point. Below, we inspect the code step by step to explain how the script works during its historical executions.\n\nThe indicator() call at the top of the code is a declaration statement that defines the script’s type and properties once, at _compile time_. This statement does not execute as the script runs on the dataset:\n\nPine Script®\nCopied\n\nindicator(\"Executions on historical bars demo\")\n\n_Before_ each script execution on a bar, the runtime system updates the built-in bar\\_index and close variables required in the calculations. The bar\\_index value is the bar’s global _time series index_, where 0 represents the first bar, 1 represents the second, and so on. The close variable holds the bar’s _latest price_. For historical bars, its value is the _final price_ at the bar’s closing time.\n\nEach time that the script executes, it declares and initializes a global sma variable of the “float” type. This variable declaration happens on _every_ execution because the code line does not specify a declaration mode. The variable’s assigned value is the result of a ta.sma() function call. The call returns the average of the latest 20 close values as of the current bar, or na if fewer than 20 bars are available. After the execution ends, the system commits the new value of sma to the time series:\n\nPine Script®\nCopied\n\n//@variable The average of the latest 20 close values.\nfloat sma = ta.sma(close, 20)\n\nNote that:\n\n- The //@variable comment above the sma declaration is an annotation that _documents_ the variable in the code. The Pine Editor displays the comment in a pop-up window when the user hovers the mouse pointer over the variable.\n\nDuring each execution, the script also initializes a plotColor variable of the “color” type. The script uses a ternary operation that compares the current sma value to sma[1] — the _last committed value_ for sma as of the _previous bar_ — to determine the plotColor variable’s assigned value. If the current sma value is higher than the last committed value, the plotColor value is color.green. Otherwise, it is color.red:\n\nPine Script®\nCopied\n\n//@variable Is color.green if the sma value is above the value on the previous bar; color.red otherwise.\ncolor plotColor = sma > sma[1] ? color.green : color.red\n\nIn contrast to the variables above, the script _does not_ initialize the executionNum variable on every execution. Instead, initialization happens only _once_ — on the _first_ bar — because the variable declaration is in the _global scope_ and uses the varip keyword. Once initialized, the variable _persists_ across all subsequent bars and the ticks within those bars. Only the reassignment or compound assignment operators can change its value:\n\nPine Script®\nCopied\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n\nThe code following the executionNum declaration uses the addition assignment operator ( +=) to increase the variable’s value by one on each new execution. Starting from -1, the value increases to 0 on the first execution after initialization, then 1 on the second, and so on:\n\nPine Script®\nCopied\n\n// Add 1 to the executionNum value.\nexecutionNum += 1\n\nThe script evaluates the plot() and bgcolor() calls on every execution. Each plot() call creates a new point on a line plot at the bar’s location on the time axis. The bgcolor() call creates a background color for the bar based on a ternary expression. The background is translucent orange if barstate.ishistory is true. Otherwise, it is na (no color):\n\nPine Script®\nCopied\n\n// Display the sma as a line plot on the main chart pane, colored by the plotColor.\nplot(sma, \"SMA\", plotColor, 3, force_overlay = true)\n// Display the executionNum and bar_index series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\n// Highlight the chart's background in translucent orange when barstate.ishistory is true.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\n\nNote that:\n\n- The plot() and bgcolor() calls that include force_overlay = true display their visuals on the main chart pane. The other plot() calls\noutput visuals in a separate pane, because the indicator() call does not include overlay = true.\n\nAfter the system executes the script on all available data points and finishes loading, the script’s outputs then become visible on the chart:\n\nNote that:\n\n- When the script first loads, _all_ bars, including the latest one, have an orange background because they initially represent _historical_ data. However, the latest bar on our chart is still open, meaning it is a _realtime bar_. After a new tick arrives from the realtime data feed, the bar’s values update, and the script executes _again_ on that bar. The orange background for the bar then _disappears_ because the system sets the value of barstate.ishistory to false.\n- The executionNum and bar\\_index values are identical on historical bars because the script executes _once per bar_ on that part of the dataset. However, they begin to differ on the realtime bar. On that bar, the script executes after _every new update_ to recalculate its results, and the executionNum value increases each time. See the Executions on realtime bars section to learn more.\n- An alternative, more robust method to track code executions is to use the Pine Profiler. The profiler analyzes the total runtime and execution count of every significant part of the source code. To learn more about this feature, see the Profiling and optimization page.\n\nIt’s important to note that, unlike indicators, strategies can execute _more than once_ per historical bar, depending on the specified calculation behavior. If the strategy() declaration statement includes calc_on_order_fills = true, or if the user selects the “After order is filled” checkbox in the “Settings/Properties” tab, the runtime system executes the script on _each available tick_ where the broker emulator fills an order, or once per bar when there is no order to fill.\n\nLet’s look at a simple example. The following strategy changes the direction of its simulated position on each execution. If there is an open short position or no position, the strategy places a market order to close all short trades and enter a long trade. If a long position is open, the strategy places a market order to close it and open a short trade.\n\nAs with the previous example, this script increments an executionNum variable declared with varip to count new executions, plots the result alongside bar\\_index for comparison, and highlights the background of historical bars in orange with bgcolor():\n\nPine Script®\nCopied\n\n//@version=6\nstrategy(\"Default strategy behavior on historical bars demo\")\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position_size <= 0\n    strategy.entry(\"Long\", strategy.long)\nelse\n    strategy.entry(\"Short\", strategy.short)\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the executionNum value.\nexecutionNum += 1\n// Display the executionNum and bar_index series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\n// Highlight the chart's background in translucent orange when barstate.ishistory is true.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\n\nNote that:\n\n- The strategy.entry() command creates entry orders. By default, a long entry using this command reverses an open short position, and a short entry reverses an open long position. See the Reversing positions section of the Strategies page to learn more.\n\nThe script above uses the default calculation behavior: it places a new order only at the close of each bar. The broker emulator fills the order at the next bar’s opening price, as the trade markers on the chart above indicate. The executionNum and bar\\_index plots show the same values because the script executes only once per bar.\n\nIf we include calc_on_order_fills = true in the strategy() declaration statement, the runtime system _re-executes_ the script on a bar after each new order fill to update the calculations. Our script’s logic generates a new order on _every_ execution, and the broker emulator considers historical bars to have _four ticks_ for filling orders by default (the open, high, low, and close). Therefore, with this change, the script executes four times per historical bar instead of only once. As shown below, the strategy now shows four trade markers on each historical bar, and the executionNum value is four times that of the bar\\_index variable:\n\nPine Script®\nCopied\n\n//@version=6\nstrategy(\"Calculation after order fill on historical bars demo\", calc_on_order_fills = true)\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position_size <= 0\n    strategy.entry(\"Long\", strategy.long)\nelse\n    strategy.entry(\"Short\", strategy.short)\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the executionNum value.\nexecutionNum += 1\n// Display the executionNum and bar_index series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\n// Highlight the chart's background in translucent orange when barstate.ishistory is true.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\n\nNote that:\n\n- This script can execute _more than four_ times per bar if it uses Bar Magnifier mode, because this mode enables the broker emulator to fill orders on historical bars using intrabar prices from a _lower timeframe_.\n- The script can execute numerous times on a _realtime_ bar, depending on the updates from the data feed, because _each new update_ to the bar is a valid tick for filling the strategy’s orders.\n- An alternative way to confirm the script’s increased execution count is to select and clear the “After order is filled” checkbox in the “Settings/Properties” tab while profiling the code.\n\nExecutions on realtime bars\n\nAfter a script running on the chart or in an alert executes across all historical bars in a dataset, the runtime system continues to execute the script on the current bar, if it is open, and on any new bars that form later. We refer to these bars as _realtime bars_, because they represent incoming data from a separate data feed that the script can access only _after_ it finishes loading.\n\nAs explained in the previous section, historical bars represent confirmed data points. By contrast, a realtime bar represents an initially _unconfirmed_ data point that evolves as new updates (ticks) arrive from the realtime data feed. With each new tick, the bar’s high, low, close, volume, and other values update to represent the latest data while the bar remains open. After the bar closes, it becomes an _elapsed realtime bar_, whose values no longer change. Then, a new realtime bar opens after another tick arrives, and that bar updates as new data becomes available.\n\nAs an indicator or library script runs on an open realtime bar, its compiled code executes once after every new update from the data feed. With each new execution, the script recalculates its results for that bar using the latest data. Consequently, the states of the script’s variables, expressions, and objects can _change_ with each new execution while the bar remains open. The system _commits_ the script’s data for the realtime bar only after the bar closes.\n\nAfter each script execution that occurs _before_ a bar’s closing tick, the runtime engine executes a _rollback_ process. Rollback _resets_ applicable script data to the latest committed states in the time series. This process enables the script to recalculate the bar’s results using only the latest available data — without the influence of _temporary_ data from executions on the bar’s previous ticks.\n\nBelow, we explain how recalculation and rollback affect a script’s data and outputs, along with some notable exceptions to this process:\n\nReinitialize variables\n\nThe runtime system erases the states of any variables that the script initializes during its executions before a bar’s close, excluding those declared using the varip keyword. When the script executes again after rollback, it _reinitializes_ the variables with new values or references based on the latest available data.\n\nLikewise, the system does not preserve the _temporary_ states of built-in variables that hold values for the current bar. Before the new script execution, it sets the variables to use the bar’s most recent data. For instance, the system updates close, high, and low with the latest, highest, and lowest prices reported since the bar’s opening time.\n\nReset changes to var variables\n\nVariables that use the var keyword in their declaration are initialized only _once_ — during the _first_ execution of their scopes on a _closed bar_. Variables that use the var keyword in their declaration remain initialized after the _first_ time that their scopes execute on a bar’s _closing tick_. Their assigned values or references _persist_ across subsequent bars, changing only after reassignment or compound assignment operations.\n\nAlthough these variables preserve data across successive bars, they do not preserve data across executions on the _ticks_ of an open bar. Rollback reverts all variables declared with var before the current bar to the last committed states in the time series as of the previous bar.\n\nFor instance, if a variable declared with var has a value of 20 on the open bar and 19 on the previous bar, the variable’s value reverts to 19 before the script executes on the next tick of the same bar. The temporary value of 20 does not persist.\n\nReplace plotted outputs\n\nThe plot*(), bgcolor(), barcolor(), and fill() functions create visual outputs on _every bar_. These outputs are _temporary_ on the open realtime bar. When the script executes again after rollback, the new outputs for the bar from calls to these functions _replace_ the ones from the previous tick.\n\nFor example, when the expression plot(close) executes on the open bar, it displays the bar’s latest close value as of the current execution. However, the plotted result is temporary until the bar closes. After rollback, the close variable updates, then the script calls plot() again on the next execution to replace the output from the previous tick and display the new value.\n\nRemove and revert objects\n\nUser-defined types (UDTs) and special types such as collections and drawing types are _reference types_. They define structures from which scripts create _objects_ — independent entities that store data elsewhere in memory. Variables of these types hold _references_ that provide access to specific objects and their data; the variables do not store objects directly.\n\nIf a script creates objects on an open bar and does not assign their references to variables declared with the varip keyword, the rollback process _removes_ those objects. During the next execution on the open bar, the script creates _new objects_ if the updated logic allows it.\n\nFor example, if a script calls label.new() to create a label object on the open bar, the system _deletes_ that object during rollback. On the next execution, the script evaluates label.new() again, creating a _new_ label that replaces the output. The label created on the previous tick no longer exists.\n\nSimilarly, for objects of built-in or user-defined types with references assigned to var variables, the rollback process reverts any changes to those objects that occur on the open bar. The only exception is for UDTs with _fields_ that include the varip keyword. See the Objects page for more information.\n\nExceptions\n\nThe runtime system does not revert _all_ the data from script executions on an open bar. The following are notable exceptions to the rollback process:\n\n- Variables or fields declared with the varip keyword do not revert to a previously committed state. They persist across _all_ script executions after initialization, even those on the ticks of an open realtime bar.\n- Logged messages in the Pine Logs pane do not disappear after rollback. The messages from any log.*() calls during executions on the ticks of realtime bars remain in the pane until the script reloads.\n- The data from strategy orders placed or filled on the ticks within a bar is not subject to rollback. If a strategy script creates orders or the broker emulator fills orders on an open bar, the data from those events persists.\n- Rollback does not erase logs for alerts from the “Alerts” menu. All messages from a script alert remain visible until the user restarts the alert.\n- Runtime errors from the system or the runtime.error() function completely _stop_ script executions. If an error occurs at any point while a script executes on an open bar, the system halts the script and does not revert the error after new updates from the data feed.\n\nLet’s inspect the behavior of a simple indicator on realtime bars. The following script calculates an RSI of close values using ta.rsi() and displays the result with a plot() call. To track the number of executions that occur _per bar_, the script increments an executions variable declared with varip and calculates its one-bar change using ta.change(). The script converts each bar’s execution count to a string with str.tostring(), then displays the result in a color-coded label at the bar’s high. The label is purple if the bar is open. Otherwise, it is gray. The script also highlights the background of realtime bars in orange using bgcolor():\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Executions on realtime bars demo\")\n//@variable The 14-bar RSI of close prices.\nfloat rsi = ta.rsi(close, 14)\n//@variable Tracks the number of script executions, where 1 represents the first execution.\nvarip int executions = 0\n// Add 1 to the executions value.\nexecutions += 1\n//@variable Is color.gray if the bar is confirmed (closed); color.purple otherwise.\ncolor labelColor = barstate.isconfirmed ? color.gray : color.purple\n// Calculate the one-bar change in executions, then convert the value to a string and display the result in a label.\n// Each call to label.new() creates a new label object.\nlabel.new(\n     bar_index, high, str.tostring(ta.change(executions)),\n     color = labelColor, textcolor = color.white, size = 20, force_overlay = true\n)\n// Plot the rsi value with colors based on whether the value is above 50 or not.\nplot(rsi, \"RSI\", rsi > 50 ? color.teal : color.maroon, 3)\n// Highlight the chart's background in translucent orange when barstate.isrealtime is true.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\", force_overlay = true)\n\nWhen we first add the script to the chart, it does _not_ add an orange background to any bar because it calculates only on data that exists at the script’s loading time. This data is _historical_. Each bar’s label shows a value of 1 because indicators always execute _once_ per historical bar:\n\nNotice the countdown timer and the _purple_ label for the latest bar in the chart above. These both indicate that the bar is _open_ and subject to changes. A new update from the data feed affects the bar’s values, triggering rollback and a new script execution to recalculate the results.\n\nWhen rollback occurs, the runtime system reverts the internal data of the ta.rsi() call to its last committed state, erases the state of the rsi variable, and deletes the latest label object. However, the system does not revert the executions variable because it uses the varip keyword.\n\nAfter rollback, the system updates the built-in close, high, and barstate.* variables using the current bar’s latest data, and the new execution begins. The script evaluates the ta.rsi() call using the new close price and reinitializes the rsi variable with the returned value. Then, it increases the executions value by one, evaluates ta.change() again, and creates a new label at the bar’s current high price to show the updated result. Lastly, it evaluates the plot() and bgcolor() calls to replace the bar’s plotted visuals. The last bar’s label remains purple because the bar is still open, but the background color is now _orange_ because barstate.isrealtime is true:\n\nAs subsequent updates become available from the data feed, the pattern of rollback and re-execution continues, and the script’s outputs for the bar update with each new execution:\n\nThe last time that rollback and another execution occur on this bar is after the _closing tick_, when the bar becomes an _elapsed_ realtime bar. After the final execution, the bar’s label is _gray_ because barstate.isconfirmed is true. The runtime system then _commits_ necessary data from this execution to the time series for calculations on future bars.\n\nThen, a new realtime bar opens after another update from the data feed, and the execution pattern continues:\n\nNote that:\n\n- Although the previous bar is now confirmed, it still has an orange background corresponding to a _realtime_ state because it closed after the script’s loading time. When the script later reloads after an execution-triggering event, that bar becomes _historical_.\n\nIt’s important to note that strategies often execute differently than indicators on realtime bars. By default, they execute only once per bar at each _closing tick_ without undergoing rollback. However, users can modify a strategy’s calculation behavior to allow rollback and re-execution on a bar before its closing tick.\n\nIf the strategy() statement includes calc_on_every_tick = true, or if the user selects the “On every tick” checkbox in the “Settings/Properties” tab, the script executes on a realtime bar after _each new update_ from the data feed, similar to an indicator.\n\nAdditionally, if the strategy() statement includes calc_on_order_fills = true or the user selects “After order is filled” in the “Settings/Properties” tab, the script executes on _each tick_ where the broker emulator fills an order. With this behavior, the system can execute the script multiple times on the open bar, but only on the ticks where an _order fill_ occurs.\n\nTo summarize the general process for script executions on realtime bars:\n\n- An indicator or library script executes on the _first available tick_ in an open realtime bar, then _once per update_ to recalculate the results for the bar using the latest data. A strategy script executes only on the bar’s _closing tick_ by default, but users can modify its calculation behavior to allow executions while the bar is open.\n- Before each new script execution on an open bar, the runtime system executes a _rollback_ process, which _reverts_ all applicable variables, expressions, and objects to their _last committed states_ as of the previous bar’s close.\n- After the script executes on an _elapsed_ realtime bar’s closing tick, the system _commits_ necessary data from that execution to the time series for access on later bars. It does not commit the data from executions on the bar’s _unconfirmed_ values from previous ticks.\n\nEvents that trigger script executions\n\nSeveral events cause a script to load and execute across all the available bars in a dataset. The specific events that trigger the loading process depend on where the script runs.\n\nFor a script on the chart, the following events always cause the script to load and perform _new executions_ on every bar:\n\n- The user adds the script to the chart for the first time from the Pine Editor or the “Indicators, metrics, and strategies” menu.\n- The user saves an update to the script while it is active on the chart.\n- The chart is refreshed while the script is active.\n\nOther events also trigger the loading process for a script on the chart. However, these events do not _always_ cause new script executions on past bars. The results from running a script with a unique combination of settings are often temporarily _cached_. If cached data exists for a selected combination of settings, the system loads the script using that data. See the Caching section for more information.\n\nBelow are the additional events that cause a script to load on the chart, either by performing new executions across the dataset or by using available cached data:\n\n- The user selects new values for the inputs or strategy properties in the script’s “Settings” menu.\n- The script uses the chart.left\\_visible\\_bar\\_time or chart.right\\_visible\\_bar\\_time variable, and the visible chart range changes.\n- The script uses the chart.fg\\_color or chart.bg\\_color variable, and the user changes the chart’s background color.\n- The chart loads a new dataset with a different _timeframe_ or _ticker identifier_. Several user actions affect a chart’s ticker ID, such as selecting a symbol from the “Symbol Search” menu, changing the chart type, toggling data modifications in the chart’s settings, and activating Bar Replay mode.\n- The user opens or closes the Pine Logs pane.\n- The user activates or deactivates the Pine Profiler.\n\nFor scripts used in other locations, the following events trigger the loading process:\n\n- The user creates a new script alert from the “Create Alert” dialog box.\n- The user pauses and restarts an alert instance from the “Alerts” menu.\n- The user clicks the “Generate report” button in the Strategy Tester while Deep Backtesting mode is enabled.\n- The user clicks the “Scan” button in the Pine Screener to run the script on the datasets from a chosen watchlist.\n\n_After_ a script loads, either of the following causes new script executions on an _open bar_:\n\n- One of the events above causes the script to load again and execute across the _entire dataset_ up to the bar.\n- The script runs on the chart or in an alert, and the bar updates after new data becomes available. The system performs _rollback_ and re-executes the script on that bar using the latest data. The only exception is if the script is a strategy that does not allow recalculation on the new tick.\n\nWhen a script completely reloads on the chart or in an alert after an applicable event, all the elapsed realtime bars from the script’s previous run become historical bars in the new run, because they represent _confirmed_ data points that the script accesses from _a different data feed_ as it loads.\n\nThe bars in a symbol’s dataset come from two distinct data feeds: the _historical_ feed and the _realtime_ feed. The historical feed reports only the _final_ values for each bar, whereas the realtime feed includes the _temporary_ values from all available ticks. When a realtime bar becomes historical after a script restarts, the values from the bar’s previous ticks are no longer accessible; only the final price, volume, and other values remain. Therefore, if a script relies on temporary data from realtime bars in its calculations, it might behave differently after reloading.\n\nFor example, the following script calculates the one-bar arithmetic return of the close series and displays the result as a line plot. On each realtime bar, the script updates three variables declared with varip to track the first, highest, and lowest return values calculated during executions across the bar’s ticks, then calls plotcandle() to plot a candle showing the values. Additionally, it uses bgcolor() to highlight the background of realtime bars in orange:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Reloading a script demo\", precision = 5)\n//@variable The one-bar arithmetic return of the close series.\nfloat priceReturn = ta.change(close, 1) / close[1]\n// Declare persistent variables to track the first, highest, and lowest priceReturn values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\nif barstate.isrealtime\n    // On the first tick in the realtime bar, reassign o, h, and l to hold the value of priceReturn.\n    if barstate.isnew\n        o := priceReturn\n        h := priceReturn\n        l := priceReturn\n    // Otherwise, reassign h and l to the bar's highest and lowest priceReturn value as of the current tick.\n    else\n        h := math.max(h, priceReturn)\n        l := math.min(l, priceReturn)\n// Plot candles to display the o, h, l, and priceReturn values for each realtime bar.\n// The candles do not appear on historical bars, because o, h, and l are na on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg_color, bordercolor = chart.fg_color)\n// Dispaly the priceReturn series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter the script loads on the chart and executes on several realtime bars, all the elapsed realtime bars, as well as the open realtime bar, include plotted return candles and an orange background color:\n\nAfter an applicable event, such as a chart refresh, the script _reloads_ and executes across the dataset again. All the closed bars with a realtime state in the previous run become _historical_ bars in the new run. The results thus change because our script relies on realtime data. As shown below, the script does not display candles or background colors for previous bars after we refresh the chart. Those outputs appear only for the latest bar, after new ticks become available, because that bar is now the only one with a realtime state:\n\nNote that:\n\n- The barstate.isnew variable has a value of true when a realtime bar opens, and false on all subsequent updates to the bar. If the script reloads midway through a realtime bar’s progression, only the background color appears on that bar. The script does not show a candle on the first realtime bar in that case, because its o, h, and l variables hold na until the first time that barstate.isnew is true.\n\nCaching\n\nWhen a script runs on a chart for the _first time_ using a _unique configuration_, the data from that run is often temporarily cached for reuse. The cached data is erased after the chart is refreshed or the user updates the script’s source code.\n\nIn this context, the configuration refers to the combined state of all script, chart, and developer tool settings that can affect the script’s executions. This combination includes:\n\n- The values of inputs in the script’s “Settings/Inputs” tab.\n- The values of the strategy properties in the “Settings/Properties” tab.\n- The values of the chart.* variables whose qualifiers are “input” ( chart.left\\_visible\\_bar\\_time, chart.right\\_visible\\_bar\\_time, chart.fg\\_color, and chart.bg\\_color).\n- The chart’s timeframe.\n- The chart’s ticker identifier.\n- Whether the Pine Logs pane is open or closed.\n- Whether the Pine Profiler is active or not.\n\nEach time that a script runs using a unique combination of settings, it executes from start to end on each bar in the dataset to perform new calculations. If possible, the script’s data from the run is then cached. If cached data is available on past bars for a selected combination of settings, the runtime system loads the script using that data.\n\nThis behavior enables users to change a script’s inputs, alter the chart, and toggle developer tools without losing information — including bar states — from previous script runs using different settings. Additionally, caching helps reduce loading times and resource requirements when switching between settings or adding multiple instances of the same script to the chart.\n\nTo understand this behavior, let’s revisit the script from the previous section. The script has different behaviors on historical and realtime bars. In the version below, we’ve added a lengthInput variable that holds the value from an input.int() call. The script uses this variable to define the length of the ta.change() calculation and the offset of the history-referencing operator:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Caching demo\", precision = 5)\n//@variable The bar span of the priceReturn calculation.\nint lengthInput = input.int(5, \"Length\", 1)\n//@variable The arithmetic return of the close series across lengthInput bars.\nfloat priceReturn = ta.change(close, lengthInput) / close[lengthInput]\n// Declare persistent variables to track the first, highest, and lowest priceReturn values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\nif barstate.isrealtime\n    // On the first tick in the realtime bar, reassign o, h, and l to hold the value of priceReturn.\n    if barstate.isnew\n        o := priceReturn\n        h := priceReturn\n        l := priceReturn\n    // Otherwise, reassign h and l to the bar's highest and lowest priceReturn value as of the current tick.\n    else\n        h := math.max(h, priceReturn)\n        l := math.min(l, priceReturn)\n// Plot candles to display the o, h, l, and priceReturn values for each realtime bar.\n// The candles do not appear on historical bars, because o, h, and l are na on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg_color, bordercolor = chart.fg_color)\n// Dispaly the priceReturn series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter we add the script to our 1m chart and let it run for a few minutes with a “Length” input value of 5, the script plots candles and highlights the background for the latest few bars, because barstate.isrealtime is true on those bars:\n\nLet’s change the “Length” input to a new value, causing the script to reload and execute across the dataset again. Here, we changed the value from 5 to 10 and let the script execute on some new ticks. The script no longer displays candles and background colors for the same bars after restarting, because it now accesses the data for those formerly realtime bars from the _historical_ data feed:\n\nAs shown above, the realtime bar information from the first run is _not available_ when we change the script’s input to a new value. However, the data from that previous run still exists in memory. If we revert the “Length” input’s value to 5, the candle plot and background colors start on the same bar as the first run:\n\nIf we add a second instance of the script to the chart, using the same settings, the runtime system loads the new instance using the cached data instead of executing it entirely from scratch. As such, its outputs are _identical_ to those from the first script instance, even though we added it to the chart a few bars later:\n\nSimilarly, cached data usually remains available even if we remove the script from our chart and add it again.\n\nTime series\n\nA symbol’s dataset is a form of _time series_ — a sequence of collected values indexed by time. Each bar represents a distinct data point, anchored to a specific time, that contains price and volume data for a particular period. This data format thus shows how a symbol’s values progress across time in successive periodic steps.\n\nPine Script’s internal time series structure follows a similar format. After executing a script on a closed bar’s confirmed values, the runtime system _commits (saves)_ the results of the script’s statements and expressions to internal time series for later use. Each bar with committed data has an assigned _index_ in the series, where 0 represents the first bar, 1 represents the second, and so on. Scripts can retrieve this index with the bar\\_index variable.\n\nScripts can access the data committed to the time series on past bars by using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The value between the operator’s square brackets specifies the position of the referenced bar in the time series as a _relative offset_ behind the current bar. For variables and expressions in the global scope, an offset value of 1 refers to the previous bar at bar_index - 1 (one bar back), a value of 2 refers to the bar at bar_index - 2 (two bars back), and so on. An offset of 0 always refers to the _current bar_.\n\nFor example, consider the open variable, which holds the opening price of the current bar on which the script executes. Before each script execution on a new bar, the runtime system commits the open value from the last execution on the previous bar. Then, it updates the variable to hold the current bar’s opening price. To access the committed open value for the previous bar, we can use the expression open[1]. To access the committed value from 10 bars back, we use open[10].\n\nThe script below performs three history-referencing operations to retrieve the current bar’s open value, the value from one bar back, and the value from a user-specified number of bars back. Then, it plots the retrieved values on the chart for comparison:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"History referencing demo\", overlay = true, behind_chart = false)\n//@variable The number of bars back from which to retrieve the open price for pastOpen.\nint offsetInput = input.int(10, \"Bar offset\", 0)\n//@variable The current bar's opening price. open[0] is equivalent to using open without the [] operator.\nfloat currOpen = open[0]\n//@variable The last committed open value. Represents the previous bar's value, or na if no previous bar exists.\nfloat prevOpen = open[1]\n//@variable The open value committed offsetInput bars back, or na if no bar exists at that offset.\nfloat pastOpen = open[offsetInput]\n// Plot currOpen, prevOpen, and pastOpen for comparison.\nplot(currOpen, \"Current open\",                 color.blue,    2)\nplot(prevOpen, \"Previous bar open\",            color.purple,  3)\nplot(pastOpen, \"Past open from custom offset\", color.orange,  4)\n\nNote that:\n\n- The expression open[0] is equivalent to using open without the history-referencing operator, because an offset of 0 refers to the current bar.\n- At the beginning of the chart’s dataset, the expressions open[1] and open[offsetInput] return na because they refer to previous bars that are unavailable.\n- Each history-referencing expression also leaves a trail of values in the time series. Therefore, it is possible to retrieve past states of the expression using another history-referencing operation, e.g., (open[offsetInput])[1].\n- Internally, the system maintains a _limited amount_ of time series data for variables and expressions in fixed-length _historical buffers_. These buffers define the _maximum offsets_ allowed for history-referencing operations. See the next section, Historical buffers, to learn more.\n\nAnother way that scripts use committed values from a time series is by calling the built-in functions that reference history internally, such as those in the ta.* namespace. For example, the expression ta.highest(high, 20) calculates the highest value from the high series over a 20-bar window. It compares the series’ current value to the committed values from the previous 19 bars to determine the result. The script below executes this call on each bar and plots the resulting series on the chart. Additionally, the script colors the background of the last 20 bars on the chart to highlight the bars used in the latest execution’s ta.highest() call:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"History referencing in functions demo\", overlay = true, behind_chart = false)\n//@variable The highest value from the high series across the 20 most recent bars.\n//          The ta.highest() call compares the current high to the last 19 committed values.\nfloat highest = ta.highest(high, 20)\n// Plot the highest series on the chart.\nplot(highest, \"20-bar high\", color.purple, 3)\n// Color the background of the last 20 bars, i.e., the bars used by the latest execution's ta.highest() call.\nbgcolor(color.new(color.blue, 70), show_last = 20, title = \"Last 20 bar highlight\")\n\nNote that:\n\n- The first 19 bars of the chart have a plotted value of na, because the ta.highest() function call requires the high values from the current bar and 19 previous bars to calculate the result.\n- All function calls and expressions that do not return “void” leave historical trails in the time series, just like variables. Therefore, scripts can use an expression such as ta.highest(high, 20)[10] to retrieve the 20-bar high from 10 bars back.\n- The ta.highest() function and other functions that access past values from a time series must execute in the global scope for consistent calculations. Time series storage for variables and expressions in local scopes works _differently_ than that for global values. See the Time series in scopes section for more information.\n\nHistorical buffers\n\nTo promote efficiency and help ensure computing resources remain available for all users, the Pine Script runtime system uses fixed-length _historical buffers_ to maintain a _limited amount_ of time series data for all variables and expressions. These historical buffers define the _maximum_ number of committed data points that a script can access on any bar via the history-referencing operator or the built-in functions that reference past bars internally.\n\nFor most series, the underlying historical buffer can contain data from up to 5000 past bars. The only exception is for some built-in series such as open, close, and time, whose buffers can store data for _more_ than 5000 bars.\n\nAlthough these buffers can contain thousands of data points at their maximum size, a script might not _require_ that much past data for its calculations on any bar. Therefore, the runtime system automatically optimizes the size of each series’ historical buffer based on the historical references that the script performs as it loads on the dataset. Each resulting buffer contains _only_ the amount of past data required by the script’s calculations and _not more_.\n\nFor instance, if the maximum number of bars back for which a script references the value of a variable on historical bars is 500, the system maintains a historical buffer that includes only the latest 500 committed values of that variable. The buffer does not store 5000 committed values, because the script _does not_ require all that extra data. This behavior thus helps to minimize a script’s resource requirements while preserving the integrity of its calculations.\n\nTo determine the sufficient buffer size for each variable and expression in a script, the runtime system performs the following process during the script’s loading time:\n\n1. It analyzes all the historical references that occur while executing the script on the dataset’s first 244 bars, then sets the initial size of each buffer to the minimum size that accommodates those references.\n2. While executing the script on subsequent bars, it checks if the script attempts to access data from previous bars that are beyond the limits of the defined buffers. If the script’s historical references exceed the buffer limits on any bar, the system restarts the loading process and tries a larger buffer size.\n3. In the rare case that a historical buffer’s size remains insufficient after several calculation attempts, the system stops the script and raises a runtime error.\n\nIt’s crucial to emphasize that the runtime system defines the sizes of all historical buffers only while executing a script on _historical bars_. It does not adjust any historical buffers during executions on _new bars_ from the realtime data feed. If a script references past data from beyond a historical buffer’s limits while executing on a realtime bar, it causes a runtime error.\n\nFor example, the script below retrieves a past value from the close series using the history-referencing operator with an offset of 100 bars back on historical bars and 150 bars back on realtime bars. Because the script references data from 100 bars back during all historical executions, the system sets the close buffer’s size to include only 100 past values. Consequently, an error occurs when the script executes on the open realtime bar, because a historical offset of 150 is _beyond_ the buffer’s limit:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Max bars back error demo\", overlay = true)\n// @variable The historical offset for retrieving past values from the close series.\n//           If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n// @variable The value of close from offset bars back.\n//           This code causes a runtime error on a realtime bar. During all code executions on historical bars,\n//           the script requires only the latest 100 past values of close, so the system sets the buffer size to\n//           include only the past 100 values. The offset of 150 is thus out of bounds.\nfloat pastClose = close[offset]\n// Plot the pastClose series.\nplot(pastClose, \"Past close\", chart.fg_color, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nFor cases like these, programmers can _manually_ set the size of a historical buffer to ensure it contains a sufficient amount of data by doing any of the following:\n\n- Modify the script to reference the maximum required number of bars back with the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) operator during its execution on the _first bar_.\n- Call the max\\_bars\\_back() function to explicitly set the historical buffer size for a _specific_ series.\n- Include a max_bars_back argument in the indicator() or strategy() declaration statement to set the initial size of _all_ historical buffers.\n\nBelow, we modified the script by including the expression max_bars_back(close, 150), which sets the size of the close buffer to include 150 past values. With the appropriate buffer size manually defined, the script’s history-referencing operation no longer causes an error on realtime bars:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Manual buffer sizing demo\", overlay = true)\n// @variable The historical offset for retrieving past values from the close series.\n//           If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n// Set the size of the close historical buffer to include 150 past values, ensuring the script has exactly\n// the amount of history that it requires on realtime bars.\nmax_bars_back(close, 150)\n// @variable The value of close from offset bars back.\n//           This code no longer causes an error when it executes on a realtime bar, because the historical\n//           buffer has an appropriate size defined in advance.\nfloat pastClose = close[offset]\n// Plot the pastClose series.\nplot(pastClose, \"Past close\", chart.fg_color, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nTime series in scopes\n\nThe _scope_ of a variable or expression refers to the part of the script where it is defined and accessible in the code. Every script has one _global_ scope and zero or more _local_ scopes.\n\nAll variables and expressions in a script that are outside user-defined functions or methods, conditional structures, loops, and user-defined type or enum type declarations belong to the _global scope_. The script evaluates variables and expressions from this scope _once_ for _every execution_ across bars and ticks in the dataset.\n\nAll functions, methods, conditional structures, and loops create their own _local scopes_. The variables and expressions defined within a local scope belong exclusively to that scope. In contrast to the global scope, a script does _not_ always evaluate a local scope once per execution; the script might evaluate the scope _zero_, _one_, or _several_ times per execution, depending on its logic.\n\nFor the runtime system to commit data from a variable or expression and queue that data into a historical buffer on any bar, a script must _evaluate_ the scope of that variable or expression once when it executes on the bar’s _closing tick_. If the script does not evaluate the scope, the runtime system _cannot_ update the historical buffer for the variable or expression. Similarly, if the script evaluates the scope repeatedly within a loop, the historical buffer cannot store series data for _each_ separate iteration, because each entry in the time series corresponds to a single bar.\n\nTherefore, time series behave differently in global and local scopes: the historical buffers for global variables and expressions _always_ contain committed data for _consecutive_ past bars, whereas the buffers for local variables often contain an inconsistent history of committed data.\n\nWhen a script references the history of a global variable using an expression such as myVariable[1], the historical offset of 1 always refers to the confirmed myVariable value from the _previous bar_. In contrast, when using such an expression with a local variable, the offset of 1 refers to the most recent bar where the script executed the scope. It does not represent a specific number of bars back. Therefore, referencing the history of a local variable can cause _unintended results_.\n\nThe following example demonstrates how the historical buffers for a user-defined function’s local scope behave when a script does not call the function on _every_ bar. The script below contains a custom upDownColor() function, which compares the current value of its source parameter to the last committed value ( source[1]). The function returns color.blue if the current source value is higher than the previous value. Otherwise, it returns color.orange.\n\nThe script uses this function _conditionally_, inside a ternary operation, to determine the color of a plot that shows the remainder from dividing bar\\_index by a specified value. If the remainder variable’s value is nonzero, the operation calls upDownColor(remainder) to calculate the color (blue or orange). If the value is 0, the operation does _not_ use the call and instead returns color.gray. The remainder value _increases_ on each bar, except for when it returns to 0 — causing the gray color. Therefore, a user might expect the plot’s color to be only blue or gray on every bar. However, the color changes to _orange_ on each bar after the one where the color is gray, even though the remainder value on that bar is _higher_ than the value on the previous bar:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Local historical references demo\")\n//@function  Returns color.blue if source is above its last committed value; color.orange otherwise.\n//           For consistent results, this function should execute on every bar, because it uses the\n//           history-referencing operator on the source series.\n//\n//           Even if the argument supplied to source comes from a global variable, the source parameter remains\n//           part of the function's local scope. The system maintains a separate historical buffer for the source\n//           series in each function call instance. The buffer contains only the committed source values from the bars\n//           where the function call occurs. If the call does not occur on a bar, the buffer for source contains\n//           no data for that bar.\nupDownColor(float source) =>\n    source > source[1] ? color.blue : color.orange\n//@variable The value by which to divide the bar_index value.\nint divisorInput = input.int(5, \"Divisor\", 1)\n//@variable The remainder of dividing bar_index by divisorInput.\nfloat remainder = bar_index % divisorInput\n//@variable Is color.orange if remainder equals 0, and the result of upDownColor(remainder) otherwise.\n//          The upDownColor() call does not execute on every bar. Therefore, it does not always compare the\n//          remainder value from one bar back to calculate the color. Instead, the function compares the current\n//          remainder to the value from the last bar where remainder is nonzero.\ncolor plotColor = remainder == 0 ? color.gray : upDownColor(remainder)\n// Plot the remainder series and color it using plotColor. The plot is orange after each bar where remainder == 0,\n// because the upDownColor() function call does not have data for that bar to use in its logic.\nplot(remainder, \"Remainder\", plotColor, 5)\n\nThe script behaves this way because upDownColor() uses the history-referencing operator on the source series, which is _local_ to the function’s scope, and the script does not call the function on _every_ execution. When the value of remainder is zero, the _first_ expression in the ternary condition evaluates to true, and therefore the second branch of the ternary expression, which contains the function call, does _not_ execute.\n\nThe compiler issues the following warning about the function directly in the Pine Editor:\n\n`\n\nThe function upDownColor() should be called on each calculation for consistency. It is recommended to extract the call from the ternary operator or from the scope.\n`\n\nThe runtime system maintains a separate historical buffer for the local source series, but it cannot update that buffer unless the script _calls_ the function. On each bar where remainder is 0, the call does not occur, and the system has no new value to commit to the time series. Therefore, the source buffer does _not_ contain the value of remainder, or even an na value, for that bar. On the bar that follows, the local expression source[1] refers to the source value from the last bar where the upDownColor() call occurs — _two bars back_ — and not the value of remainder from the previous bar. Because the value from two bars back is _higher_ than the current value, the returned color is color.orange instead of color.blue.\n\nWe can fix this script’s behavior by following the instructions in the compiler warning. Below, we modified the script by moving the upDownColor() call _outside_ the ternary expression, enabling the script to execute it on _every bar_. The historical buffer for the function’s source series now contains remainder values from _consecutive_ bars. With this change, an orange color does not appear because the function consistently compares values from _one_ bar back:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Consistent historical references demo\")\n//@function  Returns color.blue if source is above its last committed value; color.orange otherwise.\n//           For consistent results, this function should execute on every bar, because it uses the\n//           history-referencing operator on the source series.\nupDownColor(float source) =>\n    source > source[1] ? color.blue : color.orange\n//@variable The value by which to divide the bar_index value.\nint divisorInput = input.int(5, \"Divisor\", 1)\n//@variable The remainder of dividing bar_index by divisorInput.\nfloat remainder = bar_index % divisorInput\n//@variable Is color.blue if remainder is above its previous value, and color.orange otherwise.\ncolor secondColor = upDownColor(remainder)\n//@variable color.orange if remainder equals 0, and secondColor otherwise.\n//          This ternary operation no longer causes a warning. The scope of the upDownColor() call executes on\n//          every bar, meaning its historical buffer consistently includes data for consecutive past bars.\ncolor plotColor = remainder == 0 ? color.gray : secondColor\n// Plot the remainder series and color it using plotColor. The plot is now blue or gray, but never orange.\nplot(remainder, \"Remainder\", plotColor, 5)\n\nThis behavior also applies to all built-in functions that reference past values internally, such as those in the ta.* namespace. For example, the ta.sma() function uses the current value of a source series and length - 1 past values from that series to calculate a moving average. If a script calls this function only on _some_ bars instead of on _every_ bar, the historical buffer for source does not contain values for consecutive past bars. Therefore, such a call can cause unintended results, because the call calculates the returned average using an inconsistent history of values from previous bars.\n\nThe script below demonstrates how the results of the ta.sma() function can vary with the scope in which the function call occurs. The script declares three global variables to hold calculated SMA values: controlSMA, localSMA, and globalSMA. The script initializes controlSMA using the result of a ta.sma() function call, and it initializes the other two variables with na. Within the if structure, the script updates the value of globalSMA, and it updates localSMA using the result of another ta.sma() call with the same arguments as the first call.\n\nAs shown below, the controlSMA and globalSMA have the same value. Both use the result of the _global_ ta.sma() call, which executes on _every bar_. The internal historical buffer for source in that call thus includes committed values for consecutive past bars. In contrast, the localSMA value differs, because the ta.sma() call for that variable does _not_ execute on every bar. The buffer for that call’s local source series contains only the values from bars with an _even_ bar\\_index value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"ta.*() functions in scopes demo\", overlay = true, behind_chart = false)\n//@variable Is true if the bar_index is divisible by 2, and false otherwise.\nbool condition = bar_index % 2 == 0\n//@variable The 20-bar moving average of close values.\n//          This ta.sma() call executes in the global scope, so the script evaluates it on every bar.\nfloat controlSMA = ta.sma(close, 20)\n// Declare two additional variables to modify later within the if structure's scope.\nfloat globalSMA = na\nfloat localSMA  = na\nif condition\n    // Assign the controlSMA value to globalSMA. This code does not cause a warning.\n    globalSMA := controlSMA\n    // Call ta.sma() with the same arguments as before within this block and assign the result to localSMA.\n    // The function call causes a warning, because it does not execute in the global scope.\n    // The historical buffers for this ta.sma() call contain data only for the bars where condition is true,\n    // thus leading to a different result.\n    localSMA := ta.sma(close, 20)\n// Plot controlSMA, globalSMA, and localSMA for comparison.\nplot(controlSMA, \"Control SMA\", color.blue,   2)\nplot(globalSMA,  \"Global SMA\",  color.purple, 3, style = plot.style_circles)\nplot(localSMA,   \"Local SMA\",   color.gray,   3, style = plot.style_circles)\n`\n\nTo summarize the behavior of time series in a script’s scopes:\n\n- A script evaluates its global scope once on _every execution_. After each script execution on a bar’s closing tick, the system commits the data for variables and expressions in the global scope and updates their historical buffers. The resulting buffers thus include data for consecutive past bars, ensuring consistent results for operations and functions that rely on past data.\n- A script evaluates local scopes _zero_, _one_, or _several_ times per execution. The runtime system cannot maintain consistent bar-by-bar historical buffers for scopes that a script does _not_ evaluate on every bar, or for scopes that the script evaluates _more than once_ on a bar’s closing tick. Therefore, using the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) operator on local variables and expressions, or not calling functions that access past data once on each closing tick, can cause unintended results.\n\nNext\\\\\nType system",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "The function `upDownColor()` should be called on each calculation for consistency. It is recommended to extract the call from the ternary operator or from the scope."
    ]
  },
  "a749f6fc": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Loops\n\nIntroduction\n\nLoops are structures that repeatedly execute a block of statements based on specified criteria. They allow scripts to perform repetitive tasks without requiring duplicated lines of code. Pine Script® features three distinct loop types: for, while, and for…in.\n\nEvery loop structure in Pine Script consists of two main parts: a _loop header_ and a _loop body_. The loop header determines the criteria under which the loop executes. The loop body is the indented block of code ( local block) that the script executes on each loop cycle ( _iteration_) as long as the header’s conditions remain valid. See the Common characteristics section to learn more.\n\nUnderstanding when and how to use loops is essential for making the most of the power of Pine Script. Inefficient or unnecessary usage of loops can lead to suboptimal runtime performance. However, effectively using loops when necessary enables scripts to perform a wide range of calculations that would otherwise be impractical or impossible without them.\n\nWhen loops are unnecessary\n\nPine’s execution model and time series structure make loops _unnecessary_ in many situations.\n\nWhen a user adds a Pine script to a chart, it runs within the equivalent of a _large loop_, executing its code once on _every_ historical bar and realtime tick in the available data. Scripts can access the values from the executions on previous bars with the history-referencing operator, and calculated values can _persist_ across executions when assigned to variables declared with the var or varip keywords. These capabilities enable scripts to utilize bar-by-bar calculations to accomplish various tasks instead of relying on explicit loops.\n\nIn addition, several built-ins, such as those in the ta.* namespace, are internally optimized to eliminate the need to use loops for various calculations.\n\nLet’s consider a simple example demonstrating unnecessary loop usage in Pine Script. To calculate the average close over a specified number of bars, newcomers to Pine may write a code like the following, which uses a for loop to calculate the sum of historical values over lengthInput bars and divides the result by the lengthInput:\n\n//@version=6\nindicator(\"Unnecessary loops demo\", overlay = true)\n\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n\n//@variable The sum of \\close\\ values over \\lengthInput\\ bars.\nfloat closeSum = 0\n\n// Loop over the most recent \\lengthInput\\ bars, adding each bar's \\close\\ to the \\closeSum\\.\nfor i = 0 to lengthInput - 1\ncloseSum += close\\[i\\]\n\n//@variable The average \\close\\ value over \\lengthInput\\ bars.\nfloat avgClose = closeSum / lengthInput\n\n// Plot the \\avgClose\\.\nplot(avgClose, \"Average close\", color.orange, 2)\n\nUsing a for loop is an unnecessary, inefficient way to accomplish tasks like this in Pine. There are several ways to utilize the execution model and the available built-ins to eliminate this loop. Below, we replaced these calculations with a simple call to the ta.sma() function. This code is shorter, and it achieves the same result much more efficiently:\n\n//@version=6\nindicator(\"Unnecessary loops corrected demo\", overlay = true)\n\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n\n//@variable The average \\close\\ value over \\lengthInput\\ bars.\nfloat avgClose = ta.sma(close, lengthInput)\n\n// Plot the \\avgClose\\.\nplot(avgClose, \"Average close\", color.blue, 2)\n\nNote that:\n\n- Users can see the substantial difference in efficiency between these two example scripts by analyzing their performance with the Pine Profiler.\n\nWhen loops are necessary\n\nAlthough Pine’s execution model, time series, and available built-ins often eliminate the need for loops in many cases, not all iterative tasks have loop-free alternatives. Loops _are necessary_ for several types of tasks, including:\n\n- Iterating through or manipulating collections ( arrays, matrices, and maps)\n- Performing calculations that one cannot accomplish with loop-free expressions or the available built-ins\n- Looking back through history to analyze past bars with a reference value only available on the _current bar_\n\nFor example, a loop is _necessary_ to identify which past bars’ high values are above the current bar’s high because the current value is not obtainable during a script’s executions on previous bars. The script can only access the current bar’s value while it executes on that bar, and it must _look back_ through the historical series during that execution to compare the previous values.\n\nThe script below uses a for loop to compare the high values of lengthInput previous bars with the last historical bar’s high. Within the loop, it calls label.new() to draw a circular label above each past bar that has a high value exceeding that of the last historical bar:\n\n//@version=6\nindicator(\"Necessary loop demo\", overlay = true, max\\_labels\\_count = 500)\n\n//@variable The number of previous \\high\\ values to compare to the last historical bar's \\high\\.\nint lengthInput = input.int(20, \"Length\", 1, 500)\n\nif barstate.islastconfirmedhistory\n// Draw a horizontal line segment at the last historical bar's \\high\\ to visualize the level.\nline.new(bar\\_index - lengthInput, high, bar\\_index, high, color = color.gray, style = line.style\\_dashed, width = 2)\n// Create a \\for\\ loop that counts from 1 to \\lengthInput\\.\nfor i = 1 to lengthInput\n// Draw a circular \\label\\ above the bar from \\i\\ bars ago if that bar's \\high\\ is above the current \\high\\.\nif high\\[i\\] > high\nlabel.new(\nbar\\_index - i, na, \"\", yloc = yloc.abovebar, color = color.purple,\nstyle = label.style\\_circle, size = size.tiny\n)\n\n// Highlight the last historical bar.\nbarcolor(barstate.islastconfirmedhistory ? color.orange : na, title = \"Last historical bar highlight\")\n\nNote that:\n\n- Each _iteration_ of the for loop retrieves a previous bar’s high with the history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D), using the loop’s _counter_ ( i) as the historical offset. The label.new() call also uses the counter to determine each label’s x-coordinate.\n- The indicator declaration statement includes max_labels_count = 500, meaning the script can show up to 500 labels on the chart.\n- The script calls barcolor() to highlight the last historical chart bar, and it draws a horizontal line at that bar’s high for visual reference.\n\nCommon characteristics\n\nThe for, while, and for…in loop statements all have similarities in their structure, syntax, and general behavior. Before we explore each specific loop type, let’s familiarize ourselves with these characteristics.\n\nStructure and syntax\n\nIn any loop statement, programmers define the criteria under which a script remains in a loop and performs _iterations_, where an iteration refers to _one execution_ of the code within the loop’s local block ( _body_). These criteria are part of the _loop header_. A script evaluates the header’s criteria _before_ each iteration, only allowing new iterations to occur while they remain valid. When the header’s criteria are no longer valid, the script _exits_ the loop and skips over its body.\n\nThe specific header syntax varies with each loop statement ( for, while, or for…in) because each uses _distinct_ criteria to control its iterations. Effective use of loops entails choosing the structure with control criteria best suited for a script’s required tasks. See the \\for\\ loops, \\while\\ loops, and \\for…in\\ loops sections below for more information on each loop statement and its control criteria.\n\nAll loop statements in Pine Script follow the same general syntax:\n\n``\n\n[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere:\n\n- loop_header represents the loop structure’s header statement, which defines the criteria that control the loop’s iterations.\n- statements represents the code statements and expressions within the loop’s body, i.e., the _indented_ block of code beneath the loop header. All code within the body belongs to the loop’s local scope.\n- continue and break are loop-specific _keywords_ that control the flow of a loop’s iterations. The continue keyword instructs the script to _skip_ the remainder of the current loop iteration and _continue_ to the next iteration. The break keyword prompts the script to _stop_ the current iteration and _exit_ the loop entirely. See this section below for more information.\n- return_expression refers to the _last_ code line or block within the loop’s body. The loop returns the results from this code after the final iteration. If the loop skips parts of some iterations or stops prematurely due to a continue or break statement, the returned values or references are those of the latest iteration that evaluated this code. To use the loop’s returned results, assign them to a variable or tuple.\n- variables represents an optional variable or tuple to hold the values or references from the last evaluation of the return_expression. The script can assign the loop’s returned results to variables only if the results are not void. If the loop’s conditions prevent iteration, or if no iterations evaluate the return_expression, the variables’ assigned values and references are na.\n\nScope\n\nAll code lines that a script executes within a loop must have an indentation of _four spaces_ or a _tab_ relative to the loop’s header. The indented lines following the header define the loop’s _body_. This code represents a _local block_, meaning that all the definitions within the body are accessible only during the loop’s execution. In other words, the code within the loop’s body is part of its _local scope_.\n\nScripts can modify and reassign most variables from _outer_ scopes inside a loop. However, any variables declared within the loop’s body strictly belong to that loop’s local scope. A script cannot access a loop’s declared variables _outside_ its local block.\n\nNote that:\n\n- Variables declared within a loop’s _header_ are also part of the local scope. For instance, a script cannot use the _counter variable_ in a for loop anywhere but within the loop’s local block.\n\nThe body of any Pine loop statement can include conditional structures and _nested_ loop statements. When a loop includes nested structures, each structure within the body maintains a _distinct_ local scope. For example, variables declared within an _outer_ loop’s scope are accessible to an _inner_ loop. However, any variables declared within the inner loop’s scope are not accessible to the outer loop.\n\nThe simple example below demonstrates how a loop’s local scope works. This script calls label.new() within a for loop on the last historical bar to draw labels above lengthInput past bars. The color of each label depends on the labelColor variable declared _within_ the loop’s local block, and each label’s location depends on the loop counter ( i):\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\n\nif barstate.islastconfirmedhistory\nfor i = 1 to lengthInput\n//@variable Has a value of \\color.blue\\ if \\close\\[i\\]\\ is above the current \\close\\, \\color.orange\\ otherwise.\n// This variable is LOCAL to the \\for\\ loop's scope.\ncolor labelColor = close\\[i\\] > close ? color.blue : color.orange\n// Display a colored \\label\\ on the historical \\high\\ from \\i\\ bars back, using \\labelColor\\ to set the color.\nlabel.new(bar\\_index - i, high\\[i\\], \"\", color = labelColor, size = size.normal)\n\nIn the above code, the i and labelColor variables are only accessible to the for loop’s local scope. They are not usable within any outer scopes. Here, we added a label.new() call _after_ the loop with bar_index - i as the x argument and labelColor as the color argument. This code causes a _compilation error_ because neither i nor labelColor are valid variables in the outer scope:\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\n\nif barstate.islastconfirmedhistory\nfor i = 1 to lengthInput\n//@variable Has a value of \\color.blue\\ if \\close\\[i\\]\\ is above the current \\close\\, \\color.orange\\ otherwise.\n// This variable is LOCAL to the \\for\\ loop's scope.\ncolor labelColor = close\\[i\\] > close ? color.blue : color.orange\n// Display a colored \\label\\ on the historical \\high\\ from \\i\\ bars back, using \\labelColor\\ to set the color.\nlabel.new(bar\\_index - i, high\\[i\\], \"\", color = labelColor, size = size.normal)\n\n// Call \\label.new()\\ to using the \\i\\ and \\labelColor\\ variables outside the loop's local scope.\n// This code causes a compilation error because these variables are not accessible in this location.\nlabel.new(\nbar\\_index - i, low, \"Scope test\", textcolor = color.white, color = labelColor, style = label.style\\_label\\_up\n)\n\nKeywords and return expressions\n\nEvery loop in Pine Script implicitly _returns_ values, references, or void. A loop’s returned results come from the _latest_ execution of the _last_ expression or nested structure within its body as of the final iteration. The results are usable only if they are not of the void type. Loops return na results for values or references when no iterations occur. Scripts can add a variable or tuple assignment to a loop statement to hold the returned results for use in additional calculations outside the loop’s local scope.\n\nThe values or references that a loop returns usually come from evaluating the last written expression or nested code block on the _final_ iteration. However, a loop’s body can include continue and break keywords to control the flow of iterations beyond the criteria the loop header specifies, which can also affect the returned results. Programmers often include these keywords within conditional structures to control how iterations behave when certain conditions occur.\n\nThe continue keyword instructs a script to _skip_ the remaining statements and expressions in the current loop iteration, re-evaluate the loop header’s criteria, and proceed to the _next_ iteration. The script _exits_ the loop if the header’s criteria do not allow another iteration.\n\nThe break keyword instructs a script to _stop_ the loop entirely and immediately _exit_ at that point without allowing any subsequent iterations. After breaking the loop, the script skips any remaining code within the loop’s body and _does not_ re-evaluate the header’s criteria.\n\nIf a loop skips parts of iterations or stops prematurely due to a continue or break statement, it returns the values and references from the _last iteration_ where the script _evaluated_ the return expression. If the script did not evaluate the return expression across _any_ of the loop’s iterations, the loop returns na results for all non-void types.\n\nThe example below selectively displays numbers from an array within a label on the last historical bar. It uses a for…in loop to iterate through the array’s elements and build a “string” to use as the displayed text. The loop’s body contains an if statement that controls the flow of specific iterations. If the number in the current iteration is 8, the script immediately _exits_ the loop using the break keyword. Otherwise, if the number is even, it _skips_ the rest of the current iteration and moves to the next one using the continue keyword.\n\nIf neither of the if statement’s conditions occur, the script evaluates the _last expression_ within the loop’s body (i.e., the return expression), which converts the current number to a “string” and concatenates the result with the tempString value. The loop returns the _last evaluated result_ from this expression after termination. The script assigns the returned value to the finalLabelText variable and uses that variable as the text argument in the label.new() call:\n\n//@version=6\nindicator(\"Loop keywords and variable assignment demo\")\n\n//@variable An \\array\\ of arbitrary \"int\" values to selectively convert to \"string\" and display in a \\label\\.\nvar array<int> randomArray = array.from(1, 5, 2, -3, 14, 7, 9, 8, 15, 12)\n\n// Label creation logic.\nif barstate.islastconfirmedhistory\n//@variable A \"string\" containing representations of selected values from the \\randomArray\\.\nstring tempString = \"\"\n//@variable The final text to display in the \\label\\. The \\for..in\\ loop returns the result after it terminates.\nstring finalLabelText = for number in randomArray\n// Stop the current iteration and exit the loop if the \\number\\ from the \\randomArray\\ is 8.\nif number == 8\nbreak\n// Skip the rest of the current iteration and proceed to the next iteration if the \\number\\ is even.\nelse if number % 2 == 0\ncontinue\n// Convert the \\number\\ to a \"string\", append \", \", and concatenate the result with the current \\tempString\\.\n// This code represents the loop's return expression.\ntempString += str.tostring(number) + \", \"\n\n// Display the value of the \\finalLabelText\\ within a \\label\\ on the current bar.\nlabel.new(bar\\_index, 0, finalLabelText, color = color.blue, textcolor = color.white, size = size.huge)\n\nNote that:\n\n- The label displays only _odd_ numbers from the array because the script does not reassign the tempString when the loop iteration’s number is even. However, it does not include the _last_ odd number from the array (15) because the loop stops when number == 8, preventing iteration over the remaining randomArray elements.\n- When the script exits the loop due to the break keyword, the loop’s return value becomes the last evaluated result from the tempString reassignment expression. In this case, the last time that code executes is on the iteration where number == 9.\n\n​ for ​ loops\n\nThe for loop statement creates a _count-controlled_ loop, which uses a _counter_ variable to manage the iterative executions of its local code block. The counter starts at a predefined initial value, and the loop increments or decrements the counter by a fixed amount after each iteration. The loop stops its iterations after the counter reaches a specified final value.\n\nPine Script uses the following syntax to define a for loop:\n\n`\n\n[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the following parts define the _loop header_:\n\n- counter represents the counter variable, which can be any valid identifier. The loop increments or decrements this variable’s value from the initial value ( from_num) to the final value ( to_num) by a fixed amount ( step_num) after each iteration. The last possible iteration occurs when the variable’s value reaches the to_num value.\n- from_num is the counter variable’s initial value on the first iteration.\n- to_num is the _final_ counter value for which the loop’s header allows a new iteration. The loop adjusts the counter value by the step_num amount until it reaches or passes this value. If the script modifies the to_num during a loop iteration, the loop header uses the new value to control the allowed subsequent iterations.\n- step_num is a positive value representing the amount by which the counter value increases or decreases until it reaches or passes the to_num value. If the from_num value is greater than the _initial_ to_num value, the loop _subtracts_ this amount from the counter value after each iteration. Otherwise, the loop _adds_ this amount after each iteration. The default is 1.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThis simple script demonstrates a for loop that draws several labels at future bar indices during its execution on the last historical chart bar. The loop’s counter starts at 0, then increases by 1 until it reaches a value of 10, at which point the final iteration occurs:\n\n//@version=6\nindicator(\"Simple \\for\\ loop demo\")\n\nif barstate.islastconfirmedhistory\n// Define a \\for\\ loop that iterates from \\i == 0\\ to \\i == 10\\ by 1 (11 total iterations).\nfor i = 0 to 10\n// Draw a new label \\i\\ bars ahead of the current bar.\nlabel.new(bar\\_index + i, 0, str.tostring(i), textcolor = color.white, size = size.large)\n\nNote that:\n\n- The i variable represents the loop’s _counter_. This variable is local to the loop’s scope, meaning no _outer scopes_ can access it. The code uses the variable within the loop’s body to determine the location and text of each label drawing.\n- Programmers often use i, j, and k as loop counter identifiers. However, _any_ valid variable name is allowed. For example, this code behaves the same if we name the counter offset instead of i.\n- The for loop structure _automatically_ manages the counter variable. We do not need to define code in the loop’s body to increment its value.\n\nThe direction in which a for loop adjusts its counter depends on the _initial_ from_num and to_num values in the loop’s header, and the direction does not change across iterations. The loop counts _upward_ after each iteration when the to_num value is _above_ the from_num value, as shown in the previous example. If the to_num value is _below_ the from_num value, the loop counts _downward_ instead.\n\nThe script below calculates and plots the volume-weighted moving average (VWMA) of open prices across a specified number of bars. Then, it uses a downward-counting for loop to compare the last historical bar’s value to the values from previous bars, starting with the oldest bar in the specified lookback window. On each loop iteration, the script retrieves a previous bar’s vwmaOpen value, calculates the difference from the current bar’s value, and displays the result in a label at the past bar’s opening price:\n\n//@version=6\nindicator(\"\\for\\ loop demo\", \"VWMA differences\", true, max\\_labels\\_count = 500)\n\n//@variable Display color for indicator visuals.\nconst color DISPLAY\\_COLOR = color.rgb(17, 127, 218)\n\n//@variable The number of bars in the \\vwmaOpen\\ calculation.\nint maLengthInput = input.int(20, \"VWMA length\", 1)\n//@variable The number of past bars to look back through and compare to the current bar.\nint lookbackInput = input.int(15, \"Lookback length\", 1, 500)\n\n//@variable The volume-weighted moving average of \\open\\ values over \\maLengthInput\\ bars.\nfloat vwmaOpen = ta.vwma(open, maLengthInput)\n\nif barstate.islastconfirmedhistory\n// Define a \\for\\ loop that counts \\downward\\ from \\i == lookbackInput\\ to \\i == 1\\.\nfor i = lookbackInput to 1\n//@variable The difference between the \\vwmaOpen\\ from \\i\\ bars ago and the current \\vwmaOpen\\.\nfloat vwmaDifference = vwmaOpen\\[i\\] - vwmaOpen\n//@variable A \"string\" representation of \\vwmaDifference\\, rounded to two fractional digits.\nstring displayText = (vwmaDifference > 0 ? \"+\" : \"\") + str.tostring(vwmaDifference, \"0.00\")\n// Draw a label showing the \\displayText\\ at the \\open\\ of the bar from \\i\\ bars back.\nlabel.new(\nbar\\_index - i, open\\[i\\], displayText, textcolor = color.white, color = DISPLAY\\_COLOR,\nstyle = label.style\\_label\\_lower\\_right, size = size.normal\n)\n\n// Plot the \\vwmaOpen\\ value.\nplot(vwmaOpen, \"VWMA\", color = DISPLAY\\_COLOR, linewidth = 2)\n\nNote that:\n\n- The script uses the loop’s counter ( i) to within the history-referencing operator to retrieve past values of the vwmaOpen series. It also uses the counter to determine the location of each label drawing.\n- The loop in this example _decreases_ the counter by one on each iteration because the final counter value in the loop’s header ( 1) is less than the starting value ( lookbackInput).\n\nProgrammers can use for loops to iterate through collections, such as arrays and matrices. The loop’s counter can serve as an _index_ for retrieving or modifying a collection’s contents. For example, this code block uses array.get() inside a for loop to successively retrieve elements from an array:\n\nint lastIndex = array.size(myArray) - 1\nfor i = 0 to lastIndex\nelement = array.get(i)\n\nNote that:\n\n- Array _indexing_ starts from 0, but the array.size() function _counts_ array elements starting from 1. Therefore, we must subtract 1 from the array’s size to get the maximum index value. This way, the loop counter avoids representing an out-of-bounds index on the last loop iteration.\n- The for…in loop statement is often the _preferred_ way to loop through collections. However, programmers may prefer a for loop for some tasks, such as looping through stepped index values, iterating over a collection’s contents in reverse or a nonlinear order, and more. See the Looping through arrays and Looping through matrices sections to learn more about the best practices for looping through these collection types.\n\nThe script below executes ta.rsi() and ta.mom() calls to calculate the RSI and momentum of close prices over three different lengths (10, 20, and 50), then displays the results using a table on the last chart bar. It stores “string” values for the header title within arrays and the “float” values of the calculated indicators within a 2x3 matrix. The script uses a for loop to access the elements in the arrays and initialize the displayTable header cells. It then uses _nested_ for loops to iterate over the _row_ and _column_ indices in the taMatrix, access elements, convert their values to strings, and populate the remaining table cells:\n\n//@version=6\nindicator(\"\\for\\ loop with collections demo\", \"Table of TA Indexes\", overlay = true)\n\n// Calculate the RSI and momentum of \\close\\ values with constant lengths of 10, 20, and 50.\nfloat rsi10 = ta.rsi(close, 10)\nfloat rsi20 = ta.rsi(close, 20)\nfloat rsi50 = ta.rsi(close, 50)\nfloat mom10 = ta.mom(close, 10)\nfloat mom20 = ta.mom(close, 20)\nfloat mom50 = ta.mom(close, 50)\n\nif barstate.islast\n//@variable A \\table\\ that displays indicator values in the top-right corner of the chart.\nvar table displayTable = table.new(\nposition.top\\_right, columns = 5, rows = 4, border\\_color = color.black, border\\_width = 1\n)\n//@variable An array containing the \"string\" titles to display within the side header of each table row.\narray<string> sideHeaderTitles = array.from(\"TA Index\", \"RSI\", \"Momentum\")\n//@variable An array containing the \"string\" titles to representing the length of each displayed indicator.\narray<string> topHeaderTitles = array.from(\"10\", \"20\", \"50\")\n//@variable A matrix containing the values to display within the table.\nmatrix<float> taMatrix = matrix.new<float>()\n// Populate the \\taMatrix\\ with indicator values. The first row contains RSI data and the second contains momentum.\ntaMatrix.add\\_row(0, array.from(rsi10, rsi20, rsi50, mom10, mom20, mom50))\ntaMatrix.reshape(2, 3)\n\n// Initialize top header cells.\ndisplayTable.cell(1, 0, \"Bars Length\", text\\_color = color.white, bgcolor = color.blue)\ndisplayTable.merge\\_cells(1, 0, 3, 0)\n\n// Initialize additional header cells within a \\for\\ loop.\nfor i = 0 to 2\ndisplayTable.cell(0, i + 1, sideHeaderTitles.get(i), text\\_color = color.white, bgcolor = color.blue)\ndisplayTable.cell(i + 1, 1, topHeaderTitles.get(i), text\\_color = color.white, bgcolor = color.purple)\n\n// Use nested \\for\\ loops to iterate through the row and column indices of the \\taMatrix\\.\nfor i = 0 to taMatrix.rows() - 1\nfor j = 0 to taMatrix.columns() - 1\n//@variable The value stored in the \\taMatrix\\ at the \\i\\ row and \\j\\ column.\nfloat elementValue = taMatrix.get(i, j)\n// Initialize a cell in the \\displayTable\\ at the \\i + 2\\ row and \\j + 1\\ column showing a \"string\"\n// representation of the \\elementValue\\.\ndisplayTable.cell(\ncolumn = j + 1, row = i + 2, text = str.tostring(elementValue, \".\"), text\\_color = chart.fg\\_color\n)\n\nNote that:\n\n- Both arrays of header names ( sideHeaderTitles and topHeaderTitles) contain the same number of elements, enabling the script to iterate through their contents simultaneously using a single for loop.\n- The nested for loops iterate over _all_ the index values in the taMatrix. The _outer_ loop iterates over each _row_ index, and the _inner_ loop iterates over every _column_ index on each outer loop iteration.\n- The script creates and displays the table only on the last historical bar and all realtime bars because the historical states of tables are _never_ visible. See the Reducing drawing updates of the Profiling and optimization page for more information.\n\nIt’s important to note that a for loop’s header _dynamically_ evaluates the to_num value at the start of _every iteration_. If the to_num argument is a variable and the script changes its value during an iteration, the loop uses the _new value_ to update its stopping condition. Likewise, the stopping condition can change across iterations when the to_num argument is an expression or function call that depends on data modified in the loop’s scope, such as a call to array.size() on a locally resized array or str.length() on an adjusted string. Therefore, scripts can use for loops to perform iterative tasks where the exact number of required iterations is _not predictable_ in advance, similar to while loops.\n\nFor example, the following script uses a dynamic for loop to determine the historical offset of the most recent bar whose close differs from the current bar’s close by at least one standard deviation. The script declares a barOffset variable with an initial value of zero and uses that variable to define the loop counter’s to_num boundary. Within the loop’s scope, the script increments the barOffset by one if the referenced bar’s close is not far enough from the current bar’s value. Each time the barOffset value increases, the loop increases its final counter value, allowing an _extra iteration_. The script plots the barOffset and the corresponding bar’s close for visual reference:\n\n//@version=6\nindicator(\"\\for\\ loop with dynamic \\to\\_num\\ demo\")\n\n//@variable The length of the standard deviation.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n\n//@variable The standard deviation of \\close\\ prices over \\lengthInput\\ bars.\nfloat stdev = ta.stdev(close, lengthInput)\n\n//@variable The minimum bars back where the past bar's \\close\\ differs from the current \\close\\ by at least \\stdev\\.\n// Used as the weight value in the weighted average.\nint barOffset = 0\n\n// Define a \\for\\ loop that iterates from 0 to \\barsBack\\.\nfor i = 0 to barOffset\n// Add 1 for each bar where the distance from that bar's \\close\\ to the current bar's \\close\\ is less than \\stdev\\.\n// Each time \\barsBack\\ increases, it changes the loop's \\to\\_num\\ boundary, allowing another iteration.\nbarOffset += math.abs(close - close\\[i\\]) < stdev ? 1 : 0\n\n//@variable A gradient color for the \\barOffset\\ plot.\ncolor offsetColor = color.from\\_gradient(barOffset, 0, lengthInput, color.blue, color.orange)\n\n// Plot the \\barOffset\\ in a separate pane.\nplot(barOffset, \"Bar offset\", offsetColor, 1, plot.style\\_columns)\n// Plot the historical \\close\\ price from \\barOffset\\ bars back in the main chart pane.\nplot(close\\[barOffset\\], \"Historical bar's price\", color.blue, 3, force\\_overlay = true)\n\nNote that:\n\n- Changing the to_num value on an iteration does not affect the established _direction_ in which the loop adjusts its counter variable. For instance, if the loop in this example changed barOffset to -1 on any iteration, it would stop immediately after that iteration ends without reducing the i value.\n- The script uses force_overlay = true in the second plot() call to display the historical closing price on the main chart pane.\n\n​ while ​ loops\n\nThe while loop statement creates a _condition-controlled_ loop, which uses a _conditional expression_ to control the executions of its local block. The loop continues its iterations as long as the specified condition remains true.\n\nPine Script uses the following syntax to define a while loop:\n\n`\n\n[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the condition in the loop’s _header_ can be a literal, variable, expression, or function call that returns a “bool” value.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nA while loop’s header evaluates its condition before each iteration. Consequently, when the script modifies the condition within an iteration, the loop’s header reflects those changes on the _next_ iteration.\n\nDepending on the specified condition in the loop header, a while loop can behave similarly to a for loop, continuing iteration until a _counter_ variable reaches a specified limit. For example, the following script uses a for loop and while loop to perform the same task. Both loops draw a label displaying their respective counter value on each iteration:\n\n//@version=6\nindicator(\"\\while\\ loop with a counter condition demo\")\n\nif barstate.islastconfirmedhistory\n// A \\for\\ loop that creates blue labels displaying each \\i\\ value.\nfor i = 0 to 10\nlabel.new(\nbar\\_index + i, 0, str.tostring(i), color = color.blue, textcolor = color.white,\nsize = size.large, style = label.style\\_label\\_down\n)\n\n//@variable An \"int\" to use as a counter within a \\while\\ loop.\nint j = 0\n// A \\while\\ loop that creates orange labels displaying each \\j\\ value.\nwhile j <= 10\nlabel.new(\nbar\\_index + j, 0, str.tostring(j), color = color.orange, textcolor = color.white,\nsize = size.large, style = label.style\\_label\\_up\n)\n// Update the \\j\\ counter within the local block.\nj += 1\n\nNote that:\n\n- When a while loop uses count-based logic, it must explicitly manage the user-specified counter within the local block. In contrast, a for loop increments its counter automatically.\n- The script declares the variable the while loop uses as a counter _outside_ the loop’s scope, meaning its value is usable in additional calculations after the loop terminates.\n- If this code did not increment the j variable within the while loop’s body, the value would _never_ reach 10, meaning the loop would run _indefinitely_ until causing a runtime error.\n\nBecause a while loop’s execution depends on its condition remaining true, and the condition might not change on a specific iteration, the _precise_ number of expected iterations might not be knowable _before_ the loop begins. Therefore, while loops are often helpful in scenarios where the exact loop boundaries are _unknown_.\n\nThe script below tracks when the chart’s close crosses outside Keltner Channels with a user-specified length and channel width. When the price crosses outside the current bar’s channel, the script draws a box highlighting all the previous _consecutive_ bars with close values within that price window. The script uses a while loop to analyze past bars’ prices and incrementally adjust the left side of each new box until the drawing covers all the latest consecutive bars in the current range:\n\n//@version=6\nindicator(\"\\while\\ loop demo\", \"Price window boxes\", true)\n\n//@variable The length of the channel.\nint lengthInput = input.int(20, \"Channel length\", 1, 4999)\n//@variable The width multiplier of the channel.\nfloat widthInput = input.float(2.0, \"Width multiplier\", 0)\n\n//@variable The \\lengthInput\\-bar EMA of \\close\\ prices.\nfloat ma = ta.ema(close, lengthInput)\n//@variable The \\lengthInput\\-bar ATR, multiplied by the \\widthInput\\.\nfloat atr = ta.atr(lengthInput) \\* widthInput\n//@variable The lower bound of the channel.\nfloat channelLow = ma - atr\n//@variable The upper bound of the channel.\nfloat channelHigh = ma + atr\n\n//@variable Is \\true\\ when the \\close\\ price is outside the current channel range, \\false\\ otherwise.\nbool priceOutsideChannel = close < channelLow or close > channelHigh\n\n// Check if the \\close\\ crossed outside the channel range, then analyze the past bars within the current range.\nif priceOutsideChannel and not priceOutsideChannel\\[1\\]\n//@variable A box that highlights consecutive past bars within the current channel's price window.\nbox windowBox = box.new(\nbar\\_index, channelHigh, bar\\_index, channelLow, border\\_width = 2, bgcolor = color.new(color.gray, 85)\n)\n//@variable The lookback index for box adjustment. The \\while\\ loop increments this value on each iteration.\nint i = 1\n// Use a \\while\\ loop to look backward through close\\ prices. The loop iterates as long as the past \\close\\\n// from \\i\\ bars ago is between the current bar's \\channelLow\\ and \\channelHigh\\.\nwhile close\\[i\\] >= channelLow and close\\[i\\] <= channelHigh\n// Adjust the left side of the box.\nwindowBox.set\\_left(bar\\_index - i)\n// Add 1 to the \\i\\ value to check the \\close\\ from the next bar back on the next iteration.\ni += 1\n\n// Plot the \\channelLow\\ and \\channelHigh\\ for visual reference.\nplot(channelLow, \"Channel low\")\nplot(channelHigh, \"Channel high\")\n\nNote that:\n\n- The left and right edges of boxes sit within the horizontal _center_ of their respective bars, meaning that each drawing spans from the middle of the first consecutive bar to the middle of the last bar within each window.\n- This script uses the i variable as a history-referencing index within the _conditional expression_ the while loop checks on each iteration. The variable does not behave as a loop counter, as the iteration boundaries are unknown. The loop executes its local block repeatedly until the condition becomes false.\n\n​ for...in ​ loops\n\nThe for…in loop statement creates a _collection-controlled_ loop, which uses the _contents_ of a collection to control its iterations. This loop structure is often the preferred approach for looping through arrays, matrices, and maps.\n\nA for…in loop traverses a collection _in order_, retrieving one of its stored items on each iteration. Therefore, the loop’s boundaries depend directly on the number of _items_ ( array _elements_, matrix _rows_, or map _key-value pairs_).\n\nPine Script features _two_ general forms of the for…in loop statement. The _first form_ uses the following syntax:\n\n``\n\n[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere item is a _variable_ that holds sequential values or references from the specified collection_id. The variable starts with the collection’s _first item_ and takes on successive items in order after each iteration. This form is convenient when a script must access values from an array or matrix iteratively but does not require the item’s _index_ in its calculations.\n\nThe _second form_ has a slightly different syntax that includes a tuple in its _header_:\n\n`\n\n[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere index is a variable that contains the _index_ or _key_ of the retrieved item. This form is convenient when a task requires using a collection’s items _and_ their indices in iterative calculations. This form of the for…in loop is _required_ when directly iterating through the contents of a map. See this section below for more information.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThe iterative behavior of a for…in loop depends on the _type_ of collection the header specifies as the collection_id:\n\n- When using an array in the header, the loop performs _element-wise_ iteration, meaning the retrieved item on each iteration is one of the array’s _elements_.\n- When using a matrix in the header, the loop performs _row-wise_ iteration, which means that each item represents a _row array_.\n- When using a map in the header, the loop performs _pair-wise_ iteration, which retrieves a _key_ and corresponding _value_ on each iteration.\n\nLooping through arrays\n\nPine scripts can iterate over the elements of arrays using any loop structure. However, the for…in loop is typically the most convenient because it automatically verifies the size of an array when controlling iterations. With other loop structures, programmers must carefully set the header’s boundaries or conditions to _prevent_ the loop from attempting to access an element at a _nonexistent_ index.\n\nFor example, a for loop can access an array’s elements using the counter variable as the lookup index in functions such as array.get(). However, programmers must ensure the counter always represents a _valid index_ to prevent out-of-bounds errors. Additionally, if an array might be _empty_, programmers must set conditions to prevent the loop’s execution entirely.\n\nThe code below shows a for loop whose counter boundaries depend on the number of elements in an array. If the array is empty, containing zero elements, the header’s final counter value is na, which _prevents_ iteration. Otherwise, the final value is _one less_ than the array’s size (i.e., the index of the last element):\n\nfor index = 0 to (array.size(myArray) == 0 ? na : array.size(myArray) - 1)\nelement = array.get(myArray, index)\n\nIn contrast, a for…in loop automatically validates an array’s size and _directly_ accesses its elements, providing a more convenient solution than a traditional for loop. The line below achieves the _same effect_ as the code above without requiring the programmer to define boundaries explicitly or use the array.get() function to access each element:\n\nfor element in myArray\n\nThe following example examines bars on a lower timeframe to gauge the strength of _intrabar_ trends within each chart bar. The script uses a request.security\\_lower\\_tf() call to retrieve an array of intrabar hl2 prices from a calculated lowerTimeframe. Then, it uses a for…in loop to access each price within the intrabarPrices array and compare the value to the current close to calculate the bar’s strength. The script plots the strength as columns in a separate pane:\n\n//@version=6\nindicator(\"\\for element in array\\ demo\", \"Intrabar strength\")\n\n//@variable A valid timeframe closest to one-tenth of the current chart's timeframe, \"1\" if the timeframe is too small.\nvar string lowerTimeframe = timeframe.from\\_seconds(math.max(int(timeframe.in\\_seconds() / 10), 60))\n//@variable An array of intrabar \\hl2\\ prices calculated from the \\lowerTimeframe\\.\narray<float> intrabarPrices = request.security\\_lower\\_tf(\"\", lowerTimeframe, hl2)\n\n//@variable The excess trend strength of \\intrabarPrices\\.\nfloat strength = 0.0\n\n// Loop directly through the \\intrabarPrices\\ array. Each iteration's \\price\\ represents an array element.\nfor price in intrabarPrices\n// Subtract 1 from the \\strength\\ if the retrieved \\price\\ is above the current bar's \\close\\ price.\nif price > close\nstrength -= 1\n// Add 1 to the \\strength\\ if the retrieved \\price\\ is below the current bar's \\close\\ price.\nelse if price < close\nstrength += 1\n\n//@variable Is \\color.teal\\ when the \\strength\\ is positive, \\color.maroon\\ otherwise.\ncolor strengthColor = strength > 0 ? color.teal : color.maroon\n\n// Plot the \\strength\\ as columns colored by the \\strengthColor\\.\nplot(strength, \"Intrabar strength\", strengthColor, 1, plot.style\\_columns)\n\nThe second form of the for…in loop is a convenient solution when a script’s calculations require accessing each element _and_ corresponding index within an array:\n\nfor \\[index, element\\] in myArray\n\nFor example, suppose we want to display a _numerated_ list of array elements within a label while excluding values at specific indices. We can use the second form of the for…in loop structure to accomplish this task. The simple script below declares a stringArray variable that references an array of predefined “string” values. On the last historical bar, the script uses a for…in loop to access each index and element in the stringArray to construct the labelText, which it uses in a label.new() call after the loop ends:\n\n//@version=6\nindicator(\"\\for \\[index, item\\] in array\\ demo\", \"Array numerated output\")\n\n//@variable An array of \"string\" values to display as a numerated list.\nvar array<string> stringArray = array.from(\"First\", \"Second\", \"Third\", \"Before Last\", \"Last\")\n\nif barstate.islastconfirmedhistory\n//@variable A \"string\" modified within a loop to display within the \\label\\.\nstring labelText = \"Array values: \\\\n\"\n// Loop through the \\stringArray\\, accessing each \\index\\ and corresponding \\element\\.\nfor \\[index, element\\] in stringArray\n// Skip the third \\element\\ (at \\index == 2\\) in the \\labelText\\. Include an \"ELEMENT SKIPPED\" message instead.\nif index == 2\nlabelText += \"-- ELEMENT SKIPPED -- \\\\n\"\ncontinue\nlabelText += str.tostring(index + 1) + \": \" + element + \"\\\\n\"\n// Display the \\labelText\\ within a \\label\\.\nlabel.new(\nbar\\_index, 0, labelText, textcolor = color.white, size = size.huge,\nstyle = label.style\\_label\\_center, textalign = text.align\\_left\n)\n\nNote that:\n\n- This example adds 1 to the index in the str.tostring() call to start the numerated list with a value of \"1\", because array indices always begins at 0.\n- On the _third_ loop iteration, when index == 2, the script adds an \"-- ELEMENT SKIPPED --\" message to the labelText instead of the retrieved element and uses the continue keyword to skip the remainder of the iteration. See this section above to learn more about loop keywords.\n\nLet’s explore an advanced example demonstrating the utility of for…in loops. The following indicator draws a fixed number of horizontal lines at pivot high values calculated from a ta.pivothigh() call, and it analyzes the lines within a loop to determine which ones represent active ( _uncrossed_) pivots.\n\nEach time the script detects a new pivot high point, it creates a new line, _inserts_ that line at the beginning of the pivotLines array, then removes the oldest element and deletes its ID. The script accesses each line within the array using a for…in loop, analyzing and modifying the properties of the line referenced on each iteration. When the current high crosses above the pivotLine, the script changes its style to signify that it is no longer an active level. Otherwise, it extends the line’s x2 coordinate and uses its price to calculate the average _active_ pivot value. The script also plots each pivot high value and the average active pivot value on the chart:\n\n//@version=6\nindicator(\"\\for...in\\ loop with arrays demo\", \"Active high pivots\", true, max\\_lines\\_count = 500)\n\n//@variable The number of bars required on the left and right to confirm a pivot point.\nint pivotBarsInput = input.int(5, \"Pivot leg length\", 1)\n//@variable The number of recent pivot lines to analyze. Controls the size of the \\pivotLines\\ array.\nint maxRecentLines = input.int(20, \"Maximum recent lines\", 1, 500)\n\n//@variable An array that acts as a queue holding the most recent pivot high lines.\nvar array<line> pivotLines = array.new<line>(maxRecentLines)\n//@variable The pivot high price, or \\na\\ if no pivot is found.\nfloat highPivotPrice = ta.pivothigh(pivotBarsInput, pivotBarsInput)\n\nif not na(highPivotPrice)\n//@variable The \\chart.point\\ for the start of the line. Does not contain \\time\\ information.\nfirstPoint = chart.point.from\\_index(bar\\_index - pivotBarsInput, highPivotPrice)\n//@variable The \\chart.point\\ for the end of each line. Does not contain \\time\\ information.\nsecondPoint = chart.point.from\\_index(bar\\_index, highPivotPrice)\n//@variable A horizontal line at the new pivot level.\nline hiPivotLine = line.new(firstPoint, secondPoint, width = 2, color = color.green)\n// Insert the \\hiPivotLine\\ at the beginning of the \\pivotLines\\ array.\npivotLines.unshift(hiPivotLine)\n// Remove the oldest line from the array and delete its ID.\nline.delete(pivotLines.pop())\n\n//@variable The sum of active pivot prices.\nfloat activePivotSum = 0.0\n//@variable The number of active pivot high levels.\nint numActivePivots = 0\n\n// Loop through the \\pivotLines\\ array, directly accessing each \\pivotLine\\ element.\nfor pivotLine in pivotLines\n//@variable The \\x2\\ coordinate of the \\pivotline\\.\nint lineEnd = pivotLine.get\\_x2()\n// Move to the next \\pivotline\\ in the array if the current line is inactive.\nif pivotLine.get\\_x2() < bar\\_index - 1\ncontinue\n//@variable The price value of the \\pivotLine\\.\nfloat pivotPrice = pivotLine.get\\_price(bar\\_index)\n// Change the style of the \\pivotLine\\ and stop extending its display if the \\high\\ is above the \\pivotPrice\\.\nif high > pivotPrice\npivotLine.set\\_color(color.maroon)\npivotLine.set\\_style(line.style\\_dotted)\npivotLine.set\\_width(1)\ncontinue\n// Extend the \\pivotLine\\ and add the \\pivotPrice\\ to the \\activePivotSum\\ when the loop allows a full iteration.\npivotLine.set\\_x2(bar\\_index)\nactivePivotSum += pivotPrice\nnumActivePivots += 1\n\n//@variable The average active pivot high value.\nfloat avgActivePivot = activePivotSum / numActivePivots\n\n// Plot crosses at the \\highPivotPrice\\, offset backward by the \\pivotBarsInput\\.\nplot(highPivotPrice, \"High pivot marker\", color.green, 3, plot.style\\_cross, offset = -pivotBarsInput)\n// Plot the \\avgActivePivot\\ as a line with breaks.\nplot(avgActivePivot, \"Avg. active pivot\", color.orange, 3, plot.style\\_linebr)\n\nNote that:\n\n- The loop in this example executes on _every bar_ because it has to compare active pivot line prices with the current high value, then use the remaining active prices to calculate the bar’s avgActivePivot value.\n- Pine Script features several ways to calculate averages, many of which _do not_ require a loop. However, a loop is necessary in this example because the script uses information only available on the current bar to determine which prices contribute toward the average.\n- The _first_ form of the for…in loop is the most convenient option in this example because we need direct access to the lines referenced within the pivotLines array, but we do not need the corresponding _index_ values.\n\nLooping through matrices\n\nPine scripts can iterate over the contents of a matrix in several different ways. Unlike arrays, matrices use _two_ indices to reference their elements because they store data in a _rectangular_ format. The first index refers to _rows_, and the second refers to _columns_. If a programmer opts to use for or while loops to iterate through matrices instead of using for…in, they must carefully define the loop boundaries or conditions to avoid out-of-bounds errors.\n\nThis code block shows a for loop that performs _row-wise_ iteration, looping through each _row index_ in a matrix and using the value in a matrix.row() call to retrieve a row array. If the matrix is empty, the loop statement uses a final loop counter value of na to _prevent_ iteration. Otherwise, the final counter is the last row index, which is _one less_ than the value returned by matrix.rows():\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\nrowArray = myMatrix.row(rowIndex)\n\nNote that:\n\n- If we replace the matrix.rows() and matrix.row() calls with matrix.columns() and matrix.col(), the loop performs _column-wise_ iteration instead.\n\nThe for…in loop statement is the more convenient approach to loop over and access the rows of a matrix in order, as it automatically validates the number of rows and retrieves an array of the current row’s elements on each iteration:\n\nfor rowArray in myMatrix\n\nWhen a script’s calculations require access to each row from a matrix and its corresponding _index_, programmers can use the second form of the for…in loop:\n\nfor \\[rowIndex, rowArray\\] in myMatrix\n\nNote that:\n\n- The for…in loop only performs row-wise iteration on matrices. To _emulate_ column-wise iteration, programmers can use a for…in loop on a transposed copy.\n\nThe following example creates a custom string representing the rows of a matrix with extra information. When the script executes on the last historical bar, it creates a 3x3 matrix populated with values from math.random() calls. Using the first form of the for…in loop, the script iterates through each row in the matrix to create a “string” value representing the row’s contents, its average, and whether the average is above 0.5. Before the end of each iteration, the script concatenates the constructed string with the labelText value. After the loop ends, the script creates a label to display the labelText variable’s final value:\n\n//@version=6\nindicator(\"\\for row in matrix\\ demo\", \"Custom matrix label\")\n\n//@variable Generates a random value between 0 and 1, rounded to 4 decimal places.\nrand() =>\nmath.round(math.random(), 4)\n\nif barstate.islastconfirmedhistory\n//@variable A matrix of randomized values to format and display in a \\label\\.\nmatrix<float> randomMatrix = matrix.new<float>()\n// Add a row of 9 randomized values and reshape the matrix to 3x3.\nrandomMatrix.add\\_row(\n0, array.from(rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand())\n)\nrandomMatrix.reshape(3, 3)\n\n//@variable A custom \"string\" representation of \\randomMatrix\\ information. Modified within a loop.\nstring labelText = \"Matrix rows: \\\\n\"\n\n// Loop through the rows in the \\randomMatrix\\.\nfor row in randomMatrix\n//@variable The average element value within the \\row\\.\nfloat rowAvg = row.avg()\n//@variable An upward arrow when the \\rowAvg\\ is above 0.5, a downward arrow otherwise.\nstring directionChar = rowAvg > 0.5 ? \"⬆\" : \"⬇\"\n// Add a \"string\" representing the \\row\\ array, its average, and the \\directionChar\\ to the \\labelText\\.\nlabelText += str.format(\"Row: {0} Avg: {1} {2}\\\\n\", row, rowAvg, directionChar)\n\n// Draw a \\label\\ displaying the \\labelText\\ on the current bar.\nlabel.new(\nbar\\_index, 0, labelText, color = color.purple, textcolor = color.white, size = size.huge,\nstyle = label.style\\_label\\_center, textalign = text.align\\_left\n)\n\nWorking with matrices often entails iteratively accessing their _elements_, not just their rows and columns, typically using _nested loops_. For example, this code block uses an outer for loop to iterate over row indices. The inner for loop iterates over column indices on _each_ outer loop iteration and calls matrix.get() to access an element:\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\nfor columnIndex = 0 to myMatrix.columns() - 1\nelement = myMatrix.get(rowIndex, columnIndex)\n\nAlternatively, a more convenient approach for this type of task is to use nested for…in loops. The outer for…in loop in this code block retrieves each row array in a matrix, and the inner for…in statement loops through that array:\n\nfor rowArray in myMatrix\nfor element in rowArray\n\nThe script below creates a 3x2 matrix, then accesses and modifies its elements within nested for…in loops. Both loops use the second form of the for…in statement to retrieve index values and corresponding items. The outer loop accesses a row index and row array from the matrix. The inner loop accesses each index and respective element from that array.\n\nWithin the nested loop’s iterations, the script converts each element to a “string” and initializes a table cell at the rowIndex row and colIndex column. Then, it uses the loop header variables within matrix.set() to update the matrix element. After the outer loop terminates, the script displays a “string” representation of the _updated_ matrix within a label:\n\n//@version=6\nindicator(\"Nested \\for...in\\ loops on matrices demo\")\n\nif barstate.islastconfirmedhistory\n//@variable A matrix containing numbers to display.\nmatrix<float> displayNumbers = matrix.new<float>()\n// Populate the \\displayNumbers\\ matrix and reshape to 3x2.\ndisplayNumbers.add\\_row(0, array.from(1, 2, 3, 4, 5, 6))\ndisplayNumbers.reshape(3, 2)\n\n//@variable A table that displays the elements of the \\displayNumbers\\ before modification.\ntable displayTable = table.new(\nposition = position.middle\\_center, columns = displayNumbers.columns(), rows = displayNumbers.rows(),\nbgcolor = color.purple, border\\_color = color.white, border\\_width = 2\n)\n\n// Loop through the \\displayNumbers\\, retrieving the \\rowIndex\\ and the current \\row\\.\nfor \\[rowIndex, row\\] in displayNumbers\n// Loop through the current \\row\\ on each outer loop iteration to retrieve the \\colIndex\\ and \\element\\.\nfor \\[colIndex, element\\] in row\n// Initialize a table cell at the \\rowIndex\\ row and \\colIndex\\ column displaying the current \\element\\.\ndisplayTable.cell(column = colIndex, row = rowIndex, text = str.tostring(element),\ntext\\_color = color.white, text\\_size = size.huge\n)\n// Update the \\displayNumbers\\ value at the \\rowIndex\\ and \\colIndex\\.\ndisplayNumbers.set(rowIndex, colIndex, math.round(math.exp(element), 3))\n\n// Draw a \\label\\ to display a \"string\" representation of the updated \\displayNumbers\\ matrix.\nlabel.new(\nx = bar\\_index, y = 0, text = \"Matrix now modified: \\\\n\" + str.tostring(displayNumbers), color = color.orange,\ntextcolor = color.white, size = size.huge, style = label.style\\_label\\_up\n)\n\nLooping through maps\n\nThe for…in loop statement is the primary, most convenient approach for iterating over the data within Pine Script maps.\n\nUnlike arrays and matrices, maps are _unordered collections_ that store data in _key-value pairs_. Rather than traversing an internal lookup index, a script references the _keys_ from the pairs within a map to access its _values_. Therefore, when looping through a map, scripts must perform _pair-wise_ iteration, which entails retrieving key-value pairs across iterations rather than indexed elements or rows.\n\nNote that:\n\n- Although maps are unordered collections, Pine Script internally tracks the _insertion order_ of their key-value pairs.\n\nOne way to access the data from a map is to use the map.keys() function, which returns an array containing all the _keys_ from the map, sorted in their insertion order. A script can use the for…in structure to loop through the array of keys and call map.get() to retrieve corresponding values:\n\nfor key in myMap.keys()\nvalue = myMap.get(key)\n\nHowever, the more convenient, _recommended_ approach is to loop through a map directly _without_ creating new arrays. To loop through a map directly, use the second form of the for…in loop statement. Using this loop with a map creates a tuple containing a _key_ and respective _value_ on each iteration. As when looping through a map.keys() array, this _direct_ for…in loop iterates through a map’s contents in their insertion order:\n\nfor \\[key, value\\] in myMap\n\nNote that:\n\n- The second form of the for…in loop is the only way to iterate _directly_ through a map. A script cannot directly loop through this collection type without retrieving a key and value on each iteration.\n\nLet’s consider a simple example demonstrating how a for…in loop works on a map. When the script below executes on the last historical bar, it declares a simpleMap variable to reference a map of “string” keys and “float” values. The script uses map.put() to insert the keys from the newKeys array into the collection with corresponding values from math.random() calls. Then, it uses a for…in loop to iterate through the key-value pairs from the map and construct the displayText string. After the loop ends, the script uses a label to visualize the string:\n\n//@version=6\nindicator(\"Looping through map demo\")\n\nif barstate.islastconfirmedhistory\n//@variable A map of \"string\" keys and \"float\" values to render within a \\label\\.\nmap<string, float> simpleMap = map.new<string, float>()\n\n//@variable An array of \"string\" values representing the keys to put into the map.\narray<string> newKeys = array.from(\"A\", \"B\", \"C\", \"D\", \"E\")\n// Put key-value pairs into the \\simpleMap\\.\nfor key in newKeys\nsimpleMap.put(key, math.random(1, 20))\n\n//@variable A \"string\" representation of the \\simpleMap\\ contents. Modified within a loop.\nstring displayText = \"simpleMap content: \\\\n \"\n\n// Loop through each key-value pair within the \\simpleMap\\.\nfor \\[key, value\\] in simpleMap\n// Add a \"string\" representation of the pair to the \\displayText\\.\ndisplayText += key + \": \" + str.tostring(value, \".\") + \"\\\\n \"\n\n// Draw a \\label\\ showing the \\displayText\\ on the current bar.\nlabel.new(\nx = bar\\_index, y = 0, text = displayText, color = color.green, textcolor = color.white,\nsize = size.huge, textalign = text.align\\_left, style = label.style\\_label\\_center\n)\n\nNote that:\n\n- This script uses both forms of the for…in loop statement. The first loop iterates through the “string” elements of the newKeys array to put key-value pairs into the map referenced by simpleMap`, and the second iterates directly through the map’s key-value pairs to construct the custom string.\n\nPrevious\\\\\nConditional structures Next\\\\\nBuilt-ins",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression"
    ]
  },
  "1ef3ebb8": {
    "title": "PineScript Style Guide",
    "type": "style_guide",
    "content": "Style guide\n\nIntroduction\n\nThis style guide provides recommendations on how to name variables and\norganize your Pine scripts in a standard way that works well. Scripts\nthat follow our best practices will be easier to read, understand and\nmaintain.\n\nYou can see scripts using these guidelines published from the\nTradingView\nand\nPineCoders\naccounts on the platform.\n\nNaming Conventions\n\nWe recommend the use of:\n\n- camelCase for all identifiers, i.e., variable or function names:\nma, maFast, maLengthInput, maColor, roundedOHLC(),\npivotHi().\n- All caps SNAKE_CASE for constants: BULL_COLOR, BEAR_COLOR,\nMAX_LOOKBACK.\n- The use of qualifying suffixes when it provides valuable clues about\nthe type or provenance of a variable: maShowInput, bearColor,\nbearColorInput, volumesArray, maPlotID, resultsTable,\nlevelsColorArray.\n\nScript organization\n\nThe Pine Script® compiler is quite forgiving of the positioning of\nspecific statements or the version\ncompiler annotation in the script. While other arrangements are syntactically\ncorrect, this is how we recommend organizing scripts:\n\n``\n\n<license>\n\n<version>\n\n<declaration_statement>\n\n<import_statements>\n\n<constant_declarations>\n\n<inputs>\n\n<function_declarations>\n\n<calculations>\n\n<strategy_calls>\n\n<visuals>\n\n<alerts>\n`\n\n<license>\n\nIf you publish your open-source scripts publicly on TradingView (scripts\ncan also be published privately), your open-source code is by default\nprotected by the Mozilla license. You may choose any other license you\nprefer.\n\nThe reuse of code from those scripts is governed by our House Rules on\\\\\nScript\\\\\nPublishing\nwhich preempt the author’s license.\n\nThe standard license comments appearing at the beginning of scripts are:\n\nPine Script®\nCopied\n\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © username\n\n<version>\n\nThis is the\ncompiler annotation defining the version of Pine Script the script will use. If\nnone is present, v1 is used. For v6, use:\n\nPine Script®\nCopied\n\n//@version=6\n\n<declaration\\_statement>\n\nThis is the mandatory declaration statement which defines the type of\nyour script. It must be a call to either\nindicator(),\nstrategy(),\nor\nlibrary().\n\n<import\\_statements>\n\nIf your script uses one or more Pine Script\nlibraries, your\nimport\nstatements belong here.\n\n<constant\\_declarations>\n\nScripts can declare variables qualified as “const”, i.e., ones\nreferencing a constant value.\n\nWe refer to variables as “constants” when they meet these criteria:\n\n- Their declaration uses the optional const keyword (see our User\nManual’s section on\ntype qualifiers for more information).\n- They are initialized using a literal (e.g., 100 or \"AAPL\") or a\nbuilt-in qualified as “const” (e.g., color.green).\n- Their value does not change during the script’s execution.\n\nWe use SNAKE_CASE to name these variables and group their declaration\nnear the top of the script. For example:\n\nPine Script®\nCopied\n\n// ————— Constants\nint     MS_IN_MIN   = 60 * 1000\nint     MS_IN_HOUR  = MS_IN_MIN  * 60\nint     MS_IN_DAY   = MS_IN_HOUR * 24\ncolor   GRAY        = 808080ff\ncolor   LIME        = 00FF00ff\ncolor   MAROON      = 800000ff\ncolor   ORANGE      = FF8000ff\ncolor   PINK        = FF0080ff\ncolor   TEAL        = 008080ff\ncolor   BG_DIV      = color.new(ORANGE, 90)\ncolor   BG_RESETS   = color.new(GRAY, 90)\nstring  RST1        = \"No reset; cumulate since the beginning of the chart\"\nstring  RST2        = \"On a stepped higher timeframe (HTF)\"\nstring  RST3        = \"On a fixed HTF\"\nstring  RST4        = \"At a fixed time\"\nstring  RST5        = \"At the beginning of the regular session\"\nstring  RST6        = \"At the first visible chart bar\"\nstring  RST7        = \"Fixed rolling period\"\nstring  LTF1        = \"Least precise, covering many chart bars\"\nstring  LTF2        = \"Less precise, covering some chart bars\"\nstring  LTF3        = \"More precise, covering less chart bars\"\nstring  LTF4        = \"Most precise, 1min intrabars\"\nstring  TT_TOTVOL     = \"The 'Bodies' value is the transparency of the total volume candle bodies. Zero is opaque, 100 is transparent.\"\nstring  TT_RST_HTF    = \"This value is used when '\" + RST3 +\"' is selected.\"\nstring  TT_RST_TIME   = \"These values are used when '\" + RST4 +\"' is selected.\nA reset will occur when the time is greater or equal to the bar's open time, and less than its close time.\\nHour: 0-23\\nMinute: 0-59\"\nstring  TT_RST_PERIOD = \"This value is used when '\" + RST7 +\"' is selected.\"\n\nIn this example:\n\n- The RST and LTF constants will be used as tuple elements in\nthe options argument of input.*() calls.\n- The TT_* constants will be used as tooltip arguments in\ninput.*() calls. Note how we use a line continuation for long\nstring literals.\n- We do not use\nvar\nto initialize constants. The Pine Script runtime is optimized to\nhandle declarations on each bar, but using\nvar\nto initialize a variable only the first time it is declared incurs a\nminor penalty on script performance because of the maintenance that\nvar\nvariables require on further bars.\n\nNote that:\n\n- Literals used in more than one place in a script should always be\ndeclared as a constant. Using the constant rather than the literal\nmakes it more readable if it is given a meaningful name, and the\npractice makes code easier to maintain. Even though the quantity of\nmilliseconds in a day is unlikely to change in the future,\nMS_IN_DAY is more meaningful than 1000  60  60 * 24.\n- Constants only used in the local block of a function or\nif,\nwhile,\netc., statement for example, can be declared in that local block.\n\n<inputs>\n\nIt is much easier to read scripts when all their inputs are in the\nsame code section. Placing that section at the beginning of the script\nalso reflects how they are processed at runtime, i.e., before the rest\nof the script is executed.\n\nSuffixing input variable names with input makes them more readily\nidentifiable when they are used later in the script: maLengthInput,\nbearColorInput, showAvgInput, etc.\n\nPine Script®\nCopied\n\n// ————— Inputs\nstring  resetInput              = input.string(RST2,        \"CVD Resets\",                       inline = \"00\", options = [RST1, RST2, RST3, RST4, RST5, RST6, RST7])\nstring  fixedTfInput            = input.timeframe(\"D\",      \"  Fixed HTF:  \",                   tooltip = TT_RST_HTF)\nint     hourInput               = input.int(9,              \"  Fixed time hour:  \",             inline = \"01\", minval = 0, maxval = 23)\nint     minuteInput             = input.int(30,             \"minute\",                           inline = \"01\", minval = 0, maxval = 59, tooltip = TT_RST_TIME)\nint     fixedPeriodInput        = input.int(20,             \"  Fixed period:  \",                inline = \"02\", minval = 1, tooltip = TT_RST_PERIOD)\nstring  ltfModeInput            = input.string(LTF3,        \"Intrabar precision\",               inline = \"03\", options = [LTF1, LTF2, LTF3, LTF4])\n\n<function\\_declarations>\n\nAll user-defined functions must be defined in the script’s global\nscope; nested function definitions are not allowed in Pine Script.\n\nOptimal function design should minimize the use of global variables in\nthe function’s scope, as they undermine function portability. When it\ncan’t be avoided, those functions must follow the global variable\ndeclarations in the code, which entails they can’t always be placed in\nthe <function\\_declarations> section. Such dependencies on global\nvariables should ideally be documented in the function’s comments.\n\nIt will also help readers if you document the function’s objective,\nparameters and result. The same syntax used in\nlibraries can be used to\ndocument your functions. This can make it easier to port your functions\nto a library should you ever decide to do so:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"<function_declarations>\", \"\", true)\nstring SIZE_LARGE  = \"Large\"\nstring SIZE_NORMAL = \"Normal\"\nstring SIZE_SMALL  = \"Small\"\nstring sizeInput = input.string(SIZE_NORMAL, \"Size\", options = [SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL])\n// @function        Used to produce an argument for the size parameter in built-in functions.\n// @param userSize  (simple string) User-selected size.\n// @returns         One of the size.* built-in constants.\n// Dependencies     SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL\ngetSize(simple string userSize) =>\n    result =\n      switch userSize\n        SIZE_LARGE  => size.large\n        SIZE_NORMAL => size.normal\n        SIZE_SMALL  => size.small\n        => size.auto\nif ta.rising(close, 3)\n    label.new(bar_index, na, yloc = yloc.abovebar, style = label.style_arrowup, size = getSize(sizeInput))\n\n<calculations>\n\nThis is where the script’s core calculations and logic should be\nplaced. Code can be easier to read when variable declarations are placed\nnear the code segment using the variables. Some programmers prefer to\nplace all their non-constant variable declarations at the beginning of\nthis section, which is not always possible for all variables, as some\nmay require some calculations to have been executed before their\ndeclaration.\n\n<strategy\\_calls>\n\nStrategies are easier to read when strategy calls are grouped in the\nsame section of the script.\n\n<visuals>\n\nThis section should ideally include all the statements producing the\nscript’s visuals, whether they be plots, drawings, background colors,\ncandle-plotting, etc. See the Pine Script user manual’s section on\nhere for more\ninformation on how the relative depth of visuals is determined.\n\n<alerts>\n\nAlert code will usually require the script’s calculations to have\nexecuted before it, so it makes sense to put it at the end of the\nscript.\n\nSpacing\n\nA space should be used on both sides of all operators, except unary\noperators ( -1). A space is also recommended after all commas and when\nusing named function arguments, as in plot(series = close):\n\nPine Script®\nCopied\n\nint a = close > open ? 1 : -1\nvar int newLen = 2\nnewLen := min(20, newlen + 1)\nfloat a = -b\nfloat c = d > e ? d - e : d\nint index = bar_index % 2 == 0 ? 1 : 2\nplot(close, color = color.red)\n\nLine wrapping\n\nLine wrapping can make long lines easier to read. Line wraps are defined\nby using an indentation level that is not a multiple of four, as four\nspaces or a tab are used to define local blocks. Here we use two spaces:\n\nPine Script®\nCopied\n\nplot(\nseries = close,\ntitle = \"Close\",\ncolor = color.blue,\nshow_last = 10\n)\n\nVertical alignment\n\nVertical alignment using tabs or spaces can be useful in code sections\ncontaining many similar lines such as constant declarations or inputs.\nThey can make mass edits much easier using the Pine Editor’s\nmulti-cursor feature ( ctrl +\nalt \\+ 🠅):\n\nPine Script®\nCopied\n\n// Colors used as defaults in inputs.\ncolor COLOR_AQUA  = 0080FFff\ncolor COLOR_BLACK = 000000ff\ncolor COLOR_BLUE  = 013BCAff\ncolor COLOR_CORAL = FF8080ff\ncolor COLOR_GOLD  = CCCC00ff\n\nExplicit typing\n\nIncluding the type of variables when declaring them is not required.\nHowever, it helps make scripts easier to read, navigate, and understand.\nIt can help clarify the expected types at each point in a script’s\nexecution and distinguish a variable’s declaration (using =) from its\nreassignments (using :=`). Using explicit typing can also make scripts\neasier to debug.\n\nNext\\\\\nDebugging",
    "tags": [
      "style",
      "guide",
      "naming",
      "formatting",
      "conventions"
    ],
    "examples": [
      "<license>\n\n<version>\n\n<declaration_statement>\n\n<import_statements>\n\n<constant_declarations>\n\n<inputs>\n\n<function_declarations>\n\n<calculations>\n\n<strategy_calls>\n\n<visuals>\n\n<alerts>"
    ]
  },
  "04e53255": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Variable declarations\n\nIntroduction\n\nVariables are identifiers that hold values. They must be _declared_ in your code\nbefore you use them. The syntax of variable declarations is:\n\n``\n\n[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n`\n\nor\n\n`\n\n<tuple_declaration> = <function_call> | <structure>\n`\n\nwhere:\n\n- | means OR, and parts enclosed in square brackets ( []) can\nappear zero or one time.\n- <declaration\\_mode> is the variable’s\ndeclaration mode. It can be\nvar\nor\nvarip,\nor nothing.\n- <type> is a valid _type keyword_ with an optional _qualifier prefix_. Specifying a variable’s type is optional in most cases. See the Type system page to learn more.\n- <identifier> is the variable’s\nname.\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <structure> can be an\nif,\nfor,\nwhile\nor\nswitch _structure_.\n- <tuple\\_declaration> is a comma-separated list of variable names\nenclosed in square brackets ( []), e.g.,\n[ma, upperBand, lowerBand].\n\nThese are all valid variable declarations. Note that the last declaration requires four\nlines of code because it uses the returned value from an if statement:\n\nBULL\\_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round\\_to\\_mintick(close)\nsma = ta.sma(close, 14)\nvar barRange = float(na)\nvar firstBarOpen = open\nvarip float lastClose = na\n\\[macdLine, signalLine, histLine\\] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\nelse\ncolor.red\n\nThe formal syntax of a variable declaration is:\n\n`\n\n<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum\n`\n\nInitialization with ​ na ​\n\nIn most cases, an explicit type declaration is redundant because type is\nautomatically inferred from the value on the right of the = at compile\ntime, so the decision to use them is often a matter of preference. For\nexample:\n\nbaseLine0 = na // compile time error!\nfloat baseLine1 = na // OK\nbaseLine2 = float(na) // OK\n\nIn the first line of the example, the compiler cannot determine the type\nof the baseLine0 variable because\nna is a\ngeneric value of no particular type. The declaration of the baseLine1\nvariable is correct because its\nfloat\ntype is declared explicitly. The declaration of the baseLine2 variable\nis also correct because its type can be derived from the expression\nfloat(na), which is an explicit cast of the\nna value\nto the\nfloat\ntype. The declarations of baseLine1 and baseLine2 are equivalent.\n\nTuple declarations\n\nFunction calls or structures are allowed to return multiple values. When\nwe call them and want to store the values they return, a _tuple_\n_declaration_ must be used, which is a comma-separated set of one or more\nvalues enclosed in brackets. This allows us to declare multiple\nvariables simultaneously. As an example, the\nta.bb()\nbuilt-in function for Bollinger bands returns three values:\n\n\\[bbMiddle, bbUpper, bbLower\\] = ta.bb(close, 5, 4)\n\nUsing an underscore (​ _ ​) as an identifier\n\nWhen declaring a variable, it is possible to use a single underscore ( _) as its identifier. A value assigned to such a variable cannot be accessed. You can assign any number of values to a _ identifier anywhere in the script, even if the current scope already has such an assignment.\n\nThis is particularly useful when a tuple returns unneeded values. Let’s write another Bollinger Bands script. Here, we only need the bands themselves, without the center line:\n\n//@version=6\nindicator(\"Underscore demo\")\n\n// We do not need the middle Bollinger Bands value, and do not use it.\n// To make this clear, we assign it to the \\\\_\\ identifier.\n\\[\\_, bbUpper, bbLower\\] = ta.bb(close, 5, 4)\n\n// We can continue to use \\\\_\\ in the same code without causing compilation errors:\n\\[bbMiddleLong, \\_, \\_\\] = ta.bb(close, 20, 2)\n\nplot(bbUpper)\n\nVariable reassignment\n\nA variable reassignment is done using the\n:=\nreassignment operator. It can only be done after a variable has been\nfirst declared and given an initial value. Reassigning a new value to a\nvariable is often necessary in calculations, and it is always necessary\nwhen a variable from the global scope must be assigned a new value from\nwithin a structure’s local block, e.g.:\n\n//@version=6\nindicator(\"\", \"\", true)\nsensitivityInput = input.int(2, \"Sensitivity\", minval = 1, tooltip = \"Higher values make color changes less sensitive.\")\nma = ta.sma(close, 20)\nmaUp = ta.rising(ma, sensitivityInput)\nmaDn = ta.falling(ma, sensitivityInput)\n\n// On first bar only, initialize color to gray\nvar maColor = color.gray\nif maUp\n// MA has risen for two bars in a row; make it lime.\nmaColor := color.lime\nelse if maDn\n// MA has fallen for two bars in a row; make it fuchsia.\nmaColor := color.fuchsia\n\nplot(ma, \"MA\", maColor, 2)\n\nNote that:\n\n- We initialize maColor on the first bar only, so it preserves its\nvalue across bars.\n- On every bar, the\nif\nstatement checks if the MA has been rising or falling for the\nuser-specified number of bars (the default is 2). When that happens,\nthe value of maColor must be reassigned a new value from within\nthe\nif\nlocal blocks. To do this, we use the\n:= reassignment operator.\n- If we did not use the\n:= reassignment operator, the effect would be to initialize\na new maColor local variable which would have the same name as\nthat of the global scope, but actually be a very confusing\nindependent entity that would persist only for the length of the\nlocal block, and then disappear without a trace.\n\nAll user-defined variables in Pine Script are _mutable_, which means\ntheir value can be changed using the\n:=\nreassignment operator. Assigning a new value to a variable may change\nits _type qualifier_ (see the page on Pine Script’s\ntype system for more\ninformation). A variable can be assigned a new value as many times as\nneeded during the script’s execution on one bar, so a script can\ncontain any number of reassignments of one variable. A variable’s\ndeclaration mode determines how new values assigned to a variable will be\nsaved.\n\nDeclaration modes\n\nUnderstanding the impact that declaration modes have on the behavior of\nvariables requires prior knowledge of Pine Script’s\nexecution model.\n\nWhen you declare a variable, if a declaration mode is specified, it must\ncome first. Three modes can be used:\n\n- “On each bar”, when none is specified\n- var\n- varip\n\nOn each bar\n\nWhen no explicit declaration mode is specified, i.e. no\nvar or\nvarip\nkeyword is used, the variable is declared and initialized on each bar,\ne.g., the following declarations from our first set of examples in this\npage’s introduction:\n\nBULL\\_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round\\_to\\_mintick(close)\nst = ta.supertrend(4, 14)\n\\[macdLine, signalLine, histLine\\] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\nelse\ncolor.red\n\n​ var ​\n\nWhen the\nvar\nkeyword is used, the variable is only initialized once, on the first bar\nif the declaration is in the global scope, or the first time the local\nblock is executed if the declaration is inside a local block. After\nthat, it will preserve its last value on successive bars, until we\nreassign a new value to it. This behavior is very useful in many cases\nwhere a variable’s value must persist through the iterations of a\nscript across successive bars. For example, suppose we’d like to count\nthe number of green bars on the chart:\n\n//@version=6\nindicator(\"Green Bars Count\")\nvar count = 0\nisGreen = close >= open\nif isGreen\ncount := count + 1\nplot(count)\n\nWithout the var modifier, variable count would be reset to zero\n(thus losing its value) every time a new bar update triggered a script\nrecalculation.\n\nDeclaring variables on the first bar only is often useful to manage\ndrawings more efficiently. Suppose we want to extend the last bar’s\nclose\nline to the right of the right chart. We could write:\n\n//@version=6\nindicator(\"Inefficient version\", \"\", true)\ncloseLine = line.new(bar\\_index - 1, close, bar\\_index, close, extend = extend.right, width = 3)\nline.delete(closeLine\\[1\\])\n\nbut this is inefficient because we are creating and deleting the line on\neach historical bar and on each update in the realtime bar. It is more\nefficient to use:\n\n//@version=6\nindicator(\"Efficient version\", \"\", true)\nvar closeLine = line.new(bar\\_index - 1, close, bar\\_index, close, extend = extend.right, width = 3)\nif barstate.islast\nline.set\\_xy1(closeLine, bar\\_index - 1, close)\nline.set\\_xy2(closeLine, bar\\_index, close)\n\nNote that:\n\n- We initialize closeLine on the first bar only, using the\nvar\ndeclaration mode\n- We restrict the execution of the rest of our code to the chart’s\nlast bar by enclosing our code that updates the line in an\nif barstate.islast\nstructure.\n\nThere is a very slight penalty performance for using the\nvar\ndeclaration mode. For that reason, when declaring constants, it is\npreferable not to use\nvar if\nperformance is a concern, unless the initialization involves\ncalculations that take longer than the maintenance penalty, e.g.,\nfunctions with complex code or string manipulations.\n\n​ varip ​\n\nUnderstanding the behavior of variables using the\nvarip\ndeclaration mode requires prior knowledge of Pine Script’s\nexecution model and\nbar states.\n\nThe\nvarip\nkeyword can be used to declare variables that escape the _rollback_\n_process_, which is explained in the page on Pine Script’s\nexecution model.\n\nWhereas scripts only execute once at the close of historical bars, when\na script is running in realtime, it executes every time the chart’s\nfeed detects a price or volume update. At every realtime update, Pine\nScript’s runtime normally resets the values of a script’s variables\nto their last committed value, i.e., the value they held when the\nprevious bar closed. This is generally handy, as each realtime script\nexecution starts from a known state, which simplifies script logic.\n\nSometimes, however, script logic requires code to be able to save\nvariable values between different executions in the realtime bar.\nDeclaring variables with\nvarip\nmakes that possible. The “ip” in\nvarip\nstands for _intrabar persist_.\n\nLet’s look at the following code, which does not use\nvarip:\n\n//@version=6\nindicator(\"\")\nint updateNo = na\nif barstate.isnew\nupdateNo := 1\nelse\nupdateNo := updateNo + 1\n\nplot(updateNo, style = plot.style\\_circles)\n\nOn historical bars,\nbarstate.isnew\nis always true, so the plot shows a value of “1” because the else\npart of the\nif\nstructure is never executed. On realtime bars,\nbarstate.isnew\nis only\ntrue\nwhen the script first executes on the bar’s “open”. The plot will\nthen briefly display “1” until subsequent executions occur. On the\nnext executions during the realtime bar, the second branch of the\nif\nstatement is executed because\nbarstate.isnew\nis no longer true. Since updateNo is initialized to\nna at\neach execution, the updateNo + 1 expression yields\nna, so\nnothing is plotted on further realtime executions of the script.\n\nIf we now use\nvarip\nto declare the updateNo variable, the script behaves very differently:\n\n//@version=6\nindicator(\"\")\nvarip int updateNo = na\nif barstate.isnew\nupdateNo := 1\nelse\nupdateNo := updateNo + 1\n\nplot(updateNo, style = plot.style\\_circles)\n\nThe difference now is that updateNo tracks the number of realtime\nupdates that occur on each realtime bar. This can happen because the\nvarip\ndeclaration allows the value of updateNo` to be preserved between\nrealtime updates; it is no longer rolled back at each realtime execution\nof the script. The test on\nbarstate.isnew\nallows us to reset the update count when a new realtime bar comes in.\n\nBecause\nvarip\nonly affects the behavior of your code in the realtime bar, it follows\nthat backtest results on strategies designed using logic based on\nvarip\nvariables will not be able to reproduce that behavior on historical\nbars, which will invalidate test results on them. This also entails that\nplots on historical bars will not be able to reproduce the script’s\nbehavior in realtime.\n\nPrevious\\\\\nIdentifiers Next\\\\\nOperators",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>",
      "<tuple_declaration> = <function_call> | <structure>",
      "<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum"
    ]
  },
  "234a4dda": {
    "title": "PineScript Style Guide",
    "type": "style_guide",
    "content": "Style guide\n\nIntroduction\n\nThis style guide provides recommendations on how to name variables and\norganize your Pine scripts in a standard way that works well. Scripts\nthat follow our best practices will be easier to read, understand and\nmaintain.\n\nYou can see scripts using these guidelines published from the\nTradingView\nand\nPineCoders\naccounts on the platform.\n\nNaming Conventions\n\nWe recommend the use of:\n\n- camelCase for all identifiers, i.e., variable or function names:\nma, maFast, maLengthInput, maColor, roundedOHLC(),\npivotHi().\n- All caps SNAKE_CASE for constants: BULL_COLOR, BEAR_COLOR,\nMAX_LOOKBACK.\n- The use of qualifying suffixes when it provides valuable clues about\nthe type or provenance of a variable: maShowInput, bearColor,\nbearColorInput, volumesArray, maPlotID, resultsTable,\nlevelsColorArray.\n\nScript organization\n\nThe Pine Script® compiler is quite forgiving of the positioning of\nspecific statements or the version\ncompiler annotation in the script. While other arrangements are syntactically\ncorrect, this is how we recommend organizing scripts:\n\n``\n\n<license>\n\n<version>\n\n<declaration_statement>\n\n<import_statements>\n\n<constant_declarations>\n\n<inputs>\n\n<function_declarations>\n\n<calculations>\n\n<strategy_calls>\n\n<visuals>\n\n<alerts>\n`\n\n<license>\n\nIf you publish your open-source scripts publicly on TradingView (scripts\ncan also be published privately), your open-source code is by default\nprotected by the Mozilla license. You may choose any other license you\nprefer.\n\nThe reuse of code from those scripts is governed by our House Rules on\\\\\nScript\\\\\nPublishing\nwhich preempt the author’s license.\n\nThe standard license comments appearing at the beginning of scripts are:\n\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © username\n\n<version>\n\nThis is the\ncompiler annotation defining the version of Pine Script the script will use. If\nnone is present, v1 is used. For v6, use:\n\n//@version=6\n\n<declaration\\_statement>\n\nThis is the mandatory declaration statement which defines the type of\nyour script. It must be a call to either\nindicator(),\nstrategy(),\nor\nlibrary().\n\n<import\\_statements>\n\nIf your script uses one or more Pine Script\nlibraries, your\nimport\nstatements belong here.\n\n<constant\\_declarations>\n\nScripts can declare variables qualified as “const”, i.e., ones\nreferencing a constant value.\n\nWe refer to variables as “constants” when they meet these criteria:\n\n- Their declaration uses the optional const keyword (see our User\nManual’s section on\ntype qualifiers for more information).\n- They are initialized using a literal (e.g., 100 or \"AAPL\") or a\nbuilt-in qualified as “const” (e.g., color.green).\n- Their value does not change during the script’s execution.\n\nWe use SNAKE_CASE to name these variables and group their declaration\nnear the top of the script. For example:\n\n// ————— Constants\nint MS\\_IN\\_MIN = 60 \\* 1000\nint MS\\_IN\\_HOUR = MS\\_IN\\_MIN \\* 60\nint MS\\_IN\\_DAY = MS\\_IN\\_HOUR \\* 24\n\ncolor GRAY = 808080ff\ncolor LIME = 00FF00ff\ncolor MAROON = 800000ff\ncolor ORANGE = FF8000ff\ncolor PINK = FF0080ff\ncolor TEAL = 008080ff\ncolor BG\\_DIV = color.new(ORANGE, 90)\ncolor BG\\_RESETS = color.new(GRAY, 90)\n\nstring RST1 = \"No reset; cumulate since the beginning of the chart\"\nstring RST2 = \"On a stepped higher timeframe (HTF)\"\nstring RST3 = \"On a fixed HTF\"\nstring RST4 = \"At a fixed time\"\nstring RST5 = \"At the beginning of the regular session\"\nstring RST6 = \"At the first visible chart bar\"\nstring RST7 = \"Fixed rolling period\"\n\nstring LTF1 = \"Least precise, covering many chart bars\"\nstring LTF2 = \"Less precise, covering some chart bars\"\nstring LTF3 = \"More precise, covering less chart bars\"\nstring LTF4 = \"Most precise, 1min intrabars\"\n\nstring TT\\_TOTVOL = \"The 'Bodies' value is the transparency of the total volume candle bodies. Zero is opaque, 100 is transparent.\"\nstring TT\\_RST\\_HTF = \"This value is used when '\" + RST3 +\"' is selected.\"\nstring TT\\_RST\\_TIME = \"These values are used when '\" + RST4 +\"' is selected.\nA reset will occur when the time is greater or equal to the bar's open time, and less than its close time.\\\\nHour: 0-23\\\\nMinute: 0-59\"\nstring TT\\_RST\\_PERIOD = \"This value is used when '\" + RST7 +\"' is selected.\"\n\nIn this example:\n\n- The RST and LTF constants will be used as tuple elements in\nthe options argument of input.*() calls.\n- The TT_* constants will be used as tooltip arguments in\ninput.*() calls. Note how we use a line continuation for long\nstring literals.\n- We do not use\nvar\nto initialize constants. The Pine Script runtime is optimized to\nhandle declarations on each bar, but using\nvar\nto initialize a variable only the first time it is declared incurs a\nminor penalty on script performance because of the maintenance that\nvar\nvariables require on further bars.\n\nNote that:\n\n- Literals used in more than one place in a script should always be\ndeclared as a constant. Using the constant rather than the literal\nmakes it more readable if it is given a meaningful name, and the\npractice makes code easier to maintain. Even though the quantity of\nmilliseconds in a day is unlikely to change in the future,\nMS_IN_DAY is more meaningful than 1000  60  60 * 24.\n- Constants only used in the local block of a function or\nif,\nwhile,\netc., statement for example, can be declared in that local block.\n\n<inputs>\n\nIt is much easier to read scripts when all their inputs are in the\nsame code section. Placing that section at the beginning of the script\nalso reflects how they are processed at runtime, i.e., before the rest\nof the script is executed.\n\nSuffixing input variable names with input makes them more readily\nidentifiable when they are used later in the script: maLengthInput,\nbearColorInput, showAvgInput, etc.\n\n// ————— Inputs\nstring resetInput = input.string(RST2, \"CVD Resets\", inline = \"00\", options = \\[RST1, RST2, RST3, RST4, RST5, RST6, RST7\\])\nstring fixedTfInput = input.timeframe(\"D\", \"  Fixed HTF:  \", tooltip = TT\\_RST\\_HTF)\nint hourInput = input.int(9, \"  Fixed time hour:  \", inline = \"01\", minval = 0, maxval = 23)\nint minuteInput = input.int(30, \"minute\", inline = \"01\", minval = 0, maxval = 59, tooltip = TT\\_RST\\_TIME)\nint fixedPeriodInput = input.int(20, \"  Fixed period:  \", inline = \"02\", minval = 1, tooltip = TT\\_RST\\_PERIOD)\nstring ltfModeInput = input.string(LTF3, \"Intrabar precision\", inline = \"03\", options = \\[LTF1, LTF2, LTF3, LTF4\\])\n\n<function\\_declarations>\n\nAll user-defined functions must be defined in the script’s global\nscope; nested function definitions are not allowed in Pine Script.\n\nOptimal function design should minimize the use of global variables in\nthe function’s scope, as they undermine function portability. When it\ncan’t be avoided, those functions must follow the global variable\ndeclarations in the code, which entails they can’t always be placed in\nthe <function\\_declarations> section. Such dependencies on global\nvariables should ideally be documented in the function’s comments.\n\nIt will also help readers if you document the function’s objective,\nparameters and result. The same syntax used in\nlibraries can be used to\ndocument your functions. This can make it easier to port your functions\nto a library should you ever decide to do so:\n\n//@version=6\nindicator(\"<function\\_declarations>\", \"\", true)\n\nstring SIZE\\_LARGE = \"Large\"\nstring SIZE\\_NORMAL = \"Normal\"\nstring SIZE\\_SMALL = \"Small\"\n\nstring sizeInput = input.string(SIZE\\_NORMAL, \"Size\", options = \\[SIZE\\_LARGE, SIZE\\_NORMAL, SIZE\\_SMALL\\])\n\n// @function Used to produce an argument for the \\size\\ parameter in built-in functions.\n// @param userSize (simple string) User-selected size.\n// @returns One of the \\size.\\*\\ built-in constants.\n// Dependencies SIZE\\_LARGE, SIZE\\_NORMAL, SIZE\\_SMALL\ngetSize(simple string userSize) =>\nresult =\nswitch userSize\nSIZE\\_LARGE => size.large\nSIZE\\_NORMAL => size.normal\nSIZE\\_SMALL => size.small\n=\\> size.auto\n\nif ta.rising(close, 3)\nlabel.new(bar\\_index, na, yloc = yloc.abovebar, style = label.style\\_arrowup, size = getSize(sizeInput))\n\n<calculations>\n\nThis is where the script’s core calculations and logic should be\nplaced. Code can be easier to read when variable declarations are placed\nnear the code segment using the variables. Some programmers prefer to\nplace all their non-constant variable declarations at the beginning of\nthis section, which is not always possible for all variables, as some\nmay require some calculations to have been executed before their\ndeclaration.\n\n<strategy\\_calls>\n\nStrategies are easier to read when strategy calls are grouped in the\nsame section of the script.\n\n<visuals>\n\nThis section should ideally include all the statements producing the\nscript’s visuals, whether they be plots, drawings, background colors,\ncandle-plotting, etc. See the Pine Script user manual’s section on\nhere for more\ninformation on how the relative depth of visuals is determined.\n\n<alerts>\n\nAlert code will usually require the script’s calculations to have\nexecuted before it, so it makes sense to put it at the end of the\nscript.\n\nSpacing\n\nA space should be used on both sides of all operators, except unary\noperators ( -1). A space is also recommended after all commas and when\nusing named function arguments, as in plot(series = close):\n\nint a = close > open ? 1 : -1\nvar int newLen = 2\nnewLen := min(20, newlen + 1)\nfloat a = -b\nfloat c = d > e ? d - e : d\nint index = bar\\_index % 2 == 0 ? 1 : 2\nplot(close, color = color.red)\n\nLine wrapping\n\nLine wrapping can make long lines easier to read. Line wraps are defined\nby using an indentation level that is not a multiple of four, as four\nspaces or a tab are used to define local blocks. Here we use two spaces:\n\nplot(\nseries = close,\ntitle = \"Close\",\ncolor = color.blue,\nshow\\_last = 10\n)\n\nVertical alignment\n\nVertical alignment using tabs or spaces can be useful in code sections\ncontaining many similar lines such as constant declarations or inputs.\nThey can make mass edits much easier using the Pine Editor’s\nmulti-cursor feature ( ctrl +\nalt \\+ 🠅):\n\n// Colors used as defaults in inputs.\ncolor COLOR\\_AQUA = 0080FFff\ncolor COLOR\\_BLACK = 000000ff\ncolor COLOR\\_BLUE = 013BCAff\ncolor COLOR\\_CORAL = FF8080ff\ncolor COLOR\\_GOLD = CCCC00ff\n\nExplicit typing\n\nIncluding the type of variables when declaring them is not required.\nHowever, it helps make scripts easier to read, navigate, and understand.\nIt can help clarify the expected types at each point in a script’s\nexecution and distinguish a variable’s declaration (using =) from its\nreassignments (using :=`). Using explicit typing can also make scripts\neasier to debug.\n\nNext\\\\\nDebugging",
    "tags": [
      "style",
      "guide",
      "naming",
      "formatting",
      "conventions"
    ],
    "examples": [
      "<license>\n\n<version>\n\n<declaration_statement>\n\n<import_statements>\n\n<constant_declarations>\n\n<inputs>\n\n<function_declarations>\n\n<calculations>\n\n<strategy_calls>\n\n<visuals>\n\n<alerts>"
    ]
  },
  "f1397a50": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nMethods\n\nIntroduction\n\nPine Script methods are specialized functions associated with values of specific built-in types,\nuser-defined types, or enum types.\nThey behave the same as regular functions in most regards while offering a shorter, more convenient syntax.\nUsers can access methods using _dot notation_ syntax on variables of the associated type, similar to accessing the fields\nof a Pine Script object.\n\nBuilt-in methods\n\nPine Script includes built-in methods for all _special types_,\nincluding\narray,\nmatrix,\nmap,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\nand\ntable.\nThese methods provide users with a more concise way to call specialized\nroutines for these types within their scripts.\n\nWhen using these special types, the expressions:\n\n``\n\n<namespace>.<functionName>([paramName =] <objectName>, …)\n`\n\nand:\n\n`\n\n<objectName>.<functionName>(…)\n`\n\nare equivalent. For example, rather than using:\n\nPine Script®\nCopied\n\narray.get(id, index)\n\nto get the value from an array id at the specified index, we can\nsimply use:\n\nPine Script®\nCopied\n\nid.get(index)\n\nto achieve the same effect. This notation eliminates the need for users\nto reference the function’s namespace, as\nget()\nis a method of id in this context.\n\nWritten below is a practical example to demonstrate the usage of\nbuilt-in methods in place of functions.\n\nThe following script computes Bollinger Bands over a specified number of\nprices sampled once every n bars. It calls\narray.push()\nand\narray.shift()\nto queue sourceInput values through the sourceArray, then\narray.avg()\nand\narray.stdev()\nto compute the sampleMean and sampleDev. The script then uses these\nvalues to calculate the highBand and lowBand, which it plots on the\nchart along with the sampleMean:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float        sampleMean  = na\nvar float        sampleDev   = na\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    array.push(sourceArray, sourceInput)\n    array.shift(sourceArray)\n    // Update the mean and standard deviaiton values.\n    sampleMean := array.avg(sourceArray)\n    sampleDev  := array.stdev(sourceArray) * multiplier\n// Calculate bands.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nLet’s rewrite this code to utilize methods rather than built-in\nfunctions. In this version, we have replaced all built-in\narray.*() function calls in the script with equivalent method calls:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float        sampleMean  = na\nvar float        sampleDev   = na\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.push(sourceInput)\n    sourceArray.shift()\n    // Update the mean and standard deviaiton values.\n    sampleMean := sourceArray.avg()\n    sampleDev  := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nNote that:\n\n- We call the array methods using sourceArray.* rather than\nreferencing the\narray\nnamespace.\n- We do not include sourceArray as a parameter when we call the\nmethods since they already reference the object.\n\nUser-defined methods\n\nPine Script allows users to define custom methods for use with objects\nof any built-in or user-defined type. Defining a method is essentially\nthe same as defining a function, but with two key differences:\n\n- The\nmethod\nkeyword must be included before the function name.\n- The type of the first parameter in the signature must be explicitly\ndeclared, as it represents the type of object that the method will\nbe associated with.\n\n`\n\n[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>\n`\n\nLet’s apply user-defined methods to our previous Bollinger Bands\nexample to encapsulate operations from the global scope, which will\nsimplify the code and promote reusability. See this portion from the\nexample:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.push(sourceInput)\n    sourceArray.shift()\n    // Update the mean and standard deviaiton values.\n    sampleMean := sourceArray.avg()\n    sampleDev  := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\n\nWe will start by defining a simple method to queue values through an\narray in a single call.\n\nThis maintainQueue() method invokes the\npush()\nand\nshift()\nmethods on a srcArray when takeSample is true and returns the\nobject:\n\nPine Script®\nCopied\n\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n\nNote that:\n\n- Just as with user-defined functions, we use the @function compiler annotation to document method descriptions.\n\nNow we can replace sourceArray.push() and sourceArray.shift() with\nsourceArray.maintainQueue() in our example:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.maintainQueue(sourceInput)\n    // Update the mean and standard deviaiton values.\n    sampleMean  := sourceArray.avg()\n    sampleDev   := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand  = sampleMean + sampleDev\nfloat lowBand   = sampleMean - sampleDev\n\nFrom here, we will further simplify our code by defining a method that\nhandles all Bollinger Band calculations within its scope.\n\nThis calcBB() method invokes the\navg()\nand\nstdev()\nmethods on a srcArray to update mean and dev values when\ncalculate is true. The method uses these values to return a tuple\ncontaining the basis, upper band, and lower band values respectively:\n\nPine Script®\nCopied\n\n// @function         Computes Bollinger Band values from an array of data.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate   (bool) The method will only calculate new values when this is true.\n// @returns          A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        // Compute the mean and standard deviation of the array.\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]\n\nWith this method, we can now remove Bollinger Band calculations from the\nglobal scope and improve code readability:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\n\nNote that:\n\n- Rather than using an if block in the global scope, we have\ndefined a newSample variable that is only true once every n\nbars. The maintainQueue() and calcBB() methods use this\nvalue for their respective takeSample and calculate\nparameters.\n- Since the maintainQueue() method returns the object that it\nreferences, we’re able to call calcBB() from the same line of\ncode, as both methods apply to array<float> instances.\n\nHere is how the full script example looks now that we’ve applied our\nuser-defined methods:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n// @function         Computes Bollinger Band values from an array of data.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate   (bool) The method will only calculate new values when this is true.\n// @returns          A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        // Compute the mean and standard deviation of the array.\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]\n// Identify if n bars have passed.\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nMethod overloading\n\nUser-defined methods can override and overload existing built-in and\nuser-defined methods with the same identifier. This capability allows\nusers to define multiple routines associated with different parameter\nsignatures under the same method name.\n\nAs a simple example, suppose we want to define a method to identify a\nvariable’s type. Since we must explicitly specify the type of object\nassociated with a user-defined method, we will need to define overloads\nfor each type that we want it to recognize.\n\nBelow, we have defined a getType() method that returns a string\nrepresentation of a variable’s type with overloads for the five\nprimitive types:\n\nPine Script®\nCopied\n\n// @function   Identifies an object's type.\n// @param this Object to inspect.\n// @returns    (string) A string representation of the type.\nmethod getType(int this) =>\n    na(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\n    na(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\n    // \"bool\" values only have two states, true and false, but never na.\n    \"bool\"\nmethod getType(color this) =>\n    na(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\n    na(this) ? \"string(na)\" : \"string\"\n\nNow we can use these overloads to inspect some variables. This script\nuses\nstr.format()\nto format the results from calling the getType() method on five\ndifferent variables into a single results string, then displays the\nstring in the lbl label using the built-in\nset\\_text()\nmethod:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Type Inspection\")\n// @function   Identifies an object's type.\n// @param this Object to inspect.\n// @returns    (string) A string representation of the type.\nmethod getType(int this) =>\n    na(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\n    na(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\n    na(this) ? \"bool(na)\" : \"bool\"\nmethod getType(color this) =>\n    na(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\n    na(this) ? \"string(na)\" : \"string\"\na = 1\nb = 1.0\nc = true\nd = color.white\ne = \"1\"\n// Inspect variables and format results.\nresults = str.format(\n\"a: {0}\\nb: {1}\\nc: {2}\\nd: {3}\\ne: {4}\",\na.getType(), b.getType(), c.getType(), d.getType(), e.getType()\n)\nvar label lbl = label.new(0, 0)\nlbl.set_x(bar_index)\nlbl.set_text(results)\n\nNote that:\n\n- The underlying type of each variable determines which overload\nof getType() the compiler will use.\n- The method will append “(na)” to the output string when a\nvariable is na to demarcate that it is empty.\n\nAdvanced example\n\nLet’s apply what we’ve learned to construct a script that estimates\nthe cumulative distribution of elements in an array, meaning the\nfraction of elements in the array that are less than or equal to any\ngiven value.\n\nThere are many ways in which we could choose to tackle this objective.\nFor this example, we will start by defining a method to replace elements\nof an array, which will help us count the occurrences of elements within\na range of values.\n\nWritten below is an overload of the built-in\nfill()\nmethod for array<float> instances. This overload replaces elements in\na srcArray within the range between the lowerBound and upperBound\nwith an innerValue, and replaces all elements outside the range with\nan outerValue:\n\nPine Script®\nCopied\n\n// @function          Replaces elements in a srcArray between lowerBound and upperBound with an innerValue,\n//                    and replaces elements outside the range with an outerValue.\n// @param srcArray    (array<float>) Array to modify.\n// @param innerValue  (float) Value to replace elements within the range with.\n// @param outerValue  (float) Value to replace elements outside the range with.\n// @param lowerBound  (float) Lowest value to replace with innerValue.\n// @param upperBound  (float) Highest value to replace with innerValue.\n// @returns           (array<float>) srcArray object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\n    for [i, element] in srcArray\n        if (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\n            srcArray.set(i, innerValue)\n        else\n            srcArray.set(i, outerValue)\n    srcArray\n\nWith this method, we can filter an array by value ranges to produce an\narray of occurrences. For example, the expression:\n\nPine Script®\nCopied\n\nsrcArray.copy().fill(1.0, 0.0, min, val)\n\ncopies the srcArray object, replaces all elements between min and\nval with 1.0, then replaces all elements above val with 0.0. From\nhere, it’s easy to estimate the output of the cumulative distribution\nfunction at the val, as it’s simply the average of the resulting\narray:\n\nPine Script®\nCopied\n\nsrcArray.copy().fill(1.0, 0.0, min, val).avg()\n\nNote that:\n\n- The compiler will only use this fill() overload instead of the\nbuilt-in when the user provides innerValue, outerValue,\nlowerBound, and upperBound arguments in the call.\n- If either lowerBound or upperBound is na, its value is\nignored while filtering the fill range.\n- We are able to call copy(), fill(), and avg() successively\non the same line of code because the first two methods return an\narray<float> instance.\n\nWe can now use this to define a method that will calculate our empirical\ndistribution values. The following eCDF() method estimates a number of\nevenly spaced ascending steps from the cumulative distribution\nfunction of a srcArray and pushes the results into a cdfArray:\n\nPine Script®\nCopied\n\n// @function       Estimates the empirical CDF of a srcArray.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps    (int) Number of steps in the estimation.\n// @returns        (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\n    float min = srcArray.min()\n    float rng = srcArray.range() / steps\n    array<float> cdfArray = array.new<float>()\n    // Add averages of srcArray filtered by value region to the cdfArray.\n    float val = min\n    for i = 1 to steps\n        val += rng\n        cdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\n    cdfArray\n\nLastly, to ensure that our eCDF() method functions properly for arrays\ncontaining small and large values, we will define a method to normalize\nour arrays.\n\nThis featureScale() method uses array\nmin()\nand\nrange()\nmethods to produce a rescaled copy of a srcArray. We will use this to\nnormalize our arrays prior to invoking the eCDF() method:\n\nPine Script®\nCopied\n\n// @function        Rescales the elements within a srcArray to the interval [0, 1].\n// @param srcArray  (array<float>) Array to normalize.\n// @returns         (array<float>) Normalized copy of the srcArray.\nmethod featureScale(array<float> srcArray) =>\n    float min = srcArray.min()\n    float rng = srcArray.range()\n    array<float> scaledArray = array.new<float>()\n    // Push normalized element values into the scaledArray.\n    for element in srcArray\n        scaledArray.push((element - min) / rng)\n    scaledArray\n\nNote that:\n\n- This method does not include special handling for divide by zero\nconditions. If rng is 0, the value of the array element will\nbe na.\n\nThe full example below queues a sourceArray of size length with\nsourceInput values using our previous maintainQueue() method,\nnormalizes the array’s elements using the featureScale() method, then\ncalls the eCDF() method to get an array of estimates for n evenly\nspaced steps on the distribution. The script then calls a user-defined\nmakeLabel() function to display the estimates and prices in a label on\nthe right side of the chart:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Empirical Distribution\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint length        = input.int(20, \"Length\")\nint n             = input.int(20, \"Steps\")\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n// @function          Replaces elements in a srcArray between lowerBound and upperBound with an innerValue,\n//                    and replaces elements outside the range with an outerValue.\n// @param srcArray    (array<float>) Array to modify.\n// @param innerValue  (float) Value to replace elements within the range with.\n// @param outerValue  (float) Value to replace elements outside the range with.\n// @param lowerBound  (float) Lowest value to replace with innerValue.\n// @param upperBound  (float) Highest value to replace with innerValue.\n// @returns           (array<float>) srcArray object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\n    for [i, element] in srcArray\n        if (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\n            srcArray.set(i, innerValue)\n        else\n            srcArray.set(i, outerValue)\n    srcArray\n// @function       Estimates the empirical CDF of a srcArray.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps    (int) Number of steps in the estimation.\n// @returns        (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\n    float min = srcArray.min()\n    float rng = srcArray.range() / steps\n    array<float> cdfArray = array.new<float>()\n    // Add averages of srcArray filtered by value region to the cdfArray.\n    float val = min\n    for i = 1 to steps\n        val += rng\n        cdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\n    cdfArray\n// @function        Rescales the elements within a srcArray to the interval [0, 1].\n// @param srcArray  (array<float>) Array to normalize.\n// @returns         (array<float>) Normalized copy of the srcArray.\nmethod featureScale(array<float> srcArray) =>\n    float min = srcArray.min()\n    float rng = srcArray.range()\n    array<float> scaledArray = array.new<float>()\n    // Push normalized element values into the scaledArray.\n    for element in srcArray\n        scaledArray.push((element - min) / rng)\n    scaledArray\n// @function        Draws a label containing eCDF estimates in the format \"{price}: {percent}%\"\n// @param srcArray  (array<float>) Array of source values.\n// @param cdfArray  (array<float>) Array of CDF estimates.\n// @returns         (void)\nmakeLabel(array<float> srcArray, array<float> cdfArray) =>\n    float max      = srcArray.max()\n    float rng      = srcArray.range() / cdfArray.size()\n    string results = \"\"\n    var label lbl  = label.new(0, 0, \"\", style = label.style_label_left, text_font_family = font.family_monospace)\n    // Add percentage strings to results starting from the max.\n    cdfArray.reverse()\n    for [i, element] in cdfArray\n        results += str.format(\"{0}: {1}%\\n\", max - i  rng, element  100)\n    // Update lbl attributes.\n    lbl.set_xy(bar_index + 1, srcArray.avg())\n    lbl.set_text(results)\nvar array<float> sourceArray = array.new<float>(length)\n// Add background color for the last length bars.\nbgcolor(bar_index > last_bar_index - length ? color.new(color.orange, 80) : na)\n// Queue sourceArray, feature scale, then estimate the distribution over n steps.\narray<float> distArray = sourceArray.maintainQueue(sourceInput).featureScale().eCDF(n)\n// Draw label.\nmakeLabel(sourceArray, distArray)\n`\n\nPrevious\\\\\nEnums Next\\\\\nArrays",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "<namespace>.<functionName>([paramName =] <objectName>, …)",
      "<objectName>.<functionName>(…)",
      "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>"
    ]
  },
  "0a4324c9": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Execution model\n\nIntroduction\n\nPine Script® relies on an event-driven, sequential execution model to control how a script’s compiled source code runs in charts, alerts, Deep Backtesting mode, and the Pine Screener.\n\nIn contrast to the traditional execution model of most programming languages, Pine’s runtime system executes a script _repeatedly_ on the sequence of _historical bars_ and _realtime ticks_ in the dataset on which it runs, performing _separate_ calculations for _each bar_ as it progresses. After each execution on a closed bar, the necessary data from that execution becomes part of an internal time series, and the script can use that data in its calculations on subsequent bars.\n\nThis combination of sequential executions and storage enables programmers to use minimal code to write scripts with dynamic calculations that advance across a dataset bar by bar.\n\nThe execution model and time series structure closely connect to the type system — together, they define how a script behaves as it runs on a dataset. Although it’s possible to write simple scripts without understanding these foundational topics, learning about them and their nuances is key to becoming proficient in Pine Script.\n\nThis page explains the execution model in two parts: The basics and The details. The first part provides quick, actionable information about the model for beginners. The second part offers an _advanced_, in-depth breakdown of the model’s workings and unique behaviors. To make the most of the information on this page, we recommend that newcomers to Pine Script start with The basics, learn about other topics in this manual, and then come back to this page for the advanced details.\n\nThe basics\n\nThe following sections outline core principles of the execution model for beginners. If you are new to Pine Script, start here.\n\nBar-by-bar execution\n\nThe dataset for a symbol on a given timeframe, as shown on a chart, consists of a sequence of bars representing a _time series_. Each bar in the sequence represents the price and volume for a specific time period. The first (leftmost) bar on a chart corresponds to the _earliest_ period, and the last (rightmost) bar corresponds to the _most recent_ period.\n\nMuch of the power of Pine Script stems from its ability to process this time series data efficiently. When a user runs a script, its code does _not_ execute just once; it executes from start to end on _each bar_ in the symbol’s dataset individually, progressing from the first available bar to the most recent bar. Each separate script execution performs calculations or generates outputs (e.g., plots) for a _specific bar_ using the data available on that bar.\n\nA script can retrieve price, volume, and other essential data for each bar on which it executes by using the built-in variables that hold bar information, such as open, high, low, close, and volume. These variables automatically _update_ before each new execution to store the values for the _current bar_.\n\nFor example, the simple script below uses the plot() function to display the series of close values (i.e., the closing price of each bar) on the chart:\n\n//@version=6\nindicator(\"Bar-by-bar execution demo\", overlay = true, behind\\_chart = false)\n\n// Plot the \\close\\ series on the chart.\n// This call defines the plotted point for the current bar on each execution.\nplot(close, \"Close price\", chart.fg\\_color, 5)\n\nWhen a user first adds this script to their chart, its code executes _once_ for _every bar_ in the available dataset. As the script runs on the data, two primary steps occur on each bar:\n\n1. The close variable automatically updates to hold the current bar’s latest price.\n2. The plot() function call plots the updated close value at the current bar’s position.\n\nWhen the script finishes its run from the first bar to the most recent bar, the result is a simple _line plot_ showing the progression of closing prices across the chart’s history:\n\nNote that the above script evaluates the plot() function call once for every bar on the chart, not just once in total. On each separate execution, the call defines the plotted point for the current bar: the chart’s first bar during the first execution, the second bar during the next, and so on.\n\nThis pattern illustrates a key principle of Pine’s execution model: on each successive execution, a script _re-evaluates_ function calls and other expressions within its required _scopes_ to perform separate calculations for the current bar.\n\nRepeated code evaluation also applies to variable declarations. By default, a script does not declare a variable only once throughout its runtime; the script _re-declares_ that variable and assigns an initial value based on the current bar’s data during _each_ new evaluation of its scope.\n\nLet’s look at a simple example. The following script declares an x variable of the “int” type with an initial value of 0. Then, it increases the variable’s value by 10 with the addition assignment operator ( +=). The script calls plot() to display the value of x on each bar in a separate pane:\n\n//@version=6\nindicator(\"Repeated declarations demo\")\n\n//@variable A user-defined variable. The script declares this variable and initializes it to 0 on \\every\\ execution.\nint x = 0\n\n// Increase the value of \\x\\ by 10 on every bar.\nx += 10\n\n// Plot the value of \\x\\.\n// Because \\x\\ begins at 0 on every execution, and the script adds 10 to that value, the plotted value is always 10.\nplot(x, \"\\x\\ value\", color.blue, 3)\n\nAs shown above, the script plots a value of 10 on every bar, because the x variable _does not_ carry over from bar to bar; the script declares the variable _repeatedly_. On each bar, the script re-declares x with an initial value of 0, then adds 10 to that value, resulting in a final value of 10 for every plotted point.\n\nProgrammers can change the behavior of a variable, enabling it to _persist_ and preserve updates to its value _across bars_, by including the var keyword in its declaration, as described in the Declaration modes section of the Variable declarations page.\n\nBelow, we modify the previous script by adding var to the x declaration. Now, the script declares and initializes x only _once_ — on the _first bar_ — and that variable persists across _all_ bars that follow. The script now plots a line that _increases_ by 10 on each bar, because x preserves the result from each addition across the chart’s history. The value changes from 0 to 10 on the first bar, then to 20 on the second, and so on:\n\n//@version=6\nindicator(\"Persistent declarations demo\")\n\n//@variable A \\persistent\\ variable. The script initializes this variable only on the \\first execution\\.\n// The variable preserves all changes to its value on each closed bar.\nvar int x = 0\n\n// Increase the value of \\x\\ by 10 on every bar.\nx += 10\n\n// Plot the \\x\\ series on the chart.\n// Because the script declares \\x\\ using \\var\\ and then increments its value, the value never resets to 0.\n// The plotted value is 10 on the first bar, 20 on the next, and so on.\nplot(x, \"\\x\\ series\", color.blue, 3)\n\nStoring and using data from previous bars\n\nAs a script runs on a dataset, the states of its variables, function calls, and other expressions are automatically _committed (saved)_ to an internal _time series_ on each bar, creating historical trails of previous bar values that the script can access during its calculations on the current bar. The script can use these previous values by doing either of the following:\n\n- Using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The number in the square brackets represents how many _bars back_ from the current bar the script looks to retrieve a past value. For instance, close[1] retrieves the close value from _one bar before_ the current bar, and close[100] retrieves the value from _100 bars back_.\n- Calling the built-in functions that calculate on past values internally, such as ta.*() functions. For instance, ta.change(close, 10) calculates the difference between the current value of close and its value from 10 bars back.\n\nThe example below uses both of the above techniques to perform calculations based on data from previous bars. The script calculates a series of bar-by-bar price returns and plots the result as color-coded columns. It declares two global variables on each bar: priceReturn for the calculated returns, and returnColor for the plot’s color. The priceReturn value is the result of dividing the current one-bar change in closing prices ( ta.change(close, 1)) by the previous bar’s closing price ( close[1]). The returnColor value is color.teal if the current value of priceReturn is higher than the value from the previous bar ( priceReturn[1]), and color.maroon otherwise:\n\n//@version=6\nindicator(\"Storing and using data from previous bars demo\")\n\n//@variable The one-bar price return, based on the current and \\previous\\ bars' \\close\\ values.\n// This variable's final value on each bar automatically becomes part of the internal time series.\nfloat priceReturn = ta.change(close, 1) / close\\[1\\]\n\n//@variable Is \\color.teal\\ if the \\priceReturn\\ value is above the value on the previous bar; \\color.maroon\\ otherwise.\ncolor returnColor = priceReturn > priceReturn\\[1\\] ? color.teal : color.maroon\n\n// Plot the current \\priceReturn\\ value as a column, colored using the value of \\returnColor\\.\nplot(priceReturn, \"Price return\", returnColor, 1, plot.style\\_columns)\n\nNote that:\n\n- This script does _not_ plot a column on bar 0 (the _first_ bar). The priceReturn value is na on that bar, because there is _no previous bar_ available for the script to reference at that point.\n\nRealtime bars\n\nWhen a script first runs on a chart, all _closed_ bars in the accessed dataset are _historical bars_. These bars represent data for elapsed time periods where the final price and volume are _confirmed_. All indicators execute once per historical bar.\n\nWhen the rightmost bar on the chart is _open_, it is a _realtime bar_. Unlike a historical bar, whose values are final, a realtime bar _updates_ its values as new price or volume data becomes available. After the bar closes, it becomes an _elapsed realtime bar_, which is then no longer subject to change as the script runs.\n\nBecause the final values for a realtime bar are _unknown_ until the bar closes, an indicator executes differently on that bar than it does on historical bars. The script executes not once, but repeatedly on the realtime bar — once for each new _update (tick)_ — to _recalculate_ its results using the latest data.\n\nBefore each recalculation on the realtime bar, the data for a script’s variables, expressions, and outputs on that bar is _cleared_, or _reset_. We refer to this process as _rollback_. The purpose of rollback is to revert the script to the same confirmed state it had when the realtime bar opened. This process ensures that the script’s calculations for the bar operate only on the latest available data, without relying on _temporary data_ from the bar’s _previous ticks_.\n\nLet’s look at rollback and recalculation in action. The following script uses ta.stoch() to calculate the Stochastic oscillator based on the close, high, and low values over a specified number of bars, then plots the result in a separate pane. It also calls bgcolor() to highlight the background on each realtime bar — where barstate.isrealtime is true — for visual reference:\n\n//@version=6\nindicator(\"Recalculation on realtime bars demo\")\n\n//@variable The number of bars in the Stochastic calculation. Users can change this value in the \"Settings/Inputs\" tab.\nint lengthInput = input.int(10, \"Length\", 1)\n\n//@variable The Stochastic oscillator, based on the \\close\\, \\high\\, and \\low\\ values over \\lengthInput\\ bars.\nfloat stochastic = ta.stoch(close, high, low, lengthInput)\n\n// Plot the \\stochastic\\ value for each bar.\nplot(stochastic, \"Stochastic %K\", color.teal, 3)\n// Highlight the background of each realtime bar.\nbgcolor(barstate.isrealtime ? color.new(color.purple, 80) : na, title = \"Realtime background highlight\")\n\nWhen we add the script to our chart, it executes once per bar in the chart’s history, from the leftmost bar to the rightmost bar. However, the rightmost bar on our chart is still _open_. Therefore, it is a _realtime bar_, not a historical bar. After the script reaches that bar, it begins executing once for _every new update_ to the bar’s data. Each new script execution calculates on the latest available prices and _replaces_ the bar’s previous result.\n\nFor instance, in the initial image below, the oscillator’s value 10 seconds into the open realtime bar (the one with the purple background) is 32.08:\n\nEvery time the bar updates, rollback _resets_ the script’s data for that bar, and the script _recalculates_ its result using the latest high, low, and close values. Here, halfway through the realtime bar’s period, the oscillator’s plot now shows a value of 16.71:\n\nRecalculation continues for each successive update to the bar. Then, the script reaches the bar’s closing tick, where the prices become _confirmed_. On that tick, the script calculates the oscillator’s final value of 19.35. Afterward, another realtime bar opens, and the pattern of rollback and recalculation continues on that bar:\n\nNote that:\n\n- Only the values for a realtime bar’s _final tick_ become part of the internal time series. The values from ticks _before_ the bar’s close are not saved.\n- The input.int() function returns a value of the “input int” _qualified type_. Values qualified as “input” are established _before_ the first script execution, and they remain consistent throughout the script’s runtime. If the user changes the “Length” input to a new value, the script _restarts_ to perform new calculations across the dataset using that value. See the Inputs page and the Qualifiers section of the Type system page to learn more about script inputs and the “input” qualifier.\n- If the script restarts, all the realtime bars from the previous script run become _historical bars_ in the new run. Therefore, after restarting, the script executes only once on each of those bars and does _not_ highlight their background.\n\nThe details\n\nThe following sections provide in-depth details about Pine’s execution model, including the mechanics of executions on historical bars and realtime bars, which events trigger script executions, and how the runtime system maintains data across executions in a time series format.\n\nExecutions on historical bars\n\nWhen a script loads on the chart or in another location after an execution-triggering event, its compiled source code executes on _every_ accessible bar in the current dataset in order, starting with the first bar.\n\nWhile the script loads, the runtime system performs the following steps for _each bar_ that it accesses:\n\n1. It updates the built-in variables that hold bar information. For instance, the system sets the open, high, low, and close variables to hold the OHLC price values of the bar _before_ each execution.\n2. It executes the script’s compiled code from start to end using the data available as of the current bar.\n3. After the execution ends, the system commits (saves) all necessary data for the current bar to the time series. The script can then access that data from historical buffers during its executions on subsequent bars by using the history-referencing operator or the built-in functions that reference past bars internally.\n\nThese steps repeat for every successive bar up to the most recent bar. After the runtime system completes this process across the dataset, the script’s committed _outputs_ — such as plots, drawings, Pine Logs, and Strategy Tester results — become available to the user.\n\nAll the closed bars on which the script executes while loading are _historical_, because they represent data points that were confirmed before the event that triggered the loading process. By default, all scripts execute once for each historical bar.\n\nLet’s examine a simple indicator to understand how script executions work on historical bars.\n\nThe script below calculates the 20-bar moving average of close values and plots the result on the chart. The color of the plot depends on whether the average is above or below the value on the previous bar. The script also increments an executionNum variable to count code executions, then plots the result alongside bar\\_index for comparison. Additionally, it highlights the background of historical bars in orange for visual reference:\n\n//@version=6\nindicator(\"Executions on historical bars demo\")\n\n//@variable The average of the latest 20 \\close\\ values.\nfloat sma = ta.sma(close, 20)\n\n//@variable Is \\color.green\\ if the \\sma\\ value is above the value on the previous bar; \\color.red\\ otherwise.\ncolor plotColor = sma > sma\\[1\\] ? color.green : color.red\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\sma\\ as a line plot on the main chart pane, colored by the \\plotColor\\.\nplot(sma, \"SMA\", plotColor, 3, force\\_overlay = true)\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nThe statements and expressions in this source code might appear static at first glance. However, they have _dynamic_ behavior across bars because the system executes the script _repeatedly_ — once for each successive data point. Below, we inspect the code step by step to explain how the script works during its historical executions.\n\nThe indicator() call at the top of the code is a declaration statement that defines the script’s type and properties once, at _compile time_. This statement does not execute as the script runs on the dataset:\n\nindicator(\"Executions on historical bars demo\")\n\n_Before_ each script execution on a bar, the runtime system updates the built-in bar\\_index and close variables required in the calculations. The bar\\_index value is the bar’s global _time series index_, where 0 represents the first bar, 1 represents the second, and so on. The close variable holds the bar’s _latest price_. For historical bars, its value is the _final price_ at the bar’s closing time.\n\nEach time that the script executes, it declares and initializes a global sma variable of the “float” type. This variable declaration happens on _every_ execution because the code line does not specify a declaration mode. The variable’s assigned value is the result of a ta.sma() function call. The call returns the average of the latest 20 close values as of the current bar, or na if fewer than 20 bars are available. After the execution ends, the system commits the new value of sma to the time series:\n\n//@variable The average of the latest 20 \\close\\ values.\nfloat sma = ta.sma(close, 20)\n\nNote that:\n\n- The //@variable comment above the sma declaration is an annotation that _documents_ the variable in the code. The Pine Editor displays the comment in a pop-up window when the user hovers the mouse pointer over the variable.\n\nDuring each execution, the script also initializes a plotColor variable of the “color” type. The script uses a ternary operation that compares the current sma value to sma[1] — the _last committed value_ for sma as of the _previous bar_ — to determine the plotColor variable’s assigned value. If the current sma value is higher than the last committed value, the plotColor value is color.green. Otherwise, it is color.red:\n\n//@variable Is \\color.green\\ if the \\sma\\ value is above the value on the previous bar; \\color.red\\ otherwise.\ncolor plotColor = sma > sma\\[1\\] ? color.green : color.red\n\nIn contrast to the variables above, the script _does not_ initialize the executionNum variable on every execution. Instead, initialization happens only _once_ — on the _first_ bar — because the variable declaration is in the _global scope_ and uses the varip keyword. Once initialized, the variable _persists_ across all subsequent bars and the ticks within those bars. Only the reassignment or compound assignment operators can change its value:\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n\nThe code following the executionNum declaration uses the addition assignment operator ( +=) to increase the variable’s value by one on each new execution. Starting from -1, the value increases to 0 on the first execution after initialization, then 1 on the second, and so on:\n\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\nThe script evaluates the plot() and bgcolor() calls on every execution. Each plot() call creates a new point on a line plot at the bar’s location on the time axis. The bgcolor() call creates a background color for the bar based on a ternary expression. The background is translucent orange if barstate.ishistory is true. Otherwise, it is na (no color):\n\n// Display the \\sma\\ as a line plot on the main chart pane, colored by the \\plotColor\\.\nplot(sma, \"SMA\", plotColor, 3, force\\_overlay = true)\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- The plot() and bgcolor() calls that include force_overlay = true display their visuals on the main chart pane. The other plot() calls\noutput visuals in a separate pane, because the indicator() call does not include overlay = true.\n\nAfter the system executes the script on all available data points and finishes loading, the script’s outputs then become visible on the chart:\n\nNote that:\n\n- When the script first loads, _all_ bars, including the latest one, have an orange background because they initially represent _historical_ data. However, the latest bar on our chart is still open, meaning it is a _realtime bar_. After a new tick arrives from the realtime data feed, the bar’s values update, and the script executes _again_ on that bar. The orange background for the bar then _disappears_ because the system sets the value of barstate.ishistory to false.\n- The executionNum and bar\\_index values are identical on historical bars because the script executes _once per bar_ on that part of the dataset. However, they begin to differ on the realtime bar. On that bar, the script executes after _every new update_ to recalculate its results, and the executionNum value increases each time. See the Executions on realtime bars section to learn more.\n- An alternative, more robust method to track code executions is to use the Pine Profiler. The profiler analyzes the total runtime and execution count of every significant part of the source code. To learn more about this feature, see the Profiling and optimization page.\n\nIt’s important to note that, unlike indicators, strategies can execute _more than once_ per historical bar, depending on the specified calculation behavior. If the strategy() declaration statement includes calc_on_order_fills = true, or if the user selects the “After order is filled” checkbox in the “Settings/Properties” tab, the runtime system executes the script on _each available tick_ where the broker emulator fills an order, or once per bar when there is no order to fill.\n\nLet’s look at a simple example. The following strategy changes the direction of its simulated position on each execution. If there is an open short position or no position, the strategy places a market order to close all short trades and enter a long trade. If a long position is open, the strategy places a market order to close it and open a short trade.\n\nAs with the previous example, this script increments an executionNum variable declared with varip to count new executions, plots the result alongside bar\\_index for comparison, and highlights the background of historical bars in orange with bgcolor():\n\n//@version=6\nstrategy(\"Default strategy behavior on historical bars demo\")\n\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position\\_size <= 0\nstrategy.entry(\"Long\", strategy.long)\nelse\nstrategy.entry(\"Short\", strategy.short)\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- The strategy.entry() command creates entry orders. By default, a long entry using this command reverses an open short position, and a short entry reverses an open long position. See the Reversing positions section of the Strategies page to learn more.\n\nThe script above uses the default calculation behavior: it places a new order only at the close of each bar. The broker emulator fills the order at the next bar’s opening price, as the trade markers on the chart above indicate. The executionNum and bar\\_index plots show the same values because the script executes only once per bar.\n\nIf we include calc_on_order_fills = true in the strategy() declaration statement, the runtime system _re-executes_ the script on a bar after each new order fill to update the calculations. Our script’s logic generates a new order on _every_ execution, and the broker emulator considers historical bars to have _four ticks_ for filling orders by default (the open, high, low, and close). Therefore, with this change, the script executes four times per historical bar instead of only once. As shown below, the strategy now shows four trade markers on each historical bar, and the executionNum value is four times that of the bar\\_index variable:\n\n//@version=6\nstrategy(\"Calculation after order fill on historical bars demo\", calc\\_on\\_order\\_fills = true)\n\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position\\_size <= 0\nstrategy.entry(\"Long\", strategy.long)\nelse\nstrategy.entry(\"Short\", strategy.short)\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- This script can execute _more than four_ times per bar if it uses Bar Magnifier mode, because this mode enables the broker emulator to fill orders on historical bars using intrabar prices from a _lower timeframe_.\n- The script can execute numerous times on a _realtime_ bar, depending on the updates from the data feed, because _each new update_ to the bar is a valid tick for filling the strategy’s orders.\n- An alternative way to confirm the script’s increased execution count is to select and clear the “After order is filled” checkbox in the “Settings/Properties” tab while profiling the code.\n\nExecutions on realtime bars\n\nAfter a script running on the chart or in an alert executes across all historical bars in a dataset, the runtime system continues to execute the script on the current bar, if it is open, and on any new bars that form later. We refer to these bars as _realtime bars_, because they represent incoming data from a separate data feed that the script can access only _after_ it finishes loading.\n\nAs explained in the previous section, historical bars represent confirmed data points. By contrast, a realtime bar represents an initially _unconfirmed_ data point that evolves as new updates (ticks) arrive from the realtime data feed. With each new tick, the bar’s high, low, close, volume, and other values update to represent the latest data while the bar remains open. After the bar closes, it becomes an _elapsed realtime bar_, whose values no longer change. Then, a new realtime bar opens after another tick arrives, and that bar updates as new data becomes available.\n\nAs an indicator or library script runs on an open realtime bar, its compiled code executes once after every new update from the data feed. With each new execution, the script recalculates its results for that bar using the latest data. Consequently, the states of the script’s variables, expressions, and objects can _change_ with each new execution while the bar remains open. The system _commits_ the script’s data for the realtime bar only after the bar closes.\n\nAfter each script execution that occurs _before_ a bar’s closing tick, the runtime engine executes a _rollback_ process. Rollback _resets_ applicable script data to the latest committed states in the time series. This process enables the script to recalculate the bar’s results using only the latest available data — without the influence of _temporary_ data from executions on the bar’s previous ticks.\n\nBelow, we explain how recalculation and rollback affect a script’s data and outputs, along with some notable exceptions to this process:\n\nReinitialize variables\n\nThe runtime system erases the states of any variables that the script initializes during its executions before a bar’s close, excluding those declared using the varip keyword. When the script executes again after rollback, it _reinitializes_ the variables with new values or references based on the latest available data.\n\nLikewise, the system does not preserve the _temporary_ states of built-in variables that hold values for the current bar. Before the new script execution, it sets the variables to use the bar’s most recent data. For instance, the system updates close, high, and low with the latest, highest, and lowest prices reported since the bar’s opening time.\n\nReset changes to var variables\n\nVariables that use the var keyword in their declaration are initialized only _once_ — during the _first_ execution of their scopes on a _closed bar_. Variables that use the var keyword in their declaration remain initialized after the _first_ time that their scopes execute on a bar’s _closing tick_. Their assigned values or references _persist_ across subsequent bars, changing only after reassignment or compound assignment operations.\n\nAlthough these variables preserve data across successive bars, they do not preserve data across executions on the _ticks_ of an open bar. Rollback reverts all variables declared with var before the current bar to the last committed states in the time series as of the previous bar.\n\nFor instance, if a variable declared with var has a value of 20 on the open bar and 19 on the previous bar, the variable’s value reverts to 19 before the script executes on the next tick of the same bar. The temporary value of 20 does not persist.\n\nReplace plotted outputs\n\nThe plot*(), bgcolor(), barcolor(), and fill() functions create visual outputs on _every bar_. These outputs are _temporary_ on the open realtime bar. When the script executes again after rollback, the new outputs for the bar from calls to these functions _replace_ the ones from the previous tick.\n\nFor example, when the expression plot(close) executes on the open bar, it displays the bar’s latest close value as of the current execution. However, the plotted result is temporary until the bar closes. After rollback, the close variable updates, then the script calls plot() again on the next execution to replace the output from the previous tick and display the new value.\n\nRemove and revert objects\n\nUser-defined types (UDTs) and special types such as collections and drawing types are _reference types_. They define structures from which scripts create _objects_ — independent entities that store data elsewhere in memory. Variables of these types hold _references_ that provide access to specific objects and their data; the variables do not store objects directly.\n\nIf a script creates objects on an open bar and does not assign their references to variables declared with the varip keyword, the rollback process _removes_ those objects. During the next execution on the open bar, the script creates _new objects_ if the updated logic allows it.\n\nFor example, if a script calls label.new() to create a label object on the open bar, the system _deletes_ that object during rollback. On the next execution, the script evaluates label.new() again, creating a _new_ label that replaces the output. The label created on the previous tick no longer exists.\n\nSimilarly, for objects of built-in or user-defined types with references assigned to var variables, the rollback process reverts any changes to those objects that occur on the open bar. The only exception is for UDTs with _fields_ that include the varip keyword. See the Objects page for more information.\n\nExceptions\n\nThe runtime system does not revert _all_ the data from script executions on an open bar. The following are notable exceptions to the rollback process:\n\n- Variables or fields declared with the varip keyword do not revert to a previously committed state. They persist across _all_ script executions after initialization, even those on the ticks of an open realtime bar.\n- Logged messages in the Pine Logs pane do not disappear after rollback. The messages from any log.*() calls during executions on the ticks of realtime bars remain in the pane until the script reloads.\n- The data from strategy orders placed or filled on the ticks within a bar is not subject to rollback. If a strategy script creates orders or the broker emulator fills orders on an open bar, the data from those events persists.\n- Rollback does not erase logs for alerts from the “Alerts” menu. All messages from a script alert remain visible until the user restarts the alert.\n- Runtime errors from the system or the runtime.error() function completely _stop_ script executions. If an error occurs at any point while a script executes on an open bar, the system halts the script and does not revert the error after new updates from the data feed.\n\nLet’s inspect the behavior of a simple indicator on realtime bars. The following script calculates an RSI of close values using ta.rsi() and displays the result with a plot() call. To track the number of executions that occur _per bar_, the script increments an executions variable declared with varip and calculates its one-bar change using ta.change(). The script converts each bar’s execution count to a string with str.tostring(), then displays the result in a color-coded label at the bar’s high. The label is purple if the bar is open. Otherwise, it is gray. The script also highlights the background of realtime bars in orange using bgcolor():\n\n//@version=6\nindicator(\"Executions on realtime bars demo\")\n\n//@variable The 14-bar RSI of \\close\\ prices.\nfloat rsi = ta.rsi(close, 14)\n\n//@variable Tracks the number of script executions, where 1 represents the first execution.\nvarip int executions = 0\n// Add 1 to the \\executions\\ value.\nexecutions += 1\n\n//@variable Is \\color.gray\\ if the bar is confirmed (closed); \\color.purple\\ otherwise.\ncolor labelColor = barstate.isconfirmed ? color.gray : color.purple\n\n// Calculate the one-bar change in \\executions\\, then convert the value to a string and display the result in a label.\n// Each call to \\label.new()\\ creates a \\new\\ \\label\\ object.\nlabel.new(\nbar\\_index, high, str.tostring(ta.change(executions)),\ncolor = labelColor, textcolor = color.white, size = 20, force\\_overlay = true\n)\n\n// Plot the \\rsi\\ value with colors based on whether the value is above 50 or not.\nplot(rsi, \"RSI\", rsi > 50 ? color.teal : color.maroon, 3)\n\n// Highlight the chart's background in translucent orange when \\barstate.isrealtime\\ is \\true\\.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\", force\\_overlay = true)\n\nWhen we first add the script to the chart, it does _not_ add an orange background to any bar because it calculates only on data that exists at the script’s loading time. This data is _historical_. Each bar’s label shows a value of 1 because indicators always execute _once_ per historical bar:\n\nNotice the countdown timer and the _purple_ label for the latest bar in the chart above. These both indicate that the bar is _open_ and subject to changes. A new update from the data feed affects the bar’s values, triggering rollback and a new script execution to recalculate the results.\n\nWhen rollback occurs, the runtime system reverts the internal data of the ta.rsi() call to its last committed state, erases the state of the rsi variable, and deletes the latest label object. However, the system does not revert the executions variable because it uses the varip keyword.\n\nAfter rollback, the system updates the built-in close, high, and barstate.* variables using the current bar’s latest data, and the new execution begins. The script evaluates the ta.rsi() call using the new close price and reinitializes the rsi variable with the returned value. Then, it increases the executions value by one, evaluates ta.change() again, and creates a new label at the bar’s current high price to show the updated result. Lastly, it evaluates the plot() and bgcolor() calls to replace the bar’s plotted visuals. The last bar’s label remains purple because the bar is still open, but the background color is now _orange_ because barstate.isrealtime is true:\n\nAs subsequent updates become available from the data feed, the pattern of rollback and re-execution continues, and the script’s outputs for the bar update with each new execution:\n\nThe last time that rollback and another execution occur on this bar is after the _closing tick_, when the bar becomes an _elapsed_ realtime bar. After the final execution, the bar’s label is _gray_ because barstate.isconfirmed is true. The runtime system then _commits_ necessary data from this execution to the time series for calculations on future bars.\n\nThen, a new realtime bar opens after another update from the data feed, and the execution pattern continues:\n\nNote that:\n\n- Although the previous bar is now confirmed, it still has an orange background corresponding to a _realtime_ state because it closed after the script’s loading time. When the script later reloads after an execution-triggering event, that bar becomes _historical_.\n\nIt’s important to note that strategies often execute differently than indicators on realtime bars. By default, they execute only once per bar at each _closing tick_ without undergoing rollback. However, users can modify a strategy’s calculation behavior to allow rollback and re-execution on a bar before its closing tick.\n\nIf the strategy() statement includes calc_on_every_tick = true, or if the user selects the “On every tick” checkbox in the “Settings/Properties” tab, the script executes on a realtime bar after _each new update_ from the data feed, similar to an indicator.\n\nAdditionally, if the strategy() statement includes calc_on_order_fills = true or the user selects “After order is filled” in the “Settings/Properties” tab, the script executes on _each tick_ where the broker emulator fills an order. With this behavior, the system can execute the script multiple times on the open bar, but only on the ticks where an _order fill_ occurs.\n\nTo summarize the general process for script executions on realtime bars:\n\n- An indicator or library script executes on the _first available tick_ in an open realtime bar, then _once per update_ to recalculate the results for the bar using the latest data. A strategy script executes only on the bar’s _closing tick_ by default, but users can modify its calculation behavior to allow executions while the bar is open.\n- Before each new script execution on an open bar, the runtime system executes a _rollback_ process, which _reverts_ all applicable variables, expressions, and objects to their _last committed states_ as of the previous bar’s close.\n- After the script executes on an _elapsed_ realtime bar’s closing tick, the system _commits_ necessary data from that execution to the time series for access on later bars. It does not commit the data from executions on the bar’s _unconfirmed_ values from previous ticks.\n\nEvents that trigger script executions\n\nSeveral events cause a script to load and execute across all the available bars in a dataset. The specific events that trigger the loading process depend on where the script runs.\n\nFor a script on the chart, the following events always cause the script to load and perform _new executions_ on every bar:\n\n- The user adds the script to the chart for the first time from the Pine Editor or the “Indicators, metrics, and strategies” menu.\n- The user saves an update to the script while it is active on the chart.\n- The chart is refreshed while the script is active.\n\nOther events also trigger the loading process for a script on the chart. However, these events do not _always_ cause new script executions on past bars. The results from running a script with a unique combination of settings are often temporarily _cached_. If cached data exists for a selected combination of settings, the system loads the script using that data. See the Caching section for more information.\n\nBelow are the additional events that cause a script to load on the chart, either by performing new executions across the dataset or by using available cached data:\n\n- The user selects new values for the inputs or strategy properties in the script’s “Settings” menu.\n- The script uses the chart.left\\_visible\\_bar\\_time or chart.right\\_visible\\_bar\\_time variable, and the visible chart range changes.\n- The script uses the chart.fg\\_color or chart.bg\\_color variable, and the user changes the chart’s background color.\n- The chart loads a new dataset with a different _timeframe_ or _ticker identifier_. Several user actions affect a chart’s ticker ID, such as selecting a symbol from the “Symbol Search” menu, changing the chart type, toggling data modifications in the chart’s settings, and activating Bar Replay mode.\n- The user opens or closes the Pine Logs pane.\n- The user activates or deactivates the Pine Profiler.\n\nFor scripts used in other locations, the following events trigger the loading process:\n\n- The user creates a new script alert from the “Create Alert” dialog box.\n- The user pauses and restarts an alert instance from the “Alerts” menu.\n- The user clicks the “Generate report” button in the Strategy Tester while Deep Backtesting mode is enabled.\n- The user clicks the “Scan” button in the Pine Screener to run the script on the datasets from a chosen watchlist.\n\n_After_ a script loads, either of the following causes new script executions on an _open bar_:\n\n- One of the events above causes the script to load again and execute across the _entire dataset_ up to the bar.\n- The script runs on the chart or in an alert, and the bar updates after new data becomes available. The system performs _rollback_ and re-executes the script on that bar using the latest data. The only exception is if the script is a strategy that does not allow recalculation on the new tick.\n\nWhen a script completely reloads on the chart or in an alert after an applicable event, all the elapsed realtime bars from the script’s previous run become historical bars in the new run, because they represent _confirmed_ data points that the script accesses from _a different data feed_ as it loads.\n\nThe bars in a symbol’s dataset come from two distinct data feeds: the _historical_ feed and the _realtime_ feed. The historical feed reports only the _final_ values for each bar, whereas the realtime feed includes the _temporary_ values from all available ticks. When a realtime bar becomes historical after a script restarts, the values from the bar’s previous ticks are no longer accessible; only the final price, volume, and other values remain. Therefore, if a script relies on temporary data from realtime bars in its calculations, it might behave differently after reloading.\n\nFor example, the following script calculates the one-bar arithmetic return of the close series and displays the result as a line plot. On each realtime bar, the script updates three variables declared with varip to track the first, highest, and lowest return values calculated during executions across the bar’s ticks, then calls plotcandle() to plot a candle showing the values. Additionally, it uses bgcolor() to highlight the background of realtime bars in orange:\n\n//@version=6\nindicator(\"Reloading a script demo\", precision = 5)\n\n//@variable The one-bar arithmetic return of the \\close\\ series.\nfloat priceReturn = ta.change(close, 1) / close\\[1\\]\n\n// Declare persistent variables to track the first, highest, and lowest \\priceReturn\\ values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\n\nif barstate.isrealtime\n// On the first tick in the realtime bar, reassign \\o\\, \\h\\, and \\l\\ to hold the value of \\priceReturn\\.\nif barstate.isnew\no := priceReturn\nh := priceReturn\nl := priceReturn\n// Otherwise, reassign \\h\\ and \\l\\ to the bar's highest and lowest \\priceReturn\\ value as of the current tick.\nelse\nh := math.max(h, priceReturn)\nl := math.min(l, priceReturn)\n\n// Plot candles to display the \\o\\, \\h\\, \\l\\, and \\priceReturn\\ values for each realtime bar.\n// The candles do not appear on historical bars, because \\o\\, \\h\\, and \\l\\ are \\na\\ on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg\\_color, bordercolor = chart.fg\\_color)\n// Dispaly the \\priceReturn\\ series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter the script loads on the chart and executes on several realtime bars, all the elapsed realtime bars, as well as the open realtime bar, include plotted return candles and an orange background color:\n\nAfter an applicable event, such as a chart refresh, the script _reloads_ and executes across the dataset again. All the closed bars with a realtime state in the previous run become _historical_ bars in the new run. The results thus change because our script relies on realtime data. As shown below, the script does not display candles or background colors for previous bars after we refresh the chart. Those outputs appear only for the latest bar, after new ticks become available, because that bar is now the only one with a realtime state:\n\nNote that:\n\n- The barstate.isnew variable has a value of true when a realtime bar opens, and false on all subsequent updates to the bar. If the script reloads midway through a realtime bar’s progression, only the background color appears on that bar. The script does not show a candle on the first realtime bar in that case, because its o, h, and l variables hold na until the first time that barstate.isnew is true.\n\nCaching\n\nWhen a script runs on a chart for the _first time_ using a _unique configuration_, the data from that run is often temporarily cached for reuse. The cached data is erased after the chart is refreshed or the user updates the script’s source code.\n\nIn this context, the configuration refers to the combined state of all script, chart, and developer tool settings that can affect the script’s executions. This combination includes:\n\n- The values of inputs in the script’s “Settings/Inputs” tab.\n- The values of the strategy properties in the “Settings/Properties” tab.\n- The values of the chart.* variables whose qualifiers are “input” ( chart.left\\_visible\\_bar\\_time, chart.right\\_visible\\_bar\\_time, chart.fg\\_color, and chart.bg\\_color).\n- The chart’s timeframe.\n- The chart’s ticker identifier.\n- Whether the Pine Logs pane is open or closed.\n- Whether the Pine Profiler is active or not.\n\nEach time that a script runs using a unique combination of settings, it executes from start to end on each bar in the dataset to perform new calculations. If possible, the script’s data from the run is then cached. If cached data is available on past bars for a selected combination of settings, the runtime system loads the script using that data.\n\nThis behavior enables users to change a script’s inputs, alter the chart, and toggle developer tools without losing information — including bar states — from previous script runs using different settings. Additionally, caching helps reduce loading times and resource requirements when switching between settings or adding multiple instances of the same script to the chart.\n\nTo understand this behavior, let’s revisit the script from the previous section. The script has different behaviors on historical and realtime bars. In the version below, we’ve added a lengthInput variable that holds the value from an input.int() call. The script uses this variable to define the length of the ta.change() calculation and the offset of the history-referencing operator:\n\n//@version=6\nindicator(\"Caching demo\", precision = 5)\n\n//@variable The bar span of the \\priceReturn\\ calculation.\nint lengthInput = input.int(5, \"Length\", 1)\n\n//@variable The arithmetic return of the \\close\\ series across \\lengthInput\\ bars.\nfloat priceReturn = ta.change(close, lengthInput) / close\\[lengthInput\\]\n\n// Declare persistent variables to track the first, highest, and lowest \\priceReturn\\ values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\n\nif barstate.isrealtime\n// On the first tick in the realtime bar, reassign \\o\\, \\h\\, and \\l\\ to hold the value of \\priceReturn\\.\nif barstate.isnew\no := priceReturn\nh := priceReturn\nl := priceReturn\n// Otherwise, reassign \\h\\ and \\l\\ to the bar's highest and lowest \\priceReturn\\ value as of the current tick.\nelse\nh := math.max(h, priceReturn)\nl := math.min(l, priceReturn)\n\n// Plot candles to display the \\o\\, \\h\\, \\l\\, and \\priceReturn\\ values for each realtime bar.\n// The candles do not appear on historical bars, because \\o\\, \\h\\, and \\l\\ are \\na\\ on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg\\_color, bordercolor = chart.fg\\_color)\n// Dispaly the \\priceReturn\\ series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter we add the script to our 1m chart and let it run for a few minutes with a “Length” input value of 5, the script plots candles and highlights the background for the latest few bars, because barstate.isrealtime is true on those bars:\n\nLet’s change the “Length” input to a new value, causing the script to reload and execute across the dataset again. Here, we changed the value from 5 to 10 and let the script execute on some new ticks. The script no longer displays candles and background colors for the same bars after restarting, because it now accesses the data for those formerly realtime bars from the _historical_ data feed:\n\nAs shown above, the realtime bar information from the first run is _not available_ when we change the script’s input to a new value. However, the data from that previous run still exists in memory. If we revert the “Length” input’s value to 5, the candle plot and background colors start on the same bar as the first run:\n\nIf we add a second instance of the script to the chart, using the same settings, the runtime system loads the new instance using the cached data instead of executing it entirely from scratch. As such, its outputs are _identical_ to those from the first script instance, even though we added it to the chart a few bars later:\n\nSimilarly, cached data usually remains available even if we remove the script from our chart and add it again.\n\nTime series\n\nA symbol’s dataset is a form of _time series_ — a sequence of collected values indexed by time. Each bar represents a distinct data point, anchored to a specific time, that contains price and volume data for a particular period. This data format thus shows how a symbol’s values progress across time in successive periodic steps.\n\nPine Script’s internal time series structure follows a similar format. After executing a script on a closed bar’s confirmed values, the runtime system _commits (saves)_ the results of the script’s statements and expressions to internal time series for later use. Each bar with committed data has an assigned _index_ in the series, where 0 represents the first bar, 1 represents the second, and so on. Scripts can retrieve this index with the bar\\_index variable.\n\nScripts can access the data committed to the time series on past bars by using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The value between the operator’s square brackets specifies the position of the referenced bar in the time series as a _relative offset_ behind the current bar. For variables and expressions in the global scope, an offset value of 1 refers to the previous bar at bar_index - 1 (one bar back), a value of 2 refers to the bar at bar_index - 2 (two bars back), and so on. An offset of 0 always refers to the _current bar_.\n\nFor example, consider the open variable, which holds the opening price of the current bar on which the script executes. Before each script execution on a new bar, the runtime system commits the open value from the last execution on the previous bar. Then, it updates the variable to hold the current bar’s opening price. To access the committed open value for the previous bar, we can use the expression open[1]. To access the committed value from 10 bars back, we use open[10].\n\nThe script below performs three history-referencing operations to retrieve the current bar’s open value, the value from one bar back, and the value from a user-specified number of bars back. Then, it plots the retrieved values on the chart for comparison:\n\n//@version=6\nindicator(\"History referencing demo\", overlay = true, behind\\_chart = false)\n\n//@variable The number of bars back from which to retrieve the \\open\\ price for \\pastOpen\\.\nint offsetInput = input.int(10, \"Bar offset\", 0)\n\n//@variable The current bar's opening price. \\open\\[0\\]\\ is equivalent to using \\open\\ without the \\\\[\\]\\ operator.\nfloat currOpen = open\\[0\\]\n//@variable The last committed \\open\\ value. Represents the previous bar's value, or \\na\\ if no previous bar exists.\nfloat prevOpen = open\\[1\\]\n//@variable The \\open\\ value committed \\offsetInput\\ bars back, or \\na\\ if no bar exists at that offset.\nfloat pastOpen = open\\[offsetInput\\]\n\n// Plot \\currOpen\\, \\prevOpen\\, and \\pastOpen\\ for comparison.\nplot(currOpen, \"Current \\open\\\", color.blue, 2)\nplot(prevOpen, \"Previous bar \\open\\\", color.purple, 3)\nplot(pastOpen, \"Past \\open\\ from custom offset\", color.orange, 4)\n\nNote that:\n\n- The expression open[0] is equivalent to using open without the history-referencing operator, because an offset of 0 refers to the current bar.\n- At the beginning of the chart’s dataset, the expressions open[1] and open[offsetInput] return na because they refer to previous bars that are unavailable.\n- Each history-referencing expression also leaves a trail of values in the time series. Therefore, it is possible to retrieve past states of the expression using another history-referencing operation, e.g., (open[offsetInput])[1].\n- Internally, the system maintains a _limited amount_ of time series data for variables and expressions in fixed-length _historical buffers_. These buffers define the _maximum offsets_ allowed for history-referencing operations. See the next section, Historical buffers, to learn more.\n\nAnother way that scripts use committed values from a time series is by calling the built-in functions that reference history internally, such as those in the ta.* namespace. For example, the expression ta.highest(high, 20) calculates the highest value from the high series over a 20-bar window. It compares the series’ current value to the committed values from the previous 19 bars to determine the result. The script below executes this call on each bar and plots the resulting series on the chart. Additionally, the script colors the background of the last 20 bars on the chart to highlight the bars used in the latest execution’s ta.highest() call:\n\n//@version=6\nindicator(\"History referencing in functions demo\", overlay = true, behind\\_chart = false)\n\n//@variable The highest value from the \\high\\ series across the 20 most recent bars.\n// The \\ta.highest()\\ call compares the current \\high\\ to the last 19 committed values.\nfloat highest = ta.highest(high, 20)\n\n// Plot the \\highest\\ series on the chart.\nplot(highest, \"20-bar high\", color.purple, 3)\n\n// Color the background of the last 20 bars, i.e., the bars used by the latest execution's \\ta.highest()\\ call.\nbgcolor(color.new(color.blue, 70), show\\_last = 20, title = \"Last 20 bar highlight\")\n\nNote that:\n\n- The first 19 bars of the chart have a plotted value of na, because the ta.highest() function call requires the high values from the current bar and 19 previous bars to calculate the result.\n- All function calls and expressions that do not return “void” leave historical trails in the time series, just like variables. Therefore, scripts can use an expression such as ta.highest(high, 20)[10] to retrieve the 20-bar high from 10 bars back.\n- The ta.highest() function and other functions that access past values from a time series must execute in the global scope for consistent calculations. Time series storage for variables and expressions in local scopes works _differently_ than that for global values. See the Time series in scopes section for more information.\n\nHistorical buffers\n\nTo promote efficiency and help ensure computing resources remain available for all users, the Pine Script runtime system uses fixed-length _historical buffers_ to maintain a _limited amount_ of time series data for all variables and expressions. These historical buffers define the _maximum_ number of committed data points that a script can access on any bar via the history-referencing operator or the built-in functions that reference past bars internally.\n\nFor most series, the underlying historical buffer can contain data from up to 5000 past bars. The only exception is for some built-in series such as open, close, and time, whose buffers can store data for _more_ than 5000 bars.\n\nAlthough these buffers can contain thousands of data points at their maximum size, a script might not _require_ that much past data for its calculations on any bar. Therefore, the runtime system automatically optimizes the size of each series’ historical buffer based on the historical references that the script performs as it loads on the dataset. Each resulting buffer contains _only_ the amount of past data required by the script’s calculations and _not more_.\n\nFor instance, if the maximum number of bars back for which a script references the value of a variable on historical bars is 500, the system maintains a historical buffer that includes only the latest 500 committed values of that variable. The buffer does not store 5000 committed values, because the script _does not_ require all that extra data. This behavior thus helps to minimize a script’s resource requirements while preserving the integrity of its calculations.\n\nTo determine the sufficient buffer size for each variable and expression in a script, the runtime system performs the following process during the script’s loading time:\n\n1. It analyzes all the historical references that occur while executing the script on the dataset’s first 244 bars, then sets the initial size of each buffer to the minimum size that accommodates those references.\n2. While executing the script on subsequent bars, it checks if the script attempts to access data from previous bars that are beyond the limits of the defined buffers. If the script’s historical references exceed the buffer limits on any bar, the system restarts the loading process and tries a larger buffer size.\n3. In the rare case that a historical buffer’s size remains insufficient after several calculation attempts, the system stops the script and raises a runtime error.\n\nIt’s crucial to emphasize that the runtime system defines the sizes of all historical buffers only while executing a script on _historical bars_. It does not adjust any historical buffers during executions on _new bars_ from the realtime data feed. If a script references past data from beyond a historical buffer’s limits while executing on a realtime bar, it causes a runtime error.\n\nFor example, the script below retrieves a past value from the close series using the history-referencing operator with an offset of 100 bars back on historical bars and 150 bars back on realtime bars. Because the script references data from 100 bars back during all historical executions, the system sets the close buffer’s size to include only 100 past values. Consequently, an error occurs when the script executes on the open realtime bar, because a historical offset of 150 is _beyond_ the buffer’s limit:\n\n//@version=6\nindicator(\"Max bars back error demo\", overlay = true)\n\n// @variable The historical offset for retrieving past values from the \\close\\ series.\n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n\n// @variable The value of \\close\\ from \\offset\\ bars back.\n// This code causes a \\runtime error\\ on a realtime bar. During all code executions on historical bars,\n// the script requires only the latest 100 past values of \\close\\, so the system sets the buffer size to\n// include only the past 100 values. The offset of 150 is thus \\out of bounds\\.\nfloat pastClose = close\\[offset\\]\n\n// Plot the \\pastClose\\ series.\nplot(pastClose, \"Past \\close\\\", chart.fg\\_color, 3)\n\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nFor cases like these, programmers can _manually_ set the size of a historical buffer to ensure it contains a sufficient amount of data by doing any of the following:\n\n- Modify the script to reference the maximum required number of bars back with the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) operator during its execution on the _first bar_.\n- Call the max\\_bars\\_back() function to explicitly set the historical buffer size for a _specific_ series.\n- Include a max_bars_back argument in the indicator() or strategy() declaration statement to set the initial size of _all_ historical buffers.\n\nBelow, we modified the script by including the expression max_bars_back(close, 150), which sets the size of the close buffer to include 150 past values. With the appropriate buffer size manually defined, the script’s history-referencing operation no longer causes an error on realtime bars:\n\n//@version=6\nindicator(\"Manual buffer sizing demo\", overlay = true)\n\n// @variable The historical offset for retrieving past values from the \\close\\ series.\n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n\n// Set the size of the \\close\\ historical buffer to include 150 past values, ensuring the script has exactly\n// the amount of history that it requires on realtime bars.\nmax\\_bars\\_back(close, 150)\n\n// @variable The value of \\close\\ from \\offset\\ bars back.\n// This code no longer causes an error when it executes on a realtime bar, because the historical\n// buffer has an appropriate size defined in advance.\nfloat pastClose = close\\[offset\\]\n\n// Plot the \\pastClose\\ series.\nplot(pastClose, \"Past \\close\\\", chart.fg\\_color, 3)\n\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nTime series in scopes\n\nThe _scope_ of a variable or expression refers to the part of the script where it is defined and accessible in the code. Every script has one _global_ scope and zero or more _local_ scopes.\n\nAll variables and expressions in a script that are outside user-defined functions or methods, conditional structures, loops, and user-defined type or enum type declarations belong to the _global scope_. The script evaluates variables and expressions from this scope _once_ for _every execution_ across bars and ticks in the dataset.\n\nAll functions, methods, conditional structures, and loops create their own _local scopes_. The variables and expressions defined within a local scope belong exclusively to that scope. In contrast to the global scope, a script does _not_ always evaluate a local scope once per execution; the script might evaluate the scope _zero_, _one_, or _several_ times per execution, depending on its logic.\n\nFor the runtime system to commit data from a variable or expression and queue that data into a historical buffer on any bar, a script must _evaluate_ the scope of that variable or expression once when it executes on the bar’s _closing tick_. If the script does not evaluate the scope, the runtime system _cannot_ update the historical buffer for the variable or expression. Similarly, if the script evaluates the scope repeatedly within a loop, the historical buffer cannot store series data for _each_ separate iteration, because each entry in the time series corresponds to a single bar.\n\nTherefore, time series behave differently in global and local scopes: the historical buffers for global variables and expressions _always_ contain committed data for _consecutive_ past bars, whereas the buffers for local variables often contain an inconsistent history of committed data.\n\nWhen a script references the history of a global variable using an expression such as myVariable[1], the historical offset of 1 always refers to the confirmed myVariable value from the _previous bar_. In contrast, when using such an expression with a local variable, the offset of 1 refers to the most recent bar where the script executed the scope. It does not represent a specific number of bars back. Therefore, referencing the history of a local variable can cause _unintended results_.\n\nThe following example demonstrates how the historical buffers for a user-defined function’s local scope behave when a script does not call the function on _every_ bar. The script below contains a custom upDownColor() function, which compares the current value of its source parameter to the last committed value ( source[1]). The function returns color.blue if the current source value is higher than the previous value. Otherwise, it returns color.orange.\n\nThe script uses this function _conditionally_, inside a ternary operation, to determine the color of a plot that shows the remainder from dividing bar\\_index by a specified value. If the remainder variable’s value is nonzero, the operation calls upDownColor(remainder) to calculate the color (blue or orange). If the value is 0, the operation does _not_ use the call and instead returns color.gray. The remainder value _increases_ on each bar, except for when it returns to 0 — causing the gray color. Therefore, a user might expect the plot’s color to be only blue or gray on every bar. However, the color changes to _orange_ on each bar after the one where the color is gray, even though the remainder value on that bar is _higher_ than the value on the previous bar:\n\n//@version=6\nindicator(\"Local historical references demo\")\n\n//@function Returns \\color.blue\\ if \\source\\ is above its last committed value; \\color.orange\\ otherwise.\n// For consistent results, this function should execute on \\every bar\\, because it uses the\n// history-referencing operator on the \\source\\ series.\n//\n// Even if the argument supplied to \\source\\ comes from a global variable, the \\source\\ parameter remains\n// part of the function's \\local scope\\. The system maintains a \\separate historical buffer\\ for the \\source\\\n// series in each function call instance. The buffer contains only the committed \\source\\ values from the bars\n// where the function call occurs. If the call does not occur on a bar, the buffer for \\source\\ contains\n// \\\\no data\\\\ for that bar.\nupDownColor(float source) =>\nsource > source\\[1\\] ? color.blue : color.orange\n\n//@variable The value by which to divide the \\bar\\_index\\ value.\nint divisorInput = input.int(5, \"Divisor\", 1)\n\n//@variable The remainder of dividing \\bar\\_index\\ by \\divisorInput\\.\nfloat remainder = bar\\_index % divisorInput\n\n//@variable Is \\color.orange\\ if \\remainder\\ equals 0, and the result of \\upDownColor(remainder)\\ otherwise.\n// The \\upDownColor()\\ call does not execute on every bar. Therefore, it does \\not\\ always compare the\n// \\remainder\\ value from one bar back to calculate the color. Instead, the function compares the current\n// \\remainder\\ to the value from the last bar where \\remainder\\ is nonzero.\ncolor plotColor = remainder == 0 ? color.gray : upDownColor(remainder)\n\n// Plot the \\remainder\\ series and color it using \\plotColor\\. The plot is orange after each bar where \\remainder == 0\\,\n// because the \\upDownColor()\\ function call does not have data for that bar to use in its logic.\nplot(remainder, \"Remainder\", plotColor, 5)\n\nThe script behaves this way because upDownColor() uses the history-referencing operator on the source series, which is _local_ to the function’s scope, and the script does not call the function on _every_ execution. When the value of remainder is zero, the _first_ expression in the ternary condition evaluates to true, and therefore the second branch of the ternary expression, which contains the function call, does _not_ execute.\n\nThe compiler issues the following warning about the function directly in the Pine Editor:\n\n``\n\nThe function upDownColor() should be called on each calculation for consistency. It is recommended to extract the call from the ternary operator or from the scope.\n`\n\nThe runtime system maintains a separate historical buffer for the local source series, but it cannot update that buffer unless the script _calls_ the function. On each bar where remainder is 0, the call does not occur, and the system has no new value to commit to the time series. Therefore, the source buffer does _not_ contain the value of remainder, or even an na value, for that bar. On the bar that follows, the local expression source[1] refers to the source value from the last bar where the upDownColor() call occurs — _two bars back_ — and not the value of remainder from the previous bar. Because the value from two bars back is _higher_ than the current value, the returned color is color.orange instead of color.blue.\n\nWe can fix this script’s behavior by following the instructions in the compiler warning. Below, we modified the script by moving the upDownColor() call _outside_ the ternary expression, enabling the script to execute it on _every bar_. The historical buffer for the function’s source series now contains remainder values from _consecutive_ bars. With this change, an orange color does not appear because the function consistently compares values from _one_ bar back:\n\n//@version=6\nindicator(\"Consistent historical references demo\")\n\n//@function Returns \\color.blue\\ if \\source\\ is above its last committed value; \\color.orange\\ otherwise.\n// For consistent results, this function should execute on \\every bar\\, because it uses the\n// history-referencing operator on the \\source\\ series.\nupDownColor(float source) =>\nsource > source\\[1\\] ? color.blue : color.orange\n\n//@variable The value by which to divide the \\bar\\_index\\ value.\nint divisorInput = input.int(5, \"Divisor\", 1)\n\n//@variable The remainder of dividing \\bar\\_index\\ by \\divisorInput\\.\nfloat remainder = bar\\_index % divisorInput\n\n//@variable Is \\color.blue\\ if \\remainder\\ is above its previous value, and \\color.orange\\ otherwise.\ncolor secondColor = upDownColor(remainder)\n\n//@variable \\color.orange\\ if \\remainder\\ equals 0, and \\secondColor\\ otherwise.\n// This ternary operation no longer causes a warning. The scope of the \\upDownColor()\\ call executes on\n// every bar, meaning its historical buffer consistently includes data for consecutive past bars.\ncolor plotColor = remainder == 0 ? color.gray : secondColor\n\n// Plot the \\remainder\\ series and color it using \\plotColor\\. The plot is now blue or gray, but never orange.\nplot(remainder, \"Remainder\", plotColor, 5)\n\nThis behavior also applies to all built-in functions that reference past values internally, such as those in the ta.* namespace. For example, the ta.sma() function uses the current value of a source series and length - 1 past values from that series to calculate a moving average. If a script calls this function only on _some_ bars instead of on _every_ bar, the historical buffer for source does not contain values for consecutive past bars. Therefore, such a call can cause unintended results, because the call calculates the returned average using an inconsistent history of values from previous bars.\n\nThe script below demonstrates how the results of the ta.sma() function can vary with the scope in which the function call occurs. The script declares three global variables to hold calculated SMA values: controlSMA, localSMA, and globalSMA. The script initializes controlSMA using the result of a ta.sma() function call, and it initializes the other two variables with na. Within the if structure, the script updates the value of globalSMA, and it updates localSMA using the result of another ta.sma() call with the same arguments as the first call.\n\nAs shown below, the controlSMA and globalSMA have the same value. Both use the result of the _global_ ta.sma() call, which executes on _every bar_. The internal historical buffer for source in that call thus includes committed values for consecutive past bars. In contrast, the localSMA value differs, because the ta.sma() call for that variable does _not_ execute on every bar. The buffer for that call’s local source series contains only the values from bars with an _even_ bar\\_index value:\n\n//@version=6\nindicator(\"\\ta.\\*()\\ functions in scopes demo\", overlay = true, behind\\_chart = false)\n\n//@variable Is \\true\\ if the \\bar\\_index\\ is divisible by 2, and \\false\\ otherwise.\nbool condition = bar\\_index % 2 == 0\n\n//@variable The 20-bar moving average of \\close\\ values.\n// This \\ta.sma()\\ call executes in the global scope, so the script evaluates it on every bar.\nfloat controlSMA = ta.sma(close, 20)\n\n// Declare two additional variables to modify later within the \\if\\ structure's scope.\nfloat globalSMA = na\nfloat localSMA = na\n\nif condition\n// Assign the \\controlSMA\\ value to \\globalSMA\\. This code does not cause a warning.\nglobalSMA := controlSMA\n\n// Call \\ta.sma()\\ with the same arguments as before within this block and assign the result to \\localSMA\\.\n// The function call causes a warning, because it does not execute in the global scope.\n// The historical buffers for this \\ta.sma()\\ call contain data only for the bars where \\condition\\ is \\true\\,\n// thus leading to a \\different\\ result.\nlocalSMA := ta.sma(close, 20)\n\n// Plot \\controlSMA\\, \\globalSMA\\, and \\localSMA\\` for comparison.\nplot(controlSMA, \"Control SMA\", color.blue, 2)\nplot(globalSMA, \"Global SMA\", color.purple, 3, style = plot.style\\_circles)\nplot(localSMA, \"Local SMA\", color.gray, 3, style = plot.style\\_circles)\n\nTo summarize the behavior of time series in a script’s scopes:\n\n- A script evaluates its global scope once on _every execution_. After each script execution on a bar’s closing tick, the system commits the data for variables and expressions in the global scope and updates their historical buffers. The resulting buffers thus include data for consecutive past bars, ensuring consistent results for operations and functions that rely on past data.\n- A script evaluates local scopes _zero_, _one_, or _several_ times per execution. The runtime system cannot maintain consistent bar-by-bar historical buffers for scopes that a script does _not_ evaluate on every bar, or for scopes that the script evaluates _more than once_ on a bar’s closing tick. Therefore, using the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) operator on local variables and expressions, or not calling functions that access past data once on each closing tick, can cause unintended results.\n\nNext\\\\\nType system",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "The function `upDownColor()` should be called on each calculation for consistency. It is recommended to extract the call from the ternary operator or from the scope."
    ]
  },
  "7842e0f8": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Conditional structures\n\nIntroduction\n\nThe conditional structures in Pine Script® are\nif and\nswitch.\nThey can be used:\n\n- For their side effects, i.e., when they don’t return a value but do\nthings, like reassign values to variables or call functions.\n- To return a value or a tuple which can then be assigned to one (or\nmore, in the case of tuples) variable.\n\nConditional structures, like the\nfor and\nwhile\nstructures, can be embedded; you can use an\nif or\nswitch\ninside another structure.\n\nSome Pine Script built-in functions are not callable from within the\nlocal blocks of conditional structures, including barcolor(), bgcolor(), plot(), plotshape(), plotchar(), plotarrow(), plotcandle(), plotbar(), hline(), fill(), alertcondition(), indicator(), strategy(), and library().\n\nThis restriction does not entail their functionality cannot be controlled by\nconditions evaluated by your script — only that it cannot be done by\nincluding them in conditional structures. Note that while input*.()\nfunction calls are allowed in local blocks, their functionality is the\nsame as if they were in the script’s _global scope_.\n\nThe local blocks in conditional structures must be indented by four\nspaces or a tab.\n\n​ if ​ structure\n\n​ if ​ used for its side effects\n\nAn if\nstructure used for its side effects has the following syntax:\n\n``\n\nif <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <expression> must be of “bool” type or be auto-castable to that\ntype, which is only possible for “int” or “float” values (see\nthe Type system page).\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- There can be zero or more else if clauses.\n- There can be zero or one else clause.\n\nWhen the <expression> following the\nif\nevaluates to\ntrue,\nthe first local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen the <expression> following the\nif\nevaluates to\nfalse,\nthe successive else if clauses are evaluated, if there are any. When\nthe <expression> of one evaluates to\ntrue,\nits local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to\ntrue\nand an else clause exists, its local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to true and no else clause exists, na is returned. The only exception to this is if the structure returns “bool” values — in that case, false is returned instead.\n\nUsing if\nstructures for their side effects can be useful to manage the order flow\nin strategies, for example. While the same functionality can often be\nachieved using the when parameter in strategy.*() calls, code using\nif\nstructures is easier to read:\n\nif (ta.crossover(source, lower))\nstrategy.entry(\"BBandLE\", strategy.long, stop=lower,\noca\\_name=\"BollingerBands\",\noca\\_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\nstrategy.cancel(id=\"BBandLE\")\n\nRestricting the execution of your code to specific bars ican be done\nusing if\nstructures, as we do here to restrict updates to our label to the\nchart’s last bar:\n\n//@version=6\nindicator(\"\", \"\", true)\nvar ourLabel = label.new(bar\\_index, na, na, color = color(na), textcolor = color.orange)\nif barstate.islast\nlabel.set\\_xy(ourLabel, bar\\_index + 2, hl2\\[1\\])\nlabel.set\\_text(ourLabel, str.tostring(bar\\_index + 1, \"bars in chart\"))\n\nNote that:\n\n- We initialize the ourLabel variable on the script’s first bar\nonly, as we use the\nvar\ndeclaration mode. The value used to initialize the variable is\nprovided by the\nlabel.new()\nfunction call, which returns a label ID pointing to the label it\ncreates. We use that call to set the label’s properties because\nonce set, they will persist until we change them.\n- What happens next is that on each successive bar the Pine Script\nruntime will skip the initialization of ourLabel, and the\nif\nstructure’s condition\n( barstate.islast)\nis evaluated. It returns false on all bars until the last one, so\nthe script does nothing on most historical bars after bar zero.\n- On the last bar,\nbarstate.islast\nbecomes true and the structure’s local block executes, modifying on\neach chart update the properties of our label, which displays the\nnumber of bars in the dataset.\n- We want to display the label’s text without a background, so we\nmake the label’s background\nna\nin the\nlabel.new()\nfunction call, and we use hl2[1] for the label’s _y_ position\nbecause we don’t want it to move all the time. By using the average\nof the previous bar’s\nhigh\nand\nlow\nvalues, the label doesn’t move until the moment when the next\nrealtime bar opens.\n- We use bar_index + 2 in our\nlabel.set\\_xy()\ncall to offset the label to the right by two bars.\n\n​ if ​ used to return a value\n\nAn if\nstructure used to return one or more values has the following syntax:\n\n`\n\n[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed. If other local blocks return “bool” values, false will be returned instead.\n\nThis is an example:\n\n//@version=6\nindicator(\"\", \"\", true)\nstring barState = if barstate.islastconfirmedhistory\n\"islastconfirmedhistory\"\nelse if barstate.isnew\n\"isnew\"\nelse if barstate.isrealtime\n\"isrealtime\"\nelse\n\"other\"\n\nf\\_print(\\_text) =>\nvar table \\_t = table.new(position.middle\\_right, 1, 1)\ntable.cell(\\_t, 0, 0, \\_text, bgcolor = color.yellow)\nf\\_print(barState)\n\nIt is possible to omit the _else_ block. In this case, if the\ncondition is false, an _empty_ value ( na, false, or \"\") will be\nassigned to the var_declarationX variable.\n\nThis is an example showing how\nna is\nreturned when no local block is executed. If close > open is false\nin here,\nna is\nreturned:\n\nx = if close > open\nclose\n\nScripts can contain if structures with nested if and other\nconditional structures. For example:\n\nif condition1\nif condition2\nif condition3\nexpression\n\nHowever, nesting these structures is not recommended from a performance\nperspective. When possible, it is typically more optimal to compose a\nsingle if statement with multiple logical operators rather than\nseveral nested if blocks:\n\nif condition1 and condition2 and condition3\nexpression\n\n​ switch ​ structure\n\nThe\nswitch\nstructure exists in two forms. One switches on the different values of a\nkey expression:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nThe other form does not use an expression as a key; it switches on the\nevaluation of different expressions:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed.\n- The => <local_block> at the end allows you to specify a return\nvalue which acts as a default to be used when no other case in the\nstructure is executed.\n\nOnly one local block of a\nswitch\nstructure is executed. It is thus a _structured switch_ that doesn’t\n_fall through_ cases. Consequently, break statements are unnecessary.\n\nBoth forms are allowed as the value used to initialize a variable.\n\nAs with the\nif\nstructure, if no local block is exectuted,\nthe expression returns either false (when other local blocks return a “bool” value) or na (in all other cases).\n\n​ switch ​ with an expression\n\nLet’s look at an example of a\nswitch\nusing an expression:\n\n//@version=6\nindicator(\"Switch using an expression\", \"\", true)\n\nstring maType = input.string(\"EMA\", \"MA type\", options = \\[\"EMA\", \"SMA\", \"RMA\", \"WMA\"\\])\nint maLength = input.int(10, \"MA length\", minval = 2)\n\nfloat ma = switch maType\n\"EMA\" => ta.ema(close, maLength)\n\"SMA\" => ta.sma(close, maLength)\n\"RMA\" => ta.rma(close, maLength)\n\"WMA\" => ta.wma(close, maLength)\n=\\>\nruntime.error(\"No matching MA type found.\")\nfloat(na)\n\nplot(ma)\n\nNote that:\n\n- The expression we are switching on is the variable maType, which\nis of “input int” type (see here for an explanation of what the\n“ input” qualifier is). Since it cannot change during the\nexecution of the script, this guarantees that whichever MA type the\nuser selects will be executing on each bar, which is a requirement\nfor functions like\nta.ema()\nwhich require a “simple int” argument for their length\nparameter.\n- If no matching value is found for maType, the\nswitch\nexecutes the last local block introduced by =>, which acts as a\ncatch-all. We generate a runtime error in that block. We also end it\nwith float(na) so the local block returns a value whose type is\ncompatible with that of the other local blocks in the structure, to\navoid a compilation error.\n\n​ switch ​ without an expression\n\nThis is an example of a\nswitch\nstructure which does not use an expression:\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\n\nbool longCondition = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\nlongCondition => strategy.entry(\"Long ID\", strategy.long)\nshortCondition => strategy.entry(\"Short ID\", strategy.short)\n\nNote that:\n\n- We are using the\nswitch\nto select the appropriate strategy order to emit, depending on\nwhether the longCondition or shortCondition “bool” variables\nare true.\n- The building conditions of longCondition and shortCondition are\nexclusive. While they can both be false simultaneously, they\ncannot be true at the same time. The fact that only one local\nblock of the\nswitch\nstructure is ever executed is thus not an issue for us.\n- We evaluate the calls to\nta.crossover()\nand\nta.crossunder() prior to entry in the\nswitch\nstructure. Not doing so, as in the following example, would prevent\nthe functions to be executed on each bar, which would result in a\ncompiler warning and erratic behavior:\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\n\nswitch\n// Compiler warning! Will not calculate correctly!\nta.crossover( ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Long ID\", strategy.long)\nta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Short ID\", strategy.short)\n\nMatching local block type requirement\n\nWhen multiple local blocks are used in structures, the type of the\nreturn value of all its local blocks must match. This applies only if\nthe structure is used to assign a value to a variable in a declaration,\nbecause a variable can only have one type, and if the statement returns\ntwo incompatible types in its branches, the variable type cannot be\nproperly determined. If the structure is not assigned anywhere, its\nbranches can return different values.\n\nThis code compiles fine because\nclose\nand\nopen\nare both of the float type:\n\nx = if close > open\nclose\nelse\nopen\n\nThis code does not compile because the first local block returns a\nfloat value, while the second one returns a string, and the result\nof the if-statement is assigned to the x` variable:\n\n// Compilation error!\nx = if close > open\nclose\nelse\n\"open\"\n\nPrevious\\\\\nOperators Next\\\\\nLoops",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>"
    ]
  },
  "3fba4c19": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nMethods\n\nIntroduction\n\nPine Script methods are specialized functions associated with values of specific built-in types,\nuser-defined types, or enum types.\nThey behave the same as regular functions in most regards while offering a shorter, more convenient syntax.\nUsers can access methods using _dot notation_ syntax on variables of the associated type, similar to accessing the fields\nof a Pine Script object.\n\nBuilt-in methods\n\nPine Script includes built-in methods for all _special types_,\nincluding\narray,\nmatrix,\nmap,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\nand\ntable.\nThese methods provide users with a more concise way to call specialized\nroutines for these types within their scripts.\n\nWhen using these special types, the expressions:\n\n``\n\n<namespace>.<functionName>([paramName =] <objectName>, …)\n`\n\nand:\n\n`\n\n<objectName>.<functionName>(…)\n`\n\nare equivalent. For example, rather than using:\n\narray.get(id, index)\n\nto get the value from an array id at the specified index, we can\nsimply use:\n\nid.get(index)\n\nto achieve the same effect. This notation eliminates the need for users\nto reference the function’s namespace, as\nget()\nis a method of id in this context.\n\nWritten below is a practical example to demonstrate the usage of\nbuilt-in methods in place of functions.\n\nThe following script computes Bollinger Bands over a specified number of\nprices sampled once every n bars. It calls\narray.push()\nand\narray.shift()\nto queue sourceInput values through the sourceArray, then\narray.avg()\nand\narray.stdev()\nto compute the sampleMean and sampleDev. The script then uses these\nvalues to calculate the highBand and lowBand, which it plots on the\nchart along with the sampleMean:\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\n\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\n\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float sampleMean = na\nvar float sampleDev = na\n\n// Identify if \\n\\ bars have passed.\nif bar\\_index % n == 0\n// Update the queue.\narray.push(sourceArray, sourceInput)\narray.shift(sourceArray)\n// Update the mean and standard deviaiton values.\nsampleMean := array.avg(sourceArray)\nsampleDev := array.stdev(sourceArray) \\* multiplier\n\n// Calculate bands.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\n\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nLet’s rewrite this code to utilize methods rather than built-in\nfunctions. In this version, we have replaced all built-in\narray.*() function calls in the script with equivalent method calls:\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\n\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\n\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float sampleMean = na\nvar float sampleDev = na\n\n// Identify if \\n\\ bars have passed.\nif bar\\_index % n == 0\n// Update the queue.\nsourceArray.push(sourceInput)\nsourceArray.shift()\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() \\* multiplier\n\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\n\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nNote that:\n\n- We call the array methods using sourceArray.* rather than\nreferencing the\narray\nnamespace.\n- We do not include sourceArray as a parameter when we call the\nmethods since they already reference the object.\n\nUser-defined methods\n\nPine Script allows users to define custom methods for use with objects\nof any built-in or user-defined type. Defining a method is essentially\nthe same as defining a function, but with two key differences:\n\n- The\nmethod\nkeyword must be included before the function name.\n- The type of the first parameter in the signature must be explicitly\ndeclared, as it represents the type of object that the method will\nbe associated with.\n\n`\n\n[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>\n`\n\nLet’s apply user-defined methods to our previous Bollinger Bands\nexample to encapsulate operations from the global scope, which will\nsimplify the code and promote reusability. See this portion from the\nexample:\n\n// Identify if \\n\\ bars have passed.\nif bar\\_index % n == 0\n// Update the queue.\nsourceArray.push(sourceInput)\nsourceArray.shift()\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() \\* multiplier\n\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\n\nWe will start by defining a simple method to queue values through an\narray in a single call.\n\nThis maintainQueue() method invokes the\npush()\nand\nshift()\nmethods on a srcArray when takeSample is true and returns the\nobject:\n\n// @function Maintains a queue of the size of \\srcArray\\.\n// It appends a \\value\\ to the array and removes its oldest element at position zero.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new \\value\\ is only pushed into the queue if this is true.\n// @returns (array<float>) \\srcArray\\ object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\n\nNote that:\n\n- Just as with user-defined functions, we use the @function compiler annotation to document method descriptions.\n\nNow we can replace sourceArray.push() and sourceArray.shift() with\nsourceArray.maintainQueue() in our example:\n\n// Identify if \\n\\ bars have passed.\nif bar\\_index % n == 0\n// Update the queue.\nsourceArray.maintainQueue(sourceInput)\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() \\* multiplier\n\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\n\nFrom here, we will further simplify our code by defining a method that\nhandles all Bollinger Band calculations within its scope.\n\nThis calcBB() method invokes the\navg()\nand\nstdev()\nmethods on a srcArray to update mean and dev values when\ncalculate is true. The method uses these values to return a tuple\ncontaining the basis, upper band, and lower band values respectively:\n\n// @function Computes Bollinger Band values from an array of data.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate (bool) The method will only calculate new values when this is true.\n// @returns A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\nvar float mean = na\nvar float dev = na\nif calculate\n// Compute the mean and standard deviation of the array.\nmean := srcArray.avg()\ndev := srcArray.stdev() \\* mult\n\\[mean, mean + dev, mean - dev\\]\n\nWith this method, we can now remove Bollinger Band calculations from the\nglobal scope and improve code readability:\n\n// Identify if \\n\\ bars have passed.\nbool newSample = bar\\_index % n == 0\n\n// Update the queue and compute new BB values on each new sample.\n\\[sampleMean, highBand, lowBand\\] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\n\nNote that:\n\n- Rather than using an if block in the global scope, we have\ndefined a newSample variable that is only true once every n\nbars. The maintainQueue() and calcBB() methods use this\nvalue for their respective takeSample and calculate\nparameters.\n- Since the maintainQueue() method returns the object that it\nreferences, we’re able to call calcBB() from the same line of\ncode, as both methods apply to array<float> instances.\n\nHere is how the full script example looks now that we’ve applied our\nuser-defined methods:\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\n\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\n\nvar array<float> sourceArray = array.new<float>(samplesInput)\n\n// @function Maintains a queue of the size of \\srcArray\\.\n// It appends a \\value\\ to the array and removes its oldest element at position zero.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new \\value\\ is only pushed into the queue if this is true.\n// @returns (array<float>) \\srcArray\\ object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\n\n// @function Computes Bollinger Band values from an array of data.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate (bool) The method will only calculate new values when this is true.\n// @returns A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\nvar float mean = na\nvar float dev = na\nif calculate\n// Compute the mean and standard deviation of the array.\nmean := srcArray.avg()\ndev := srcArray.stdev() \\* mult\n\\[mean, mean + dev, mean - dev\\]\n\n// Identify if \\n\\ bars have passed.\nbool newSample = bar\\_index % n == 0\n\n// Update the queue and compute new BB values on each new sample.\n\\[sampleMean, highBand, lowBand\\] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\n\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nMethod overloading\n\nUser-defined methods can override and overload existing built-in and\nuser-defined methods with the same identifier. This capability allows\nusers to define multiple routines associated with different parameter\nsignatures under the same method name.\n\nAs a simple example, suppose we want to define a method to identify a\nvariable’s type. Since we must explicitly specify the type of object\nassociated with a user-defined method, we will need to define overloads\nfor each type that we want it to recognize.\n\nBelow, we have defined a getType() method that returns a string\nrepresentation of a variable’s type with overloads for the five\nprimitive types:\n\n// @function Identifies an object's type.\n// @param this Object to inspect.\n// @returns (string) A string representation of the type.\nmethod getType(int this) =>\nna(this) ? \"int(na)\" : \"int\"\n\nmethod getType(float this) =>\nna(this) ? \"float(na)\" : \"float\"\n\nmethod getType(bool this) =>\n// \"bool\" values only have two states, \\true\\ and \\false\\, but never \\na\\.\n\"bool\"\n\nmethod getType(color this) =>\nna(this) ? \"color(na)\" : \"color\"\n\nmethod getType(string this) =>\nna(this) ? \"string(na)\" : \"string\"\n\nNow we can use these overloads to inspect some variables. This script\nuses\nstr.format()\nto format the results from calling the getType() method on five\ndifferent variables into a single results string, then displays the\nstring in the lbl label using the built-in\nset\\_text()\nmethod:\n\n//@version=6\nindicator(\"Type Inspection\")\n\n// @function Identifies an object's type.\n// @param this Object to inspect.\n// @returns (string) A string representation of the type.\nmethod getType(int this) =>\nna(this) ? \"int(na)\" : \"int\"\n\nmethod getType(float this) =>\nna(this) ? \"float(na)\" : \"float\"\n\nmethod getType(bool this) =>\nna(this) ? \"bool(na)\" : \"bool\"\n\nmethod getType(color this) =>\nna(this) ? \"color(na)\" : \"color\"\n\nmethod getType(string this) =>\nna(this) ? \"string(na)\" : \"string\"\n\na = 1\nb = 1.0\nc = true\nd = color.white\ne = \"1\"\n\n// Inspect variables and format results.\nresults = str.format(\n\"a: {0}\\\\nb: {1}\\\\nc: {2}\\\\nd: {3}\\\\ne: {4}\",\na.getType(), b.getType(), c.getType(), d.getType(), e.getType()\n)\n\nvar label lbl = label.new(0, 0)\nlbl.set\\_x(bar\\_index)\nlbl.set\\_text(results)\n\nNote that:\n\n- The underlying type of each variable determines which overload\nof getType() the compiler will use.\n- The method will append “(na)” to the output string when a\nvariable is na to demarcate that it is empty.\n\nAdvanced example\n\nLet’s apply what we’ve learned to construct a script that estimates\nthe cumulative distribution of elements in an array, meaning the\nfraction of elements in the array that are less than or equal to any\ngiven value.\n\nThere are many ways in which we could choose to tackle this objective.\nFor this example, we will start by defining a method to replace elements\nof an array, which will help us count the occurrences of elements within\na range of values.\n\nWritten below is an overload of the built-in\nfill()\nmethod for array<float> instances. This overload replaces elements in\na srcArray within the range between the lowerBound and upperBound\nwith an innerValue, and replaces all elements outside the range with\nan outerValue:\n\n// @function Replaces elements in a \\srcArray\\ between \\lowerBound\\ and \\upperBound\\ with an \\innerValue\\,\n// and replaces elements outside the range with an \\outerValue\\.\n// @param srcArray (array<float>) Array to modify.\n// @param innerValue (float) Value to replace elements within the range with.\n// @param outerValue (float) Value to replace elements outside the range with.\n// @param lowerBound (float) Lowest value to replace with \\innerValue\\.\n// @param upperBound (float) Highest value to replace with \\innerValue\\.\n// @returns (array<float>) \\srcArray\\ object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\nfor \\[i, element\\] in srcArray\nif (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\nsrcArray.set(i, innerValue)\nelse\nsrcArray.set(i, outerValue)\nsrcArray\n\nWith this method, we can filter an array by value ranges to produce an\narray of occurrences. For example, the expression:\n\nsrcArray.copy().fill(1.0, 0.0, min, val)\n\ncopies the srcArray object, replaces all elements between min and\nval with 1.0, then replaces all elements above val with 0.0. From\nhere, it’s easy to estimate the output of the cumulative distribution\nfunction at the val, as it’s simply the average of the resulting\narray:\n\nsrcArray.copy().fill(1.0, 0.0, min, val).avg()\n\nNote that:\n\n- The compiler will only use this fill() overload instead of the\nbuilt-in when the user provides innerValue, outerValue,\nlowerBound, and upperBound arguments in the call.\n- If either lowerBound or upperBound is na, its value is\nignored while filtering the fill range.\n- We are able to call copy(), fill(), and avg() successively\non the same line of code because the first two methods return an\narray<float> instance.\n\nWe can now use this to define a method that will calculate our empirical\ndistribution values. The following eCDF() method estimates a number of\nevenly spaced ascending steps from the cumulative distribution\nfunction of a srcArray and pushes the results into a cdfArray:\n\n// @function Estimates the empirical CDF of a \\srcArray\\.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps (int) Number of steps in the estimation.\n// @returns (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range() / steps\narray<float> cdfArray = array.new<float>()\n// Add averages of \\srcArray\\ filtered by value region to the \\cdfArray\\.\nfloat val = min\nfor i = 1 to steps\nval += rng\ncdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\ncdfArray\n\nLastly, to ensure that our eCDF() method functions properly for arrays\ncontaining small and large values, we will define a method to normalize\nour arrays.\n\nThis featureScale() method uses array\nmin()\nand\nrange()\nmethods to produce a rescaled copy of a srcArray. We will use this to\nnormalize our arrays prior to invoking the eCDF() method:\n\n// @function Rescales the elements within a \\srcArray\\ to the interval \\[0, 1\\].\n// @param srcArray (array<float>) Array to normalize.\n// @returns (array<float>) Normalized copy of the \\srcArray\\.\nmethod featureScale(array<float> srcArray) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range()\narray<float> scaledArray = array.new<float>()\n// Push normalized \\element\\ values into the \\scaledArray\\.\nfor element in srcArray\nscaledArray.push((element - min) / rng)\nscaledArray\n\nNote that:\n\n- This method does not include special handling for divide by zero\nconditions. If rng is 0, the value of the array element will\nbe na.\n\nThe full example below queues a sourceArray of size length with\nsourceInput values using our previous maintainQueue() method,\nnormalizes the array’s elements using the featureScale() method, then\ncalls the eCDF() method to get an array of estimates for n evenly\nspaced steps on the distribution. The script then calls a user-defined\nmakeLabel() function to display the estimates and prices in a label on\nthe right side of the chart:\n\n//@version=6\nindicator(\"Empirical Distribution\", overlay = true)\n\nfloat sourceInput = input.source(close, \"Source\")\nint length = input.int(20, \"Length\")\nint n = input.int(20, \"Steps\")\n\n// @function Maintains a queue of the size of \\srcArray\\.\n// It appends a \\value\\ to the array and removes its oldest element at position zero.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new \\value\\ is only pushed into the queue if this is true.\n// @returns (array<float>) \\srcArray\\ object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\n\n// @function Replaces elements in a \\srcArray\\ between \\lowerBound\\ and \\upperBound\\ with an \\innerValue\\,\n// and replaces elements outside the range with an \\outerValue\\.\n// @param srcArray (array<float>) Array to modify.\n// @param innerValue (float) Value to replace elements within the range with.\n// @param outerValue (float) Value to replace elements outside the range with.\n// @param lowerBound (float) Lowest value to replace with \\innerValue\\.\n// @param upperBound (float) Highest value to replace with \\innerValue\\.\n// @returns (array<float>) \\srcArray\\ object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\nfor \\[i, element\\] in srcArray\nif (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\nsrcArray.set(i, innerValue)\nelse\nsrcArray.set(i, outerValue)\nsrcArray\n\n// @function Estimates the empirical CDF of a \\srcArray\\.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps (int) Number of steps in the estimation.\n// @returns (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range() / steps\narray<float> cdfArray = array.new<float>()\n// Add averages of \\srcArray\\ filtered by value region to the \\cdfArray\\.\nfloat val = min\nfor i = 1 to steps\nval += rng\ncdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\ncdfArray\n\n// @function Rescales the elements within a \\srcArray\\ to the interval \\[0, 1\\].\n// @param srcArray (array<float>) Array to normalize.\n// @returns (array<float>) Normalized copy of the \\srcArray\\.\nmethod featureScale(array<float> srcArray) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range()\narray<float> scaledArray = array.new<float>()\n// Push normalized \\element\\ values into the \\scaledArray\\.\nfor element in srcArray\nscaledArray.push((element - min) / rng)\nscaledArray\n\n// @function Draws a label containing eCDF estimates in the format \"{price}: {percent}%\"\n// @param srcArray (array<float>) Array of source values.\n// @param cdfArray (array<float>) Array of CDF estimates.\n// @returns (void)\nmakeLabel(array<float> srcArray, array<float> cdfArray) =>\nfloat max = srcArray.max()\nfloat rng = srcArray.range() / cdfArray.size()\nstring results = \"\"\nvar label lbl = label.new(0, 0, \"\", style = label.style\\_label\\_left, text\\_font\\_family = font.family\\_monospace)\n// Add percentage strings to \\results\\ starting from the \\max\\.\ncdfArray.reverse()\nfor \\[i, element\\] in cdfArray\nresults += str.format(\"{0}: {1}%\\\\n\", max - i \\ rng, element \\ 100)\n// Update \\lbl\\ attributes.\nlbl.set\\_xy(bar\\_index + 1, srcArray.avg())\nlbl.set\\_text(results)\n\nvar array<float> sourceArray = array.new<float>(length)\n\n// Add background color for the last \\length\\ bars.\nbgcolor(bar\\_index > last\\_bar\\_index - length ? color.new(color.orange, 80) : na)\n\n// Queue \\sourceArray\\, feature scale, then estimate the distribution over \\n\\` steps.\narray<float> distArray = sourceArray.maintainQueue(sourceInput).featureScale().eCDF(n)\n// Draw label.\nmakeLabel(sourceArray, distArray)\n\nPrevious\\\\\nEnums Next\\\\\nArrays",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "<namespace>.<functionName>([paramName =] <objectName>, …)",
      "<objectName>.<functionName>(…)",
      "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>"
    ]
  },
  "7ac2be02": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nMatrices\n\nIntroduction\n\nPine Script Matrices are collections that store value references in a\nrectangular format. They are the equivalent of two-dimensional array objects with functions and methods for inspection, modification, and specialized calculations. As with arrays, all matrix elements must be of the same type, user-defined type, or enum type.\n\nMatrices reference their elements using _two_ indices: one index for their\n_rows_ and the other for their _columns_. Each index starts at 0 and extends\nto the number of rows/columns in the matrix minus one. Matrices in Pine\ncan have dynamic numbers of rows and columns that vary across bars. The total number of elements\nwithin a matrix is the _product_ of the number of rows and columns it contains\n(e.g., a 5x5 matrix contains 25 elements). Like\narrays, the total number of\nelements in a matrix cannot exceed 100,000.\n\nDeclaring a matrix\n\nPine Script uses the following syntax for matrix declaration:\n\n``\n\n[var/varip ][matrix<type> ]<identifier> = <expression>\n`\n\nWhere <type> is a\ntype template for the matrix that declares the type of values or references it\ncontains, and the <expression> returns either the reference of a matrix instance or na.\n\nWhen initializing a matrix variable with na, users must specify that the\nidentifier will reference matrices of a specific type by including the\nmatrix\nkeyword followed by a\ntype template.\n\nThis line declares a new myMatrix variable with an initial reference of na. It\nexplicitly declares the variable as matrix<float>, which tells the\ncompiler that the variable can accept only\nmatrix\nobjects containing\nfloat\nvalues:\n\nmatrix<float> myMatrix = na\n\nWhen a matrix variable is not initialized with na, the\nmatrix\nkeyword and its type template are optional, as the compiler will use the\ntype information from the matrix instance that the variable references.\n\nHere, we declare a myMatrix variable referencing a new matrix<float>\ninstance with two rows, two columns, and an initial_value of 0. The\nvariable gets its type information from the new object in this case, so\nit doesn’t require an explicit type declaration:\n\nmyMatrix = matrix.new<float>(2, 2, 0.0)\n\nUsing ​ var ​ and ​ varip ​ keywords\n\nAs with other variables, users can include the\nvar or\nvarip\nkeywords to instruct a script to declare a matrix variable only once\nrather than on every bar. A matrix variable declared with this keyword\nwill point to the same instance throughout the span of the chart unless\nthe script explicitly assigns another matrix to it, allowing a matrix\nand its element references to persist between script iterations.\n\nThis script declares an m variable to reference a matrix that holds a\nsingle row of two\nint\nelements using the\nvar\nkeyword. On every 20th bar, the script adds 1 to the first element on\nthe first row of the m matrix. The\nplot()\ncall displays this element’s value on the chart. As we see from the plot, the\nvalue of the matrix.get() method call\npersists across bars, never returning to the initial value of 0:\n\n//@version=6\nindicator(\"var matrix demo\")\n\n//@variable A 1x2 rectangular matrix declared only at \\bar\\_index == 0\\, i.e., the first bar.\nvar m = matrix.new<int>(1, 2, 0)\n\n//@variable Is \\true\\ on every 20th bar.\nbool update = bar\\_index % 20 == 0\n\nif update\nint currentValue = m.get(0, 0) // Get the current value of the first row and column.\nm.set(0, 0, currentValue + 1) // Set the first row and column element value to \\currentValue + 1\\.\n\nplot(m.get(0, 0), linewidth = 3) // Plot the value from the first row and column.\n\nReading and writing matrix elements\n\n​ matrix.get() ​ and ​ matrix.set() ​\n\nTo retrieve the value from a matrix at a specified row and column\nindex, use\nmatrix.get().\nThis function locates the specified matrix element and returns its\nvalue. Similarly, to overwrite a specific element’s value, use\nmatrix.set()\nto assign the element at the specified row and column to a new\nvalue.\n\nThe example below defines a square matrix m with two rows and columns\nand an initial_value of 0 for all elements on the first bar. The\nscript adds 1 to each element’s value on different bars using matrix.get()\nand\nmatrix.set()\nmethod calls. It updates the first row’s first value once every 11 bars, the\nfirst row’s second value once every seven bars, the second row’s first\nvalue once every five bars, and the second row’s second value once\nevery three bars. The script plots each element’s value on the chart:\n\n//@version=6\nindicator(\"Reading and writing elements demo\")\n\n//@variable A 2x2 square matrix of \\float\\ values.\nvar m = matrix.new<float>(2, 2, 0.0)\n\nswitch\nbar\\_index % 11 == 0 => m.set(0, 0, m.get(0, 0) + 1.0) // Adds 1 to the value at row 0, column 0 every 11th bar.\nbar\\_index % 7 == 0 => m.set(0, 1, m.get(0, 1) + 1.0) // Adds 1 to the value at row 0, column 1 every 7th bar.\nbar\\_index % 5 == 0 => m.set(1, 0, m.get(1, 0) + 1.0) // Adds 1 to the value at row 1, column 0 every 5th bar.\nbar\\_index % 3 == 0 => m.set(1, 1, m.get(1, 1) + 1.0) // Adds 1 to the value at row 1, column 1 every 3rd bar.\n\nplot(m.get(0, 0), \"Row 0, Column 0 Value\", color.red, 2)\nplot(m.get(0, 1), \"Row 0, Column 1 Value\", color.orange, 2)\nplot(m.get(1, 0), \"Row 1, Column 0 Value\", color.green, 2)\nplot(m.get(1, 1), \"Row 1, Column 1 Value\", color.blue, 2)\n\n​ matrix.fill() ​\n\nTo overwrite all matrix elements with a specific value, use\nmatrix.fill().\nThis function points all items in the entire matrix or within the\nfrom_row/column and to_row/column index range to the value\nspecified in the call. For example, this snippet declares a 4x4 square\nmatrix, then fills its elements with the result of a\nmath.random()\ncall:\n\nmyMatrix = matrix.new<float>(4, 4)\nmyMatrix.fill(math.random())\n\nNote when using\nmatrix.fill()\nwith matrices of _reference types_\n( line,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point)\nor UDTs, all replaced elements will point to the same object passed\nin the function call.\n\nThis script declares a matrix with four rows and columns of\nlabel\nreferences, which it fills with a new\nlabel\nreference on the first bar. On each bar, the script sets the x property\nof the label referenced at row 0, column 0 to\nbar\\_index,\nand the text property of the one referenced at row 3, column 3 to the\nnumber of labels on the chart. Although the matrix can reference 16\n(4x4) labels, each element refers to the _same_ label object, resulting in\nonly one label on the chart with coordinates and displayed text that update on each bar:\n\n//@version=6\nindicator(\"Object matrix fill demo\")\n\n//@variable A 4x4 label matrix.\nvar matrix<label> m = matrix.new<label>(4, 4)\n\n// Fill \\m\\ with a new label object on the first bar.\nif bar\\_index == 0\nm.fill(label.new(0, 0, textcolor = color.white, size = size.huge))\n\n//@variable The number of label objects on the chart.\nint numLabels = label.all.size()\n\n// Set the \\x\\ of the label from the first row and column to \\bar\\_index\\.\nm.get(0, 0).set\\_x(bar\\_index)\n// Set the \\text\\ of the label at the last row and column to the number of labels.\nm.get(3, 3).set\\_text(str.format(\"Total labels on the chart: {0}\", numLabels))\n\nRows and columns\n\nRetrieving\n\nScripts can retrieve all the data from a specific row or\ncolumn in a matrix via the\nmatrix.row()\nand\nmatrix.col()\nfunctions. These functions return the row or column contents as an\narray sized according to the other dimension of the matrix. The\nsize of a\nmatrix.row()\narray equals the number of columns ( matrix.columns()), and the size of a matrix.col() array equals the number of rows matrix.rows().\n\nThe script below populates a 3x2 m matrix with the values 1 - 6 on the\nfirst chart bar. It uses\nmatrix.row()\nand\nmatrix.col()\nmethod calls to access the first row and column arrays from the matrix and\ndisplays them on the chart in a label along with the array sizes:\n\n//@version=6\nindicator(\"Retrieving rows and columns demo\")\n\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\n\nif bar\\_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 2, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 2, column 1 value to 6.\n\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, 0, color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set\\_x(bar\\_index)\ndebugLabel.set\\_text(str.format(\"Row 0: {0}, Size: {1}\\\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\n\nNote that:\n\n- To get the sizes of the arrays displayed in the label, we used\nthe\nmatrix.rows()\nand\nmatrix.columns()\nmethods rather than\narray.size()\nto demonstrate that the size of the row0 array equals the\nnumber of matrix columns and the size of the column0 array equals the\nnumber of matrix rows.\n\nThe matrix.row()\nand\nmatrix.col() functions\ncopy the contents of a row/column to a new\narray.\nModifications to the arrays\nreturned by these functions do not directly affect the elements or the\nshape of a matrix.\n\nHere, we’ve modified the previous script to set the first element of\nrow0 to 10 via the\narray.set()\nmethod before displaying the label. This script also plots the value\nfrom row 0, column 0. As we see, the label shows that the first element\nof the row0 array is 10. However, the plot\nshows that the corresponding matrix element still has a value of 1:\n\n//@version=6\nindicator(\"Retrieving rows and columns demo\")\n\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\n\nif bar\\_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 1, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 1, column 1 value to 6.\n\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n\n// Set the first \\row\\ element to 10.\nrow0.set(0, 10)\n\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, m.get(0, 0), color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set\\_x(bar\\_index)\ndebugLabel.set\\_text(str.format(\"Row 0: {0}, Size: {1}\\\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\n\n// Plot the first element of \\m\\.\nplot(m.get(0, 0), linewidth = 3)\n\nAlthough changes to an\narray\nconstructed from\nmatrix.row()\nor\nmatrix.col()\ndo not directly affect a parent matrix, it’s important to note the\nresulting array from a matrix containing\nUDTs\nor special types, including\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point,\nbehaves as a _shallow copy_ of a row/column, i.e., the elements within\nan array returned from these functions reference the same objects as the\ncorresponding matrix elements.\n\nThis script contains a custom myUDT type containing a value field\nwith an initial value of 0. It declares a 1x1 m matrix to hold a\nsingle myUDT instance on the first bar, then calls m.row(0) to copy\nthe first row of the matrix as an\narray.\nOn every chart bar, the script adds 1 to the value field of the first\nrow array element. In this case, the value field of the matrix\nelement increases on every bar as well, because both elements refer to the\nsame object:\n\n//@version=6\nindicator(\"Row with reference types demo\")\n\n//@type A custom type that holds a float value.\ntype myUDT\nfloat value = 0.0\n\n//@variable A 1x1 matrix of \\myUDT\\ type.\nvar matrix<myUDT> m = matrix.new<myUDT>(1, 1, myUDT.new())\n//@variable A shallow copy of the first row of \\m\\.\narray<myUDT> row = m.row(0)\n//@variable The first element of the \\row\\.\nmyUDT firstElement = row.get(0)\n\nfirstElement.value += 1.0 // Add 1 to the \\value\\ field of \\firstElement\\. Also affects the element in the matrix.\n\nplot(m.get(0, 0).value, linewidth = 3) // Plot the \\value\\ of the \\myUDT\\ object from the first row and column of \\m\\.\n\nInserting\n\nScripts can add new rows and columns to a matrix via\nmatrix.add\\_row()\nand\nmatrix.add\\_col().\nThese functions insert the values or references from an\narray\ninto a matrix at the specified row/column index. If the id matrix is\nempty (has no rows or columns), the array referenced by array_id in the call can be of any\nsize. If a row/column exists at the specified index, the matrix\nincreases the index value for the existing row/column and all after it\nby one.\n\nThe script below declares an empty m matrix and inserts rows and\ncolumns by calling\nmatrix.add\\_row()\nand\nmatrix.add\\_col() as\nmethods. It first inserts an array with three elements at row 0, turning\nm into a 1x3 matrix, then another at row 1, changing the shape to 2x3.\nAfter that, the script inserts another array at row 0, which changes the\nshape of m to 3x3 and shifts the index of all rows previously at index\n0 and higher. It inserts another array at the last column index,\nchanging the shape to 3x4. Finally, it adds an array with four values at\nthe end row index.\n\nThe resulting matrix has four rows and columns and contains values 1-16\nin ascending order. The script displays the rows of the matrix after each\nrow/column insertion with a user-defined debugLabel() function to\nvisualize the process:\n\n//@version=6\nindicator(\"Rows and columns demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//Create an empty matrix.\nvar m = matrix.new<float>()\n\nif bar\\_index == last\\_bar\\_index - 1\ndebugLabel(m, bar\\_index - 30, note = \"Empty matrix\")\n\n// Insert an array at row 0. \\m\\ will now have 1 row and 3 columns.\nm.add\\_row(0, array.from(5, 6, 7))\ndebugLabel(m, bar\\_index - 20, note = \"New row at\\\\nindex 0\")\n\n// Insert an array at row 1. \\m\\ will now have 2 rows and 3 columns.\nm.add\\_row(1, array.from(9, 10, 11))\ndebugLabel(m, bar\\_index - 10, note = \"New row at\\\\nindex 1\")\n\n// Insert another array at row 0. \\m\\ will now have 3 rows and 3 columns.\n// The values previously on row 0 will now be on row 1, and the values from row 1 will be on row 2.\nm.add\\_row(0, array.from(1, 2, 3))\ndebugLabel(m, bar\\_index, note = \"New row at\\\\nindex 0\")\n\n// Insert an array at column 3. \\m\\ will now have 3 rows and 4 columns.\nm.add\\_col(3, array.from(4, 8, 12))\ndebugLabel(m, bar\\_index + 10, note = \"New column at\\\\nindex 3\")\n\n// Insert an array at row 3. \\m\\ will now have 4 rows and 4 columns.\nm.add\\_row(3, array.from(13, 14, 15, 16))\ndebugLabel(m, bar\\_index + 20, note = \"New row at\\\\nindex 3\")\n\nRemoving\n\nTo remove a specific row or column from a matrix, use\nmatrix.remove\\_row()\nand\nmatrix.remove\\_col().\nThese functions remove the specified row/column and decrease the index\nvalues of all rows/columns after it by one.\n\nFor this example, we’ve added these lines of code to our “Rows and\ncolumns demo” script from the\nInserting section above:\n\n// Removing example\n\n// Remove the first row and last column from the matrix. \\m\\ will now have 3 rows and 3 columns.\nm.remove\\_row(0)\nm.remove\\_col(3)\ndebugLabel(m, bar\\_index + 30, color.red, note = \"Removed row 0\\\\nand column 3\")\n\nThis code removes the first row and the last column of the m matrix\nusing\nmatrix.remove\\_row()\nand\nmatrix.remove\\_col()\nmethod calls, then displays the rows in a label at bar_index + 30. As we can\nsee, the matrix has a 3x3 shape after the script executes this block, and the index\nvalues for all existing rows are reduced by 1:\n\nSwapping\n\nTo swap the rows and columns of a matrix without altering its\ndimensions, use\nmatrix.swap\\_rows()\nand\nmatrix.swap\\_columns().\nThese functions swap the positions of the elements at the row1/column1\nand row2/column2 indices.\n\nLet’s add another set of code lines to the example from the\nremoving section. The following lines swap the first and last rows of the m matrix and display the\nchanges in a label at bar_index + 40:\n\n// Swapping example\n\n// Swap the first and last row. \\m\\ retains the same dimensions.\nm.swap\\_rows(0, 2)\ndebugLabel(m, bar\\_index + 40, color.purple, note = \"Swapped rows 0\\\\nand 2\")\n\nIn the new label, we see the matrix has the same number of rows as\nbefore, and the first and last rows have traded places:\n\nReplacing\n\nIt may be desirable in some cases to completely _replace_ a row or\ncolumn in a matrix. To do so,\ninsert another array’s elements at the desired row/column and\nremove the old elements previously at that index.\n\nIn the following code, we’ve defined a replaceRow() method that uses\nthe\nmatrix.add\\_row()\nfunction to insert the new values at the row index, and the\nmatrix.remove\\_row()\nmethod to remove the old row that moved to the row + 1 index. This\nscript uses the replaceRow() method to fill the rows of a 3x3 matrix\nwith the numbers 1-9. It draws a label on the chart before and after\nreplacing the rows using the custom debugLabel() method:\n\n//@version=6\nindicator(\"Replacing rows demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@function Replaces the \\row\\ of \\this\\ matrix with a new array of \\values\\.\n//@param row The row index to replace.\n//@param values The array of values to insert.\nmethod replaceRow(matrix<float> this, int row, array<float> values) =>\nthis.add\\_row(row, values) // Inserts a copy of the \\values\\ array at the \\row\\.\nthis.remove\\_row(row + 1) // Removes the old elements previously at the \\row\\.\n\n//@variable A 3x3 matrix.\nvar matrix<float> m = matrix.new<float>(3, 3, 0.0)\n\nif bar\\_index == last\\_bar\\_index - 1\nm.debugLabel(note = \"Original\")\n// Replace each row of \\m\\.\nm.replaceRow(0, array.from(1.0, 2.0, 3.0))\nm.replaceRow(1, array.from(4.0, 5.0, 6.0))\nm.replaceRow(2, array.from(7.0, 8.0, 9.0))\nm.debugLabel(bar\\_index + 10, note = \"Replaced rows\")\n\nLooping through a matrix\n\n​ for ​\n\nWhen a script only needs to iterate over the row/column indices in a\nmatrix, the most common method is to use\nfor\nloops. For example, this line creates a loop with a row value that\nstarts at 0 and increases by one until it reaches one less than the\nnumber of rows in the m matrix (i.e., the last row index):\n\nfor row = 0 to m.rows() - 1\n\nTo iterate over all index values in the m matrix, we can create a\n_nested_ loop that iterates over each column index on each row\nvalue:\n\nfor row = 0 to m.rows() - 1\nfor column = 0 to m.columns() - 1\n\nLet’s use this nested structure to create a\nmethod that visualizes\nmatrix elements. In the script below, we’ve defined a toTable()\nmethod that displays the elements of a matrix within a\ntable\nobject. It iterates over each row index and over each column index\non every row. Within the loop, it converts each element to a\nstring\nto display in the corresponding table cell.\n\nOn the first bar, the script creates an empty m matrix, populates it\nwith rows, and calls m.toTable() to display its elements:\n\n//@version=6\nindicator(\"for loop demo\", \"Matrix to table\")\n\n//@function Displays the elements of \\this\\ matrix in a table.\n//@param this The matrix to display.\n//@param position The position of the table on the chart.\n//@param bgColor The background color of the table.\n//@param textColor The color of the text in each cell.\n//@param note A note string to display on the bottom row of the table.\n//@returns A new \\table\\ object with cells corresponding to each element of \\this\\ matrix.\nmethod toTable(\nmatrix<float> this, string position = position.middle\\_center,\ncolor bgColor = color.blue, color textColor = color.white,\nstring note = na\n) =>\n//@variable The number of rows in \\this\\ matrix.\nint rows = this.rows()\n//@variable The number of columns in \\this\\ matrix.\nint columns = this.columns()\n//@variable A table that displays the elements of \\this\\ matrix with an optional \\note\\ cell.\ntable result = table.new(position, columns, rows + 1, bgColor)\n\n// Iterate over each row index of \\this\\ matrix.\nfor row = 0 to rows - 1\n// Iterate over each column index of \\this\\ matrix on each \\row\\.\nfor col = 0 to columns - 1\n//@variable The element from \\this\\ matrix at the \\row\\ and \\col\\ index.\nfloat element = this.get(row, col)\n// Initialize the corresponding \\result\\ cell with the \\element\\ value.\nresult.cell(col, row, str.tostring(element), text\\_color = textColor, text\\_size = size.huge)\n\n// Initialize a merged cell on the bottom row if a \\note\\ is provided.\nif not na(note)\nresult.cell(0, rows, note, text\\_color = textColor, text\\_size = size.huge)\nresult.merge\\_cells(0, rows, columns - 1, rows)\n\nresult // Return the \\result\\ table.\n\n//@variable A 3x4 matrix of values.\nvar m = matrix.new<float>()\n\nif bar\\_index == 0\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(1, 2, 3))\nm.add\\_row(1, array.from(5, 6, 7))\nm.add\\_row(2, array.from(9, 10, 11))\n// Add a column to \\m\\.\nm.add\\_col(3, array.from(4, 8, 12))\n// Display the elements of \\m\\ in a table.\nm.toTable()\n\n​ for...in ​\n\nWhen a script needs to iterate over and retrieve the rows of a matrix,\nusing the\nfor…in\nstructure is often preferred over the standard for loop. This\nstructure directly references the row\narrays in a matrix, making\nit a more convenient option for such use cases. For example, this line\ncreates a loop that returns the reference of an array representing a row in the m\nmatrix on each iteration:\n\nfor row in m\n\nThe following indicator calculates the moving average of OHLC data with\nan input length and displays the values on the chart. The custom\nrowWiseAvg() method loops through the rows of a matrix using a\nfor…in structure to produce an array containing the\narray.avg() value\nfor each row array.\n\nOn the first chart bar, the script creates a new m matrix with four\nrows and length columns, which it queues a new column of OHLC data\ninto by calling\nmatrix.add\\_col()\nand\nmatrix.remove\\_col()\nas methods on each subsequent bar. It uses m.rowWiseAvg() to calculate\nthe array of row-wise averages, then it plots the value of each array element on\nthe chart:\n\n//@version=6\nindicator(\"for...in loop demo\", \"Average OHLC\", overlay = true)\n\n//@variable The number of terms in the average.\nint length = input.int(20, \"Length\", minval = 1)\n\n//@function Calculates the average of each matrix row.\nmethod rowWiseAvg(matrix<float> this) =>\n//@variable An array with elements corresponding to each row's average.\narray<float> result = array.new<float>()\n// Iterate over each \\row\\ of \\this\\ matrix.\nfor row in this\n// Push the average of each \\row\\ into the \\result\\.\nresult.push(row.avg())\nresult // Return the resulting array.\n\n//@variable A 4x\\length\\ matrix of values.\nvar matrix<float> m = matrix.new<float>(4, length)\n\n// Add a new column containing OHLC values to the matrix.\nm.add\\_col(m.columns(), array.from(open, high, low, close))\n// Remove the first column.\nm.remove\\_col(0)\n\n//@variable An array containing averages of \\open\\, \\high\\, \\low\\, and \\close\\ over \\length\\ bars.\narray<float> averages = m.rowWiseAvg()\n\nplot(averages.get(0), \"Average Open\", color.blue, 2)\nplot(averages.get(1), \"Average High\", color.green, 2)\nplot(averages.get(2), \"Average Low\", color.red, 2)\nplot(averages.get(3), \"Average Close\", color.orange, 2)\n\nNote that:\n\n- The for…in loop structure can also access the _index_ value of each row.\nFor example, for [i, row] in m creates a tuple containing the\ni row index and the reference of the corresponding row array from the m\nmatrix on each loop iteration.\n\nCopying a matrix\n\nShallow copies\n\nPine scripts can copy matrices via\nmatrix.copy().\nThis function returns a _shallow copy_ of a matrix that does not affect\nthe shape of the original matrix or its contents.\n\nFor example, this script assigns a new matrix reference to the myMatrix variable\nand adds two columns. It creates a new myCopy matrix from that matrix\nby calling\nmatrix.copy()\nas a method, then adds a new row to the resulting copy. It displays the rows of both matrices in\nlabels via the user-defined debugLabel() function:\n\n//@version=6\nindicator(\"Shallow copy demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x2 \\float\\ matrix.\nmatrix<float> myMatrix = matrix.new<float>()\nmyMatrix.add\\_col(0, array.from(1.0, 3.0))\nmyMatrix.add\\_col(1, array.from(2.0, 4.0))\n\n//@variable A shallow copy of \\myMatrix\\.\nmatrix<float> myCopy = myMatrix.copy()\n// Add a row to the last index of \\myCopy\\.\nmyCopy.add\\_row(myCopy.rows(), array.from(5.0, 6.0))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the rows of both matrices in separate labels.\nmyMatrix.debugLabel(note = \"Original\")\nmyCopy.debugLabel(bar\\_index + 10, color.green, note = \"Shallow Copy\")\n\nIt’s important to note that the elements within shallow copies of a\nmatrix have the same values or references as the original matrix. When matrices\ncontain references to special types\n( line,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point)\nor\nuser-defined types, the elements of a shallow copy reference the same objects\nas the original matrix.\n\nThis script declares a myMatrix variable with a newLabel as the\ninitial value. It then copies myMatrix to a myCopy variable via\nmyMatrix.copy()\nand plots the number of labels. As we see below, there’s only one\nlabel\non the chart, as the element in myCopy references the same object as\nthe element in myMatrix. Consequently, changes to the object referenced in the copied matrix affects the object referenced in the original matrix:\n\n//@version=6\nindicator(\"Shallow copy demo\")\n\n//@variable Initial value of the original matrix elements.\nvar label newLabel = label.new(\nbar\\_index, 1, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n)\n\n//@variable A 1x1 matrix containing a new \\label\\ instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A shallow copy of \\myMatrix\\.\nvar matrix<label> myCopy = myMatrix.copy()\n\n//@variable The first label from the \\myCopy\\ matrix.\nlabel testLabel = myCopy.get(0, 0)\n\n// Change the \\text\\, \\style\\, and \\x\\ values of \\testLabel\\. Also affects the \\newLabel\\.\ntestLabel.set\\_text(\"Copy\")\ntestLabel.set\\_style(label.style\\_label\\_up)\ntestLabel.set\\_x(bar\\_index)\n\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\n\nDeep copies\n\nOne can produce a _deep copy_ of a matrix (i.e., a matrix whose elements refer to copies of the objects referenced by the original matrix) by explicitly copying each element in the matrix.\n\nHere, we’ve added a deepCopy() user-defined method to our previous\nscript. The method creates a new matrix and uses nested\n\\for\\ loops to assign all elements to copies of the originals. When the\nscript calls this method instead of\nmatrix.copy(),\nwe see that there are now two labels on the chart, and any changes to\nthe label referenced by the copied matrix do not affect the one referenced by the original matrix:\n\n//@version=6\nindicator(\"Deep copy demo\")\n\n//@function Returns a deep copy of a label matrix.\nmethod deepCopy(matrix<label> this) =>\n//@variable A deep copy of \\this\\ matrix.\nmatrix<label> that = this.copy()\nfor row = 0 to that.rows() - 1\nfor column = 0 to that.columns() - 1\n// Assign the element at each \\row\\ and \\column\\ of \\that\\ matrix to a copy of the retrieved label.\nthat.set(row, column, that.get(row, column).copy())\nthat\n\n//@variable Initial value of the original matrix.\nvar label newLabel = label.new(\nbar\\_index, 2, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n)\n\n//@variable A 1x1 matrix containing a new \\label\\ instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A deep copy of \\myMatrix\\.\nvar matrix<label> myCopy = myMatrix.deepCopy()\n\n//@variable The first label from the \\myCopy\\ matrix.\nlabel testLabel = myCopy.get(0, 0)\n\n// Change the \\text\\, \\style\\, and \\x\\ values of \\testLabel\\. Does not affect the \\newLabel\\.\ntestLabel.set\\_text(\"Copy\")\ntestLabel.set\\_style(label.style\\_label\\_up)\ntestLabel.set\\_x(bar\\_index)\n\n// Change the \\x\\ value of \\newLabel\\.\nnewLabel.set\\_x(bar\\_index)\n\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\n\nSubmatrices\n\nIn Pine, a _submatrix_ is a\nshallow copy of an existing matrix that only includes the rows and\ncolumns specified by the from_row/column and to_row/column\nparameters. In essence, it is a sliced copy of a matrix.\n\nFor example, the script below creates an mSub matrix from the m\nmatrix via the\nmatrix.submatrix()\nmethod, then calls our user-defined debugLabel() function to display\nthe rows of both matrices in labels:\n\n//@version=6\nindicator(\"Submatrix demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix of values.\nvar m = matrix.new<float>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add columns to \\m\\.\nm.add\\_col(0, array.from(9, 6, 3))\nm.add\\_col(1, array.from(8, 5, 2))\nm.add\\_col(2, array.from(7, 4, 1))\n// Display the rows of \\m\\.\nm.debugLabel(note = \"Original Matrix\")\n\n//@variable A 2x2 submatrix of \\m\\ containing the first two rows and columns.\nmatrix<float> mSub = m.submatrix(from\\_row = 0, to\\_row = 2, from\\_column = 0, to\\_column = 2)\n// Display the rows of \\mSub\\\ndebugLabel(mSub, bar\\_index + 10, bgColor = color.green, note = \"Submatrix\")\n\nScope and history\n\nMatrix variables leave historical trails on each bar, allowing scripts\nto use the history-referencing operator\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nto interact with past matrix instances previously assigned to a\nvariable. Additionally, scripts can modify matrices assigned to global\nvariables from within the scopes of\nuser-defined functions,\nmethods, and\nconditional structures.\n\nThis script calculates the average ratios of body and wick distances\nrelative to the bar range over length bars. It displays the data along\nwith values from length bars ago in a table. The user-defined\naddData() function adds columns of current and historical ratios to\nthe a matrix created in the global scope, and the calcAvg() function references previous\nmatrices assigned to the globalMatrix variable using the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator to calculate a matrix of averages:\n\n//@version=6\nindicator(\"Scope and history demo\", \"Bar ratio comparison\")\n\nint length = input.int(10, \"Length\", 1)\n\n//@variable A global matrix.\nmatrix<float> globalMatrix = matrix.new<float>()\n\n//@function Calculates the ratio of body range to candle range.\nbodyRatio() =>\nmath.abs(close - open) / (high - low)\n\n//@function Calculates the ratio of upper wick range to candle range.\nupperWickRatio() =>\n(high - math.max(open, close)) / (high - low)\n\n//@function Calculates the ratio of lower wick range to candle range.\nlowerWickRatio() =>\n(math.min(open, close) - low) / (high - low)\n\n//@function Adds data to the \\globalMatrix\\.\naddData() =>\n// Add a new column of data at \\column\\ 0.\nglobalMatrix.add\\_col(0, array.from(bodyRatio(), upperWickRatio(), lowerWickRatio()))\n//@variable The column of \\globalMatrix\\ from index 0 \\length\\ bars ago.\narray<float> pastValues = globalMatrix.col(0)\\[length\\]\n// Add \\pastValues\\ to the \\globalMatrix\\, or an array of \\na\\ if \\pastValues\\ is \\na\\.\nif na(pastValues)\nglobalMatrix.add\\_col(1, array.new<float>(3))\nelse\nglobalMatrix.add\\_col(1, pastValues)\n\n//@function Returns the \\length\\-bar average of matrices assigned to \\globalMatrix\\ on historical bars.\ncalcAvg() =>\n//@variable The sum historical \\globalMatrix\\ matrices.\nmatrix<float> sums = matrix.new<float>(globalMatrix.rows(), globalMatrix.columns(), 0.0)\nfor i = 0 to length - 1\n//@variable The \\globalMatrix\\ matrix \\i\\ bars before the current bar.\nmatrix<float> previous = globalMatrix\\[i\\]\n// Break the loop if \\previous\\ is \\na\\.\nif na(previous)\nsums.fill(na)\nbreak\n// Assign the sum of \\sums\\ and \\previous\\ to \\sums\\.\nsums := matrix.sum(sums, previous)\n// Divide the \\sums\\ matrix by the \\length\\.\nresult = sums.mult(1.0 / length)\n\n// Add data to the \\globalMatrix\\.\naddData()\n\n//@variable The historical average of the \\globalMatrix\\ matrices.\nglobalAvg = calcAvg()\n\n//@variable A \\table\\ displaying information from the \\globalMatrix\\.\nvar table infoTable = table.new(\nposition.middle\\_center, globalMatrix.columns() + 1, globalMatrix.rows() + 1, bgcolor = color.navy\n)\n\n// Define value cells.\nfor \\[i, row\\] in globalAvg\nfor \\[j, value\\] in row\ncolor textColor = value > 0.333 ? color.orange : color.gray\ninfoTable.cell(j + 1, i + 1, str.tostring(value), text\\_color = textColor, text\\_size = size.huge)\n\n// Define header cells.\ninfoTable.cell(0, 1, \"Body ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(0, 2, \"Upper wick ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(0, 3, \"Lower wick ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(1, 0, \"Current average\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(2, 0, str.format(\"{0} bars ago\", length), text\\_color = color.white, text\\_size = size.huge)\n\nNote that:\n\n- The addData() and calcAvg() functions have no parameters, as\nthey directly interact with the globalMatrix and length\nvariables declared in the outer scope.\n- The calcAvg() functions calculates the averages by adding previous matrices\nusing\nmatrix.sum()\nand multiplying all elements by 1 / length using\nmatrix.mult().\nWe discuss these and other specialized functions in the\nMatrix calculations section below.\n\nInspecting a matrix\n\nThe ability to inspect the shape of a matrix and patterns within its\nelements is crucial, as it helps reveal important information about a\nmatrix and its compatibility with various calculations and\ntransformations. Pine Script includes several built-ins for matrix\ninspection, including\nmatrix.is\\_square(),\nmatrix.is\\_identity(),\nmatrix.is\\_diagonal(),\nmatrix.is\\_antidiagonal(),\nmatrix.is\\_symmetric(),\nmatrix.is\\_antisymmetric(),\nmatrix.is\\_triangular(),\nmatrix.is\\_stochastic(),\nmatrix.is\\_binary(),\nand\nmatrix.is\\_zero().\n\nTo demonstrate these features, this example contains a custom\ninspect() method that uses conditional blocks with matrix.is_*()\nfunctions to return information about a matrix. It displays a string\nrepresentation of an m matrix and the description returned from\nm.inspect() in labels on the chart:\n\n//@version=6\nindicator(\"Matrix inspection demo\")\n\n//@function Inspects a matrix using \\matrix.is\\_\\*()\\ functions and returns a \\string\\ describing some of its features.\nmethod inspect(matrix<int> this)=>\n//@variable A string describing \\this\\ matrix.\nstring result = \"This matrix:\\\\n\"\nif this.is\\_square()\nresult += \"- Has an equal number of rows and columns.\\\\n\"\nif this.is\\_binary()\nresult += \"- Contains only 1s and 0s.\\\\n\"\nif this.is\\_zero()\nresult += \"- Is filled with 0s.\\\\n\"\nif this.is\\_triangular()\nresult += \"- Contains only 0s above and/or below its main diagonal.\\\\n\"\nif this.is\\_diagonal()\nresult += \"- Only has nonzero values in its main diagonal.\\\\n\"\nif this.is\\_antidiagonal()\nresult += \"- Only has nonzero values in its main antidiagonal.\\\\n\"\nif this.is\\_symmetric()\nresult += \"- Equals its transpose.\\\\n\"\nif this.is\\_antisymmetric()\nresult += \"- Equals the negative of its transpose.\\\\n\"\nif this.is\\_identity()\nresult += \"- Is the identity matrix.\\\\n\"\nresult\n\n//@variable A 4x4 identity matrix.\nmatrix<int> m = matrix.new<int>()\n\n// Add rows to the matrix.\nm.add\\_row(0, array.from(1, 0, 0, 0))\nm.add\\_row(1, array.from(0, 1, 0, 0))\nm.add\\_row(2, array.from(0, 0, 1, 0))\nm.add\\_row(3, array.from(0, 0, 0, 1))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the \\m\\ matrix in a blue label.\nlabel.new(\nbar\\_index, 0, str.tostring(m), color = color.blue, style = label.style\\_label\\_right,\ntextcolor = color.white, size = size.huge\n)\n// Display the result of \\m.inspect()\\ in a purple label.\nlabel.new(\nbar\\_index, 0, m.inspect(), color = color.purple, style = label.style\\_label\\_left,\ntextcolor = color.white, size = size.huge\n)\n\nManipulating a matrix\n\nReshaping\n\nThe shape of a matrix can determine its compatibility with various\nmatrix operations. In some cases, it is necessary to change the\ndimensions of a matrix without affecting the number of elements or the\nvalues they reference, otherwise known as _reshaping_. To reshape a\nmatrix in Pine, use the\nmatrix.reshape()\nfunction.\n\nThis example demonstrates the results of multiple reshaping operations\non a matrix. The initial m matrix has a 1x8 shape (one row and eight\ncolumns). Through successive calls to the\nmatrix.reshape()\nmethod, the script changes the shape of m to 2x4, 4x2, and 8x1. It\ndisplays each reshaped matrix in a label on the chart using the custom\ndebugLabel() method:\n\n//@version=6\nindicator(\"Reshaping example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A matrix containing the values 1-8.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add the initial vector of values.\nm.add\\_row(0, array.from(1, 2, 3, 4, 5, 6, 7, 8))\nm.debugLabel(note = \"Initial 1x8 matrix\")\n\n// Reshape. \\m\\ now has 2 rows and 4 columns.\nm.reshape(2, 4)\nm.debugLabel(bar\\_index + 10, note = \"Reshaped to 2x4\")\n\n// Reshape. \\m\\ now has 4 rows and 2 columns.\nm.reshape(4, 2)\nm.debugLabel(bar\\_index + 20, note = \"Reshaped to 4x2\")\n\n// Reshape. \\m\\ now has 8 rows and 1 column.\nm.reshape(8, 1)\nm.debugLabel(bar\\_index + 30, note = \"Reshaped to 8x1\")\n\nNote that:\n\n- The order of elements in m does not change with each\nm.reshape() call.\n- When reshaping a matrix, the product of the rows and columns\narguments must equal the\nmatrix.elements\\_count()\nvalue, as\nmatrix.reshape()\ncannot change the number of elements in a matrix.\n\nReversing\n\nOne can reverse the order of all elements in a matrix using\nmatrix.reverse().\nThis function moves the references of an m-by-n matrix id at the i-th\nrow and j-th column to the m - 1 - i row and n - 1 - j column.\n\nFor example, this script creates a 3x3 matrix containing the values 1-9\nin ascending order, then uses the\nmatrix.reverse()\nmethod to reverse its contents. It displays the original and modified\nversions of the matrix in labels on the chart via m.debugLabel():\n\n//@version=6\nindicator(\"Reversing demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nmatrix<float> m = matrix.new<float>()\n\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(1, 2, 3))\nm.add\\_row(1, array.from(4, 5, 6))\nm.add\\_row(2, array.from(7, 8, 9))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the contents of \\m\\.\nm.debugLabel(note = \"Original\")\n// Reverse \\m\\, then display its contents.\nm.reverse()\nm.debugLabel(bar\\_index + 10, color.red, note = \"Reversed\")\n\nTransposing\n\nTransposing a matrix is a fundamental operation that flips all rows and\ncolumns in a matrix about its _main diagonal_ (the diagonal vector of\nall values in which the row index equals the column index). This process\nproduces a new matrix with reversed row and column dimensions, known as\nthe _transpose_. Scripts can calculate the transpose of a matrix using\nmatrix.transpose().\n\nFor any m-row, n-column matrix, the matrix returned from\nmatrix.transpose()\nwill have n rows and m columns. All elements in a matrix at the i-th row\nand j-th column correspond to the elements in its transpose at the j-th\nrow and i-th column.\n\nThis example declares a 2x4 m matrix, calculates its transpose by calling\nmatrix.transpose() as a\nmethod, then displays strings representing both matrices on the chart using our custom\ndebugLabel() method. As we can see below, the transposed matrix has a\n4x2 shape, and the rows of the transpose match the columns of the\noriginal matrix:\n\n//@version=6\nindicator(\"Transpose example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x4 matrix.\nmatrix<int> m = matrix.new<int>()\n\n// Add columns to \\m\\.\nm.add\\_col(0, array.from(1, 5))\nm.add\\_col(1, array.from(2, 6))\nm.add\\_col(2, array.from(3, 7))\nm.add\\_col(3, array.from(4, 8))\n\n//@variable The transpose of \\m\\. Has a 4x2 shape.\nmatrix<int> mt = m.transpose()\n\nif bar\\_index == last\\_bar\\_index - 1\nm.debugLabel(note = \"Original\")\nmt.debugLabel(bar\\_index + 10, note = \"Transpose\")\n\nSorting\n\nScripts can sort the contents of a matrix via\nmatrix.sort().\nUnlike\narray.sort(),\nwhich sorts _elements_, this function organizes all _rows_ in a matrix\nin a specified order\n( order.ascending\nby default) based on the values in a specified column.\n\nThis script declares a 3x3 m matrix, sorts the rows of the m1 copy\nin ascending order based on the first column, then sorts the rows of the\nm2 copy in descending order based on the second column. It displays\nthe original matrix and sorted copies in labels using our debugLabel()\nmethod:\n\n//@version=6\nindicator(\"Sorting rows example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(3, 2, 4))\nm.add\\_row(1, array.from(1, 9, 6))\nm.add\\_row(2, array.from(7, 8, 9))\nm.debugLabel(note = \"Original\")\n\n// Copy \\m\\ and sort rows in ascending order based on the first column (default).\nmatrix<int> m1 = m.copy()\nm1.sort()\nm1.debugLabel(bar\\_index + 10, color.green, note = \"Sorted using col 0\\\\n(Ascending)\")\n\n// Copy \\m\\ and sort rows in descending order based on the second column.\nmatrix<int> m2 = m.copy()\nm2.sort(1, order.descending)\nm2.debugLabel(bar\\_index + 20, color.red, note = \"Sorted using col 1\\\\n(Descending)\")\n\nIt’s important to note that\nmatrix.sort()\ndoes not sort the columns of a matrix. However, one _can_ use this\nfunction to sort matrix columns with the help of\nmatrix.transpose().\n\nAs an example, this script contains a sortColumns() method that uses\nthe\nmatrix.sort()\nmethod to sort the\ntranspose\nof a matrix using the column corresponding to the row of the original\nmatrix. The script uses this method to sort the m matrix based on the\ncontents of its first row:\n\n//@version=6\nindicator(\"Sorting columns example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@function Sorts the columns of \\this\\ matrix based on the values in the specified \\row\\.\nmethod sortColumns(matrix<int> this, int row = 0, bool ascending = true) =>\n//@variable The transpose of \\this\\ matrix.\nmatrix<int> thisT = this.transpose()\n//@variable Is \\order.ascending\\ when \\ascending\\ is \\true\\, \\order.descending\\ otherwise.\norder = ascending ? order.ascending : order.descending\n// Sort the rows of \\thisT\\ using the \\row\\ column.\nthisT.sort(row, order)\n//@variable A copy of \\this\\ matrix with sorted columns.\nresult = thisT.transpose()\n\n//@variable A 3x3 matrix.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(3, 2, 4))\nm.add\\_row(1, array.from(1, 9, 6))\nm.add\\_row(2, array.from(7, 8, 9))\nm.debugLabel(note = \"Original\")\n\n// Sort the columns of \\m\\ based on the first row and display the result.\nm.sortColumns(0).debugLabel(bar\\_index + 10, note = \"Sorted using row 0\\\\n(Ascending)\")\n\nConcatenating\n\nScripts can _concatenate_ two matrices using\nmatrix.concat().\nThis function appends the rows of an id2 matrix to the end of an id1\nmatrix with the same number of columns.\n\nTo create a matrix with elements representing the _columns_ of a matrix\nappended to another,\ntranspose both matrices, use\nmatrix.concat()\non the transposed matrices, then\ntranspose()\nthe result.\n\nFor example, this script appends the rows of the m2 matrix to the m1\nmatrix and appends their columns using _transposed copies_ of the\nmatrices. It displays the m1 and m2 matrices and the results after\nconcatenating their rows and columns in labels using the custom\ndebugLabel() method:\n\n//@version=6\nindicator(\"Concatenation demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x3 matrix filled with 1s.\nmatrix<int> m1 = matrix.new<int>(2, 3, 1)\n//@variable A 2x3 matrix filled with 2s.\nmatrix<int> m2 = matrix.new<int>(2, 3, 2)\n\n//@variable The transpose of \\m1\\.\nt1 = m1.transpose()\n//@variable The transpose of \\m2\\.\nt2 = m2.transpose()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the original matrices.\nm1.debugLabel(note = \"Matrix 1\")\nm2.debugLabel(bar\\_index + 10, note = \"Matrix 2\")\n// Append the rows of \\m2\\ to the end of \\m1\\ and display \\m1\\.\nm1.concat(m2)\nm1.debugLabel(bar\\_index + 20, color.blue, note = \"Appended rows\")\n// Append the rows of \\t2\\ to the end of \\t1\\, then display the transpose of \\t1\\.\nt1.concat(t2)\nt1.transpose().debugLabel(bar\\_index + 30, color.purple, note = \"Appended columns\")\n\nMatrix calculations\n\nElement-wise calculations\n\nPine scripts can calculate the _average_, _minimum_, _maximum_, and\n_mode_ of all elements within a matrix via\nmatrix.avg(),\nmatrix.min(),\nmatrix.max(),\nand\nmatrix.mode().\nThese functions operate the same as their array.* equivalents,\nallowing users to run element-wise calculations on a matrix, its\nsubmatrices, and its\nrows and columns using the same syntax. For example, the built-in *.avg()\nfunctions called on a 3x3 matrix with values 1-9 and an\narray\nwith the same nine elements will both return a value of 5.\n\nThe script below uses .avg(), .max(), and *.min() methods to\ncalculate developing averages and extremes of OHLC data in a period. It\nadds a new column of\nopen,\nhigh,\nlow,\nand\nclose\nvalues to the end of the ohlcData matrix whenever queueColumn is\ntrue. When false, the script uses the\nmatrix.get()\nand\nmatrix.set() methods to adjust the elements in the last column for developing\nHLC values in the current period. It uses the ohlcData matrix, a submatrix, and row and column\narrays to calculate the developing OHLC4 and HL2 averages over length\nperiods, the maximum high and minimum low over length periods, and the\ncurrent period’s developing OHLC4 price:\n\n//@version=6\nindicator(\"Element-wise calculations example\", \"Developing values\", overlay = true)\n\n//@variable The number of data points in the averages.\nint length = input.int(3, \"Length\", 1)\n//@variable The timeframe of each reset period.\nstring timeframe = input.timeframe(\"D\", \"Reset Timeframe\")\n\n//@variable A 4x\\length\\ matrix of OHLC values.\nvar matrix<float> ohlcData = matrix.new<float>(4, length)\n\n//@variable Is \\true\\ at the start of a new bar at the \\timeframe\\.\nbool queueColumn = timeframe.change(timeframe)\n\nif queueColumn\n// Add new values to the end column of \\ohlcData\\.\nohlcData.add\\_col(length, array.from(open, high, low, close))\n// Remove the oldest column from \\ohlcData\\.\nohlcData.remove\\_col(0)\nelse\n// Adjust the last element of column 1 for new highs.\nif high > ohlcData.get(1, length - 1)\nohlcData.set(1, length - 1, high)\n// Adjust the last element of column 2 for new lows.\nif low < ohlcData.get(2, length - 1)\nohlcData.set(2, length - 1, low)\n// Adjust the last element of column 3 for the new closing price.\nohlcData.set(3, length - 1, close)\n\n//@variable The \\matrix.avg()\\ of all elements in \\ohlcData\\.\navgOHLC4 = ohlcData.avg()\n//@variable The \\matrix.avg()\\ of all elements in rows 1 and 2, i.e., the average of all \\high\\ and \\low\\ values.\navgHL2 = ohlcData.submatrix(from\\_row = 1, to\\_row = 3).avg()\n//@variable The \\matrix.max()\\ of all values in \\ohlcData\\. Equivalent to \\ohlcData.row(1).max()\\.\nmaxHigh = ohlcData.max()\n//@variable The \\array.min()\\ of all \\low\\ values in \\ohlcData\\. Equivalent to \\ohlcData.min()\\.\nminLow = ohlcData.row(2).min()\n//@variable The \\array.avg()\\ of the last column in \\ohlcData\\, i.e., the current OHLC4.\nohlc4Value = ohlcData.col(length - 1).avg()\n\nplot(avgOHLC4, \"Average OHLC4\", color.purple, 2)\nplot(avgHL2, \"Average HL2\", color.navy, 2)\nplot(maxHigh, \"Max High\", color.green)\nplot(minLow, \"Min Low\", color.red)\nplot(ohlc4Value, \"Current OHLC4\", color.blue)\n\nNote that:\n\n- In this example, we used\narray.() and matrix.() methods interchangeably to demonstrate their similarities in syntax and behavior.\n- Users can calculate the matrix equivalent of\narray.sum()\nby multiplying the values of matrix.avg() and matrix.elements\\_count().\n\nSpecial calculations\n\nPine Script features several built-in functions for performing\nessential matrix arithmetic and linear algebra operations, including\nmatrix.sum(),\nmatrix.diff(),\nmatrix.mult(),\nmatrix.pow(),\nmatrix.det(),\nmatrix.inv(),\nmatrix.pinv(),\nmatrix.rank(),\nmatrix.trace(),\nmatrix.eigenvalues(),\nmatrix.eigenvectors(),\nand\nmatrix.kron().\nThese functions are advanced features that facilitate a variety of\nmatrix calculations and transformations.\n\nBelow, we explain a few fundamental functions with some basic examples.\n\n​ matrix.sum() ​ and ​ matrix.diff() ​\n\nScripts can perform addition and subtraction of two matrices with the\nsame shape or a matrix and a scalar value using the\nmatrix.sum()\nand\nmatrix.diff()\nfunctions. These functions use the values from the id2 matrix or\nscalar to add to or subtract from the elements in id1.\n\nThis script demonstrates a simple example of matrix addition and\nsubtraction in Pine. It creates a 3x3 matrix, calculates its\ntranspose, then calculates the\nmatrix.sum()\nand\nmatrix.diff()\nresults using the two matrices. This example displays the original matrix, its\ntranspose,\nand the resulting sum and difference matrices in labels on the chart:\n\n//@version=6\nindicator(\"Matrix sum and diff example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nm = matrix.new<float>()\n\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(0.5, 1.0, 1.5))\nm.add\\_row(1, array.from(2.0, 2.5, 3.0))\nm.add\\_row(2, array.from(3.5, 4.0, 4.5))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display \\m\\.\nm.debugLabel(note = \"A\")\n// Get and display the transpose of \\m\\.\nmatrix<float> t = m.transpose()\nt.debugLabel(bar\\_index + 10, note = \"Aᵀ\")\n// Calculate the sum of the two matrices. The resulting matrix is symmetric.\nmatrix.sum(m, t).debugLabel(bar\\_index + 20, color.green, note = \"A + Aᵀ\")\n// Calculate the difference between the two matrices. The resulting matrix is antisymmetric.\nmatrix.diff(m, t).debugLabel(bar\\_index + 30, color.red, note = \"A - Aᵀ\")\n\nNote that:\n\n- In this example, we’ve labeled the original matrix as “A” and\nthe transpose as “Aᵀ”.\n- Adding “A” and “Aᵀ” produces a _symmetric_ matrix, and subtracting them produces an _antisymmetric_ matrix. The functions matrix.is\\_symmetric() and matrix.is\\_antisymmetric() test a matrix for these conditions.\n\n​ matrix.mult() ​\n\nScripts can multiply two matrices via the\nmatrix.mult()\nfunction. This function can also multiply a matrix by an\narray\nor a scalar value.\n\nIn the case of multiplying two matrices, unlike addition and\nsubtraction, matrix multiplication does not require two matrices to\nshare the same shape. However, the number of columns in the first matrix\nmust equal the number of rows in the second one. The resulting matrix\nreturned by\nmatrix.mult()\nwill contain the same number of rows as the id1 matrix and the same number of\ncolumns as the id2 matrix. For instance, a 2x3 matrix multiplied by a 3x4 matrix\nwill produce a matrix with two rows and four columns, as shown below.\nEach value within the resulting matrix is the dot\\\\\nproduct of the corresponding\nrow in the id1 maxtrix and column in the id2 matrix:\n\n//@version=6\nindicator(\"Matrix mult example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x3 matrix.\na = matrix.new<float>()\n//@variable A 3x4 matrix.\nb = matrix.new<float>()\n\n// Add rows to \\a\\.\na.add\\_row(0, array.from(1, 2, 3))\na.add\\_row(1, array.from(4, 5, 6))\n\n// Add rows to \\b\\.\nb.add\\_row(0, array.from(0.5, 1.0, 1.5, 2.0))\nb.add\\_row(1, array.from(2.5, 3.0, 3.5, 4.0))\nb.add\\_row(0, array.from(4.5, 5.0, 5.5, 6.0))\n\nif bar\\_index == last\\_bar\\_index - 1\n//@variable The result of \\a\\ \\* \\b\\.\nmatrix<float> ab = a.mult(b)\n// Display \\a\\, \\b\\, and \\ab\\ matrices.\ndebugLabel(a, note = \"A\")\ndebugLabel(b, bar\\_index + 10, note = \"B\")\ndebugLabel(ab, bar\\_index + 20, color.green, note = \"A \\* B\")\n\nNote that:\n\n- In contrast to the multiplication of scalars, matrix\nmultiplication is _non-commutative_, i.e., matrix.mult(a, b)\ndoes not necessarily produce the same result as\nmatrix.mult(b, a). In the context of our example, the latter\nwill raise a runtime error because the number of columns in b\ndoesn’t equal the number of rows in a.\n\nWhen multiplying a matrix and an\narray,\nthis function treats the operation the same as multiplying the id1 matrix by a\nsingle-column matrix, but it returns an\narray\nwith the same number of elements as the number of matrix rows. When\nmatrix.mult()\npasses a scalar as its id2 value, the function returns a new matrix\nwhose elements are the elements in the id1 matrix multiplied by the id2 value.\n\n​ matrix.det() ​\n\nA _determinant_ is a scalar value associated with a square\nmatrix that describes some of its characteristics, namely its\ninvertibility. If a matrix has an\ninverse,\nits determinant is nonzero. Otherwise, the matrix is _singular_\n(non-invertible). Scripts can calculate the determinant of a matrix via\nmatrix.det().\n\nProgrammers can use determinants to detect similarities between\nmatrices, identify _full-rank_ and _rank-deficient_ matrices, and solve\nsystems of linear equations, among other applications.\n\nFor example, this script uses determinants to solve a system of\nlinear equations with a matching number of unknown values using\nCramer’s rule. The\nuser-defined solve() function returns the reference of an\narray\ncontaining solutions for each unknown value in the system, where the\nn-th element of the array is the determinant of the coefficient matrix\nwith the n-th column replaced by the column of constants divided by the\ndeterminant of the original coefficients.\n\nIn this script, we’ve defined the matrix m that holds coefficients\nand constants for these three equations:\n\n`\n\n3  x0 + 4  x1 - 1 * x2 = 8\n\n5  x0 - 2  x1 + 1 * x2 = 4\n\n2  x0 - 2  x1 + 1 * x2 = 1\n`\n\nThe solution to this system is (x0 = 1, x1 = 2, x2 = 3). The script\ncalculates these values from m via m.solve() and plots them on the\nchart:\n\n//@version=6\nindicator(\"Determinants example\", \"Cramer's Rule\")\n\n//@function Solves a system of linear equations with a matching number of unknowns using Cramer's rule.\n//@param this An augmented matrix containing the coefficients for each unknown and the results of\n// the equations. For example, a row containing the values 2, -1, and 3 represents the equation\n// \\2 \\ x0 + (-1) \\ x1 = 3\\, where \\x0\\ and \\x1\\ are the unknown values in the system.\n//@returns An array containing solutions for each variable in the system.\nsolve(matrix<float> this) =>\n//@variable The coefficient matrix for the system of equations.\nmatrix<float> coefficients = this.submatrix(from\\_column = 0, to\\_column = this.columns() - 1)\n//@variable The array of resulting constants for each equation.\narray<float> constants = this.col(this.columns() - 1)\n//@variable An array containing solutions for each unknown in the system.\narray<float> result = array.new<float>()\n\n//@variable The determinant value of the coefficient matrix.\nfloat baseDet = coefficients.det()\nmatrix<float> modified = na\nfor col = 0 to coefficients.columns() - 1\nmodified := coefficients.copy()\nmodified.add\\_col(col, constants)\nmodified.remove\\_col(col + 1)\n\n// Calculate the solution for the column's unknown by dividing the determinant of \\modified\\ by the \\baseDet\\.\nresult.push(modified.det() / baseDet)\n\nresult\n\n//@variable A 3x4 matrix containing coefficients and results for a system of three equations.\nm = matrix.new<float>()\n\n// Add rows for the following equations:\n// Equation 1: 3 \\ x0 + 4 \\ x1 - 1 \\* x2 = 8\n// Equation 2: 5 \\ x0 - 2 \\ x1 + 1 \\* x2 = 4\n// Equation 3: 2 \\ x0 - 2 \\ x1 + 1 \\* x2 = 1\nm.add\\_row(0, array.from(3.0, 4.0, -1.0, 8.0))\nm.add\\_row(1, array.from(5.0, -2.0, 1.0, 4.0))\nm.add\\_row(2, array.from(2.0, -2.0, 1.0, 1.0))\n\n//@variable An array of solutions to the unknowns in the system of equations represented by \\m\\.\nsolutions = solve(m)\n\nplot(solutions.get(0), \"x0\", color.red, 3) // Plots 1.\nplot(solutions.get(1), \"x1\", color.green, 3) // Plots 2.\nplot(solutions.get(2), \"x2\", color.blue, 3) // Plots 3.\n\nNote that:\n\n- Solving systems of equations is particularly useful for\n_regression analysis_, e.g., linear and polynomial regression.\n- Cramer’s rule works fine for small systems of equations.\nHowever, it’s computationally inefficient on larger systems.\nOther methods, such as Gaussian\\\\\nelimination,\nare often preferred for such use cases.\n\n​ matrix.inv() ​ and ​ matrix.pinv() ​\n\nFor any non-singular square\nmatrix, there is an inverse matrix that yields the identity\nmatrix when\nmultiplied by the original. Inverses have use in various matrix\ntransformations and solving systems of equations. Scripts can calculate\nthe inverse of a matrix when one exists via the\nmatrix.inv()\nfunction.\n\nFor singular (non-invertible) matrices, one can calculate a generalized\ninverse\n( pseudoinverse),\nregardless of whether the matrix is square or has a nonzero determinant, via the\nmatrix.pinv()\nfunction. Keep in mind that unlike a true inverse, the product of a\npseudoinverse and the original matrix does not necessarily equal the\nidentity matrix unless the original matrix _is invertible_.\n\nThe following example forms a 2x2 m matrix from user inputs, then calls\nmatrix.inv()\nand\nmatrix.pinv() as methods to calculate the inverse or pseudoinverse of m. The script\ndisplays strings representing the original matrix, its inverse or pseudoinverse, and their\nproduct in labels on the chart:\n\n//@version=6\nindicator(\"Inverse example\")\n\n// Element inputs for the 2x2 matrix.\nfloat r0c0 = input.float(4.0, \"Row 0, Col 0\")\nfloat r0c1 = input.float(3.0, \"Row 0, Col 1\")\nfloat r1c0 = input.float(2.0, \"Row 1, Col 0\")\nfloat r1c1 = input.float(1.0, \"Row 1, Col 1\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x2 matrix of input values.\nm = matrix.new<float>()\n\n// Add input values to \\m\\.\nm.add\\_row(0, array.from(r0c0, r0c1))\nm.add\\_row(1, array.from(r1c0, r1c1))\n\n//@variable Is \\true\\ if \\m\\ is square with a nonzero determinant, indicating invertibility.\nbool isInvertible = m.is\\_square() and m.det() != 0\n\n//@variable The inverse or pseudoinverse of \\m\\.\nmInverse = isInvertible ? m.inv() : m.pinv()\n\n//@variable The product of \\m\\ and \\mInverse\\. Returns the identity matrix when \\isInvertible\\ is \\true\\.\nmatrix<float> product = m.mult(mInverse)\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display \\m\\, \\mInverse\\, and their \\product\\.\nm.debugLabel(note = \"Original\")\nmInverse.debugLabel(bar\\_index + 10, color.purple, note = isInvertible ? \"Inverse\" : \"Pseudoinverse\")\nproduct.debugLabel(bar\\_index + 20, color.green, note = \"Product\")\n\nNote that:\n\n- This script calls m.inv() only when isInvertible is true, i.e., when m is square and has a nonzero determinant. Otherwise, it uses m.pinv() to calculate the generalized inverse.\n\n​ matrix.rank() ​\n\nThe _rank_ of a matrix represents the number of linearly independent\nvectors (rows or columns) it contains. In essence, matrix rank measures\nthe number of vectors one cannot express as a linear combination of\nothers, or in other words, the number of vectors that contain unique\ninformation. Scripts can calculate the rank of a matrix via\nmatrix.rank().\n\nThis script identifies the number of linearly independent vectors in two\n3x3 matrices ( m1 and m2) using matrix.rank() and plots the values in a separate pane. As\nwe see on the chart, the m1.rank() value is 3 because each vector is unique. The m2.rank() value, on the other hand, is 1 because it has just one unique vector:\n\n//@version=6\nindicator(\"Matrix rank example\")\n\n//@variable A 3x3 full-rank matrix.\nm1 = matrix.new<float>()\n//@variable A 3x3 rank-deficient matrix.\nm2 = matrix.new<float>()\n\n// Add linearly independent vectors to \\m1\\.\nm1.add\\_row(0, array.from(3, 2, 3))\nm1.add\\_row(1, array.from(4, 6, 6))\nm1.add\\_row(2, array.from(7, 4, 9))\n\n// Add linearly dependent vectors to \\m2\\.\nm2.add\\_row(0, array.from(1, 2, 3))\nm2.add\\_row(1, array.from(2, 4, 6))\nm2.add\\_row(2, array.from(3, 6, 9))\n\n// Plot \\matrix.rank()\\ values.\nplot(m1.rank(), color = color.green, linewidth = 3)\nplot(m2.rank(), color = color.red, linewidth = 3)\n\nNote that:\n\n- The highest rank value a matrix can have is the minimum of its\nnumber of rows and columns. A matrix with the maximum possible\nrank is known as a _full-rank_ matrix, and any matrix without\nfull rank is known as a _rank-deficient_ matrix.\n- The\ndeterminants of full-rank square matrices are nonzero, and such\nmatrices have\ninverses. Conversely, the\ndeterminant\nof a rank-deficient matrix is always 0.\n- For any matrix that contains nothing but the same value in each\nof its elements (e.g., a matrix filled with 0), the rank is\nalways 0 since none of the vectors hold unique information. For\nany other matrix with distinct values, the minimum possible rank\nis 1.\n\nError handling\n\nIn addition to usual compiler errors, which occur during a script’s\ncompilation due to improper syntax, scripts using matrices can raise\nspecific runtime errors during their execution. When a script raises\na runtime error, it displays a red exclamation point next to the script\ntitle. Users can view the error message by clicking this icon.\n\nIn this section, we discuss runtime errors that users may encounter\nwhile utilizing matrices in their scripts.\n\nThe row/column index (xx) is out of bounds, row/column size is (yy).\n\nThis runtime error occurs when trying to access indices outside the\nmatrix dimensions with functions including\nmatrix.get(),\nmatrix.set(),\nmatrix.fill(),\nand\nmatrix.submatrix(),\nas well as some of the functions relating to the\nrows and columns of a matrix.\n\nFor example, this code contains two lines that will produce this runtime\nerror. The\nm.set()\nmethod references a row index that doesn’t exist (2). The\nm.submatrix()\nmethod references all column indices up to to_column - 1. A\nto_column value of 4 results in a runtime error because the last\ncolumn index referenced (3) does not exist in m:\n\n//@version=6\nindicator(\"Out of bounds demo\")\n\n//@variable A 2x3 matrix with a max row index of 1 and max column index of 2.\nmatrix<float> m = matrix.new<float>(2, 3, 0.0)\n\nm.set(row = 2, column = 0, value = 1.0) // The \\row\\ index is out of bounds on this line. The max value is 1.\nm.submatrix(from\\_column = 1, to\\_column = 4) // The \\to\\_column\\ index is invalid on this line. The max value is 3.\n\nif bar\\_index == last\\_bar\\_index - 1\nlabel.new(bar\\_index, 0, str.tostring(m), color = color.navy, textcolor = color.white, size = size.huge)\n\nUsers can avoid this error in their scripts by ensuring their function\ncalls do not reference indices greater than or equal to the number of\nrows/columns.\n\nThe array size does not match the number of rows/columns in the matrix.\n\nWhen using\nmatrix.add\\_row()\nand\nmatrix.add\\_col()\nfunctions to\ninsert rows and columns into a non-empty matrix, the size of the\ninserted array must align with the matrix dimensions. The size of an\ninserted row must match the number of columns, and the size of an\ninserted column must match the number of rows. Otherwise, the script\nwill raise this runtime error. For example:\n\n//@version=6\nindicator(\"Invalid array size demo\")\n\n// Declare an empty matrix.\nm = matrix.new<float>()\n\nm.add\\_col(0, array.from(1, 2)) // Add a column. Changes the shape of \\m\\ to 2x1.\nm.add\\_col(1, array.from(1, 2, 3)) // Raises a runtime error because \\m\\ has 2 rows, not 3.\n\nplot(m.col(0).get(1))\n\nNote that:\n\n- When m is empty, one can insert a row or column array of _any_\nsize, as shown in the first m.add_col() line.\n\nCannot call matrix methods when the ID of matrix is ‘na’.\n\nWhen a matrix variable is assigned to na, it means that the variable\ndoesn’t reference an existing object. Consequently, one cannot use\nbuilt-in matrix.*() functions and methods with it. For example:\n\n//@version=6\nindicator(\"na matrix methods demo\")\n\n//@variable A \\matrix\\ variable assigned to \\na\\.\nmatrix<float> m = na\n\nmCopy = m.copy() // Raises a runtime error. You can't copy a matrix that doesn't exist.\n\nif bar\\_index == last\\_bar\\_index - 1\nlabel.new(bar\\_index, 0, str.tostring(mCopy), color = color.navy, textcolor = color.white, size = size.huge)\n\nTo resolve this error, assign m to a valid matrix instance before\nusing matrix.*() functions.\n\nMatrix is too large. Maximum size of the matrix is 100,000 elements.\n\nThe total number of elements in a matrix\n( matrix.elements\\_count())\ncannot exceed 100,000, regardless of its shape. For example, this\nscript will raise an error because it\ninserts 1000 rows with 101 elements into the m matrix:\n\n//@version=6\nindicator(\"Matrix too large demo\")\n\nvar matrix<float> m = matrix.new<float>()\n\nif bar\\_index == 0\nfor i = 1 to 1000\n// This raises an error because the script adds 101 elements on each iteration.\n// 1000 rows \\* 101 elements per row = 101000 total elements. This is too large.\nm.add\\_row(m.rows(), array.new<float>(101, i))\n\nplot(m.get(0, 0))\n\nThe row/column index must be 0 <= from\\_row/column < to\\_row/column.\n\nWhen using matrix.*() functions with from_row/column and\nto_row/column indices, the from_* values must be less than the\ncorresponding to_* values, with the minimum possible value being 0.\nOtherwise, the script will raise a runtime error.\n\nFor example, this script shows an attempt to declare a\nsubmatrix from a 4x4 m matrix with a from_row value of 2 and a\nto_row value of 2, which will result in an error:\n\n//@version=6\nindicator(\"Invalid from\\_row, to\\_row demo\")\n\n//@variable A 4x4 matrix filled with a random value.\nmatrix<float> m = matrix.new<float>(4, 4, math.random())\n\nmatrix<float> mSub = m.submatrix(from\\_row = 2, to\\_row = 2) // Raises an error. \\from\\_row\\ can't equal \\to\\_row\\.\n\nplot(mSub.get(0, 0))\n\nMatrices ‘id1’ and ‘id2’ must have an equal number of rows and columns to be added.\n\nWhen using\nmatrix.sum() and matrix.diff() functions, the id1 and id2 matrices must have the same\nnumber of rows and the same number of columns. Attempting to add or\nsubtract two matrices with mismatched dimensions will raise an error, as\ndemonstrated by this code:\n\n//@version=6\nindicator(\"Invalid sum dimensions demo\")\n\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 3x4 matrix.\nmatrix<float> m2 = matrix.new<float>(3, 4, 2)\n\nmSum = matrix.sum(m1, m2) // Raises an error. \\m1\\ and \\m2\\ don't have matching dimensions.\n\nplot(mSum.get(0, 0))\n\nThe number of columns in the ‘id1’ matrix must equal the number of rows in the matrix (or the number of elements in the array) ‘id2’.\n\nWhen using\nmatrix.mult() to multiply an id1 matrix by an id2 matrix or array, the\nmatrix.rows()\nor\narray.size()\nof id2 must equal the\nmatrix.columns()\nin id1. If they don’t align, the script will raise this error.\n\nFor example, this script tries to multiply two 2x3 matrices. While\n_adding_ these matrices is possible, _multiplying_ them is not:\n\n//@version=6\nindicator(\"Invalid mult dimensions demo\")\n\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 2x3 matrix.\nmatrix<float> m2 = matrix.new<float>(2, 3, 2)\n\nmSum = matrix.mult(m1, m2) // Raises an error. The number of columns in \\m1\\ and rows in \\m2\\ aren't equal.\n\nplot(mSum.get(0, 0))\n\nOperation not available for non-square matrices.\n\nSome matrix operations, including\nmatrix.inv(),\nmatrix.det(),\nmatrix.eigenvalues(),\nand\nmatrix.eigenvectors()\nonly work with square matrices, i.e., matrices with the same number\nof rows and columns. When attempting to execute such functions on\nnon-square matrices, the script will raise an error stating the\noperation isn’t available or that it cannot calculate the result for\nthe matrix id`. For example:\n\n//@version=6\nindicator(\"Non-square demo\")\n\n//@variable A 3x5 matrix.\nmatrix<float> m = matrix.new<float>(3, 5, 1)\n\nplot(m.det()) // Raises a runtime error. You can't calculate the determinant of a 3x5 matrix.\n\nPrevious\\\\\nArrays Next\\\\\nMaps",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[var/varip ][matrix<type> ]<identifier> = <expression>",
      "3 * x0 + 4 * x1 - 1 * x2 = 8\n\n5 * x0 - 2 * x1 + 1 * x2 = 4\n\n2 * x0 - 2 * x1 + 1 * x2 = 1"
    ]
  },
  "1a424f60": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Loops\n\nIntroduction\n\nLoops are structures that repeatedly execute a block of statements based on specified criteria. They allow scripts to perform repetitive tasks without requiring duplicated lines of code. Pine Script® features three distinct loop types: for, while, and for…in.\n\nEvery loop structure in Pine Script consists of two main parts: a _loop header_ and a _loop body_. The loop header determines the criteria under which the loop executes. The loop body is the indented block of code ( local block) that the script executes on each loop cycle ( _iteration_) as long as the header’s conditions remain valid. See the Common characteristics section to learn more.\n\nUnderstanding when and how to use loops is essential for making the most of the power of Pine Script. Inefficient or unnecessary usage of loops can lead to suboptimal runtime performance. However, effectively using loops when necessary enables scripts to perform a wide range of calculations that would otherwise be impractical or impossible without them.\n\nWhen loops are unnecessary\n\nPine’s execution model and time series structure make loops _unnecessary_ in many situations.\n\nWhen a user adds a Pine script to a chart, it runs within the equivalent of a _large loop_, executing its code once on _every_ historical bar and realtime tick in the available data. Scripts can access the values from the executions on previous bars with the history-referencing operator, and calculated values can _persist_ across executions when assigned to variables declared with the var or varip keywords. These capabilities enable scripts to utilize bar-by-bar calculations to accomplish various tasks instead of relying on explicit loops.\n\nIn addition, several built-ins, such as those in the ta.* namespace, are internally optimized to eliminate the need to use loops for various calculations.\n\nLet’s consider a simple example demonstrating unnecessary loop usage in Pine Script. To calculate the average close over a specified number of bars, newcomers to Pine may write a code like the following, which uses a for loop to calculate the sum of historical values over lengthInput bars and divides the result by the lengthInput:\n\nPine Script®\nCopied\n\n`//@version=6\nindicator(\"Unnecessary loops demo\", overlay = true)\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n//@variable The sum of close values over lengthInput bars.\nfloat closeSum = 0\n// Loop over the most recent lengthInput bars, adding each bar's close to the closeSum.\nfor i = 0 to lengthInput - 1\n    closeSum += close[i]\n//@variable The average close value over lengthInput bars.\nfloat avgClose = closeSum / lengthInput\n// Plot the avgClose.\nplot(avgClose, \"Average close\", color.orange, 2)\n\nUsing a for loop is an unnecessary, inefficient way to accomplish tasks like this in Pine. There are several ways to utilize the execution model and the available built-ins to eliminate this loop. Below, we replaced these calculations with a simple call to the ta.sma() function. This code is shorter, and it achieves the same result much more efficiently:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Unnecessary loops corrected demo\", overlay = true)\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n//@variable The average close value over lengthInput bars.\nfloat avgClose = ta.sma(close, lengthInput)\n// Plot the avgClose.\nplot(avgClose, \"Average close\", color.blue, 2)\n\nNote that:\n\n- Users can see the substantial difference in efficiency between these two example scripts by analyzing their performance with the Pine Profiler.\n\nWhen loops are necessary\n\nAlthough Pine’s execution model, time series, and available built-ins often eliminate the need for loops in many cases, not all iterative tasks have loop-free alternatives. Loops _are necessary_ for several types of tasks, including:\n\n- Iterating through or manipulating collections ( arrays, matrices, and maps)\n- Performing calculations that one cannot accomplish with loop-free expressions or the available built-ins\n- Looking back through history to analyze past bars with a reference value only available on the _current bar_\n\nFor example, a loop is _necessary_ to identify which past bars’ high values are above the current bar’s high because the current value is not obtainable during a script’s executions on previous bars. The script can only access the current bar’s value while it executes on that bar, and it must _look back_ through the historical series during that execution to compare the previous values.\n\nThe script below uses a for loop to compare the high values of lengthInput previous bars with the last historical bar’s high. Within the loop, it calls label.new() to draw a circular label above each past bar that has a high value exceeding that of the last historical bar:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Necessary loop demo\", overlay = true, max_labels_count = 500)\n//@variable The number of previous high values to compare to the last historical bar's high.\nint lengthInput = input.int(20, \"Length\", 1, 500)\nif barstate.islastconfirmedhistory\n    // Draw a horizontal line segment at the last historical bar's high to visualize the level.\n    line.new(bar_index - lengthInput, high, bar_index, high, color = color.gray, style = line.style_dashed, width = 2)\n    // Create a for loop that counts from 1 to lengthInput.\n    for i = 1 to lengthInput\n        // Draw a circular label above the bar from i bars ago if that bar's high is above the current high.\n        if high[i] > high\n            label.new(\n                 bar_index - i, na, \"\", yloc = yloc.abovebar, color = color.purple,\n                 style = label.style_circle, size = size.tiny\n             )\n// Highlight the last historical bar.\nbarcolor(barstate.islastconfirmedhistory ? color.orange : na, title = \"Last historical bar highlight\")\n\nNote that:\n\n- Each _iteration_ of the for loop retrieves a previous bar’s high with the history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D), using the loop’s _counter_ ( i) as the historical offset. The label.new() call also uses the counter to determine each label’s x-coordinate.\n- The indicator declaration statement includes max_labels_count = 500, meaning the script can show up to 500 labels on the chart.\n- The script calls barcolor() to highlight the last historical chart bar, and it draws a horizontal line at that bar’s high for visual reference.\n\nCommon characteristics\n\nThe for, while, and for…in loop statements all have similarities in their structure, syntax, and general behavior. Before we explore each specific loop type, let’s familiarize ourselves with these characteristics.\n\nStructure and syntax\n\nIn any loop statement, programmers define the criteria under which a script remains in a loop and performs _iterations_, where an iteration refers to _one execution_ of the code within the loop’s local block ( _body_). These criteria are part of the _loop header_. A script evaluates the header’s criteria _before_ each iteration, only allowing new iterations to occur while they remain valid. When the header’s criteria are no longer valid, the script _exits_ the loop and skips over its body.\n\nThe specific header syntax varies with each loop statement ( for, while, or for…in) because each uses _distinct_ criteria to control its iterations. Effective use of loops entails choosing the structure with control criteria best suited for a script’s required tasks. See the \\for\\ loops, \\while\\ loops, and \\for…in\\ loops sections below for more information on each loop statement and its control criteria.\n\nAll loop statements in Pine Script follow the same general syntax:\n\n`\n\n[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere:\n\n- loop_header represents the loop structure’s header statement, which defines the criteria that control the loop’s iterations.\n- statements represents the code statements and expressions within the loop’s body, i.e., the _indented_ block of code beneath the loop header. All code within the body belongs to the loop’s local scope.\n- continue and break are loop-specific _keywords_ that control the flow of a loop’s iterations. The continue keyword instructs the script to _skip_ the remainder of the current loop iteration and _continue_ to the next iteration. The break keyword prompts the script to _stop_ the current iteration and _exit_ the loop entirely. See this section below for more information.\n- return_expression refers to the _last_ code line or block within the loop’s body. The loop returns the results from this code after the final iteration. If the loop skips parts of some iterations or stops prematurely due to a continue or break statement, the returned values or references are those of the latest iteration that evaluated this code. To use the loop’s returned results, assign them to a variable or tuple.\n- variables represents an optional variable or tuple to hold the values or references from the last evaluation of the return_expression. The script can assign the loop’s returned results to variables only if the results are not void. If the loop’s conditions prevent iteration, or if no iterations evaluate the return_expression, the variables’ assigned values and references are na.\n\nScope\n\nAll code lines that a script executes within a loop must have an indentation of _four spaces_ or a _tab_ relative to the loop’s header. The indented lines following the header define the loop’s _body_. This code represents a _local block_, meaning that all the definitions within the body are accessible only during the loop’s execution. In other words, the code within the loop’s body is part of its _local scope_.\n\nScripts can modify and reassign most variables from _outer_ scopes inside a loop. However, any variables declared within the loop’s body strictly belong to that loop’s local scope. A script cannot access a loop’s declared variables _outside_ its local block.\n\nNote that:\n\n- Variables declared within a loop’s _header_ are also part of the local scope. For instance, a script cannot use the _counter variable_ in a for loop anywhere but within the loop’s local block.\n\nThe body of any Pine loop statement can include conditional structures and _nested_ loop statements. When a loop includes nested structures, each structure within the body maintains a _distinct_ local scope. For example, variables declared within an _outer_ loop’s scope are accessible to an _inner_ loop. However, any variables declared within the inner loop’s scope are not accessible to the outer loop.\n\nThe simple example below demonstrates how a loop’s local scope works. This script calls label.new() within a for loop on the last historical bar to draw labels above lengthInput past bars. The color of each label depends on the labelColor variable declared _within_ the loop’s local block, and each label’s location depends on the loop counter ( i):\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\nif barstate.islastconfirmedhistory\n    for i = 1 to lengthInput\n        //@variable Has a value of color.blue if close[i] is above the current close, color.orange otherwise.\n        //          This variable is LOCAL to the for loop's scope.\n        color labelColor = close[i] > close ? color.blue : color.orange\n        // Display a colored label on the historical high from i bars back, using labelColor to set the color.\n        label.new(bar_index - i, high[i], \"\", color = labelColor, size = size.normal)\n\nIn the above code, the i and labelColor variables are only accessible to the for loop’s local scope. They are not usable within any outer scopes. Here, we added a label.new() call _after_ the loop with bar_index - i as the x argument and labelColor as the color argument. This code causes a _compilation error_ because neither i nor labelColor are valid variables in the outer scope:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\nif barstate.islastconfirmedhistory\n    for i = 1 to lengthInput\n        //@variable Has a value of color.blue if close[i] is above the current close, color.orange otherwise.\n        //          This variable is LOCAL to the for loop's scope.\n        color labelColor = close[i] > close ? color.blue : color.orange\n        // Display a colored label on the historical high from i bars back, using labelColor to set the color.\n        label.new(bar_index - i, high[i], \"\", color = labelColor, size = size.normal)\n    // Call label.new() to using the i and labelColor variables outside the loop's local scope.\n    // This code causes a compilation error because these variables are not accessible in this location.\n    label.new(\n         bar_index - i, low, \"Scope test\", textcolor = color.white, color = labelColor, style = label.style_label_up\n     )\n\nKeywords and return expressions\n\nEvery loop in Pine Script implicitly _returns_ values, references, or void. A loop’s returned results come from the _latest_ execution of the _last_ expression or nested structure within its body as of the final iteration. The results are usable only if they are not of the void type. Loops return na results for values or references when no iterations occur. Scripts can add a variable or tuple assignment to a loop statement to hold the returned results for use in additional calculations outside the loop’s local scope.\n\nThe values or references that a loop returns usually come from evaluating the last written expression or nested code block on the _final_ iteration. However, a loop’s body can include continue and break keywords to control the flow of iterations beyond the criteria the loop header specifies, which can also affect the returned results. Programmers often include these keywords within conditional structures to control how iterations behave when certain conditions occur.\n\nThe continue keyword instructs a script to _skip_ the remaining statements and expressions in the current loop iteration, re-evaluate the loop header’s criteria, and proceed to the _next_ iteration. The script _exits_ the loop if the header’s criteria do not allow another iteration.\n\nThe break keyword instructs a script to _stop_ the loop entirely and immediately _exit_ at that point without allowing any subsequent iterations. After breaking the loop, the script skips any remaining code within the loop’s body and _does not_ re-evaluate the header’s criteria.\n\nIf a loop skips parts of iterations or stops prematurely due to a continue or break statement, it returns the values and references from the _last iteration_ where the script _evaluated_ the return expression. If the script did not evaluate the return expression across _any_ of the loop’s iterations, the loop returns na results for all non-void types.\n\nThe example below selectively displays numbers from an array within a label on the last historical bar. It uses a for…in loop to iterate through the array’s elements and build a “string” to use as the displayed text. The loop’s body contains an if statement that controls the flow of specific iterations. If the number in the current iteration is 8, the script immediately _exits_ the loop using the break keyword. Otherwise, if the number is even, it _skips_ the rest of the current iteration and moves to the next one using the continue keyword.\n\nIf neither of the if statement’s conditions occur, the script evaluates the _last expression_ within the loop’s body (i.e., the return expression), which converts the current number to a “string” and concatenates the result with the tempString value. The loop returns the _last evaluated result_ from this expression after termination. The script assigns the returned value to the finalLabelText variable and uses that variable as the text argument in the label.new() call:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Loop keywords and variable assignment demo\")\n//@variable An array of arbitrary \"int\" values to selectively convert to \"string\" and display in a label.\nvar array<int> randomArray = array.from(1, 5, 2, -3, 14, 7, 9, 8, 15, 12)\n// Label creation logic.\nif barstate.islastconfirmedhistory\n    //@variable A \"string\" containing representations of selected values from the randomArray.\n    string tempString = \"\"\n    //@variable The final text to display in the label. The for..in loop returns the result after it terminates.\n    string finalLabelText = for number in randomArray\n        // Stop the current iteration and exit the loop if the number from the randomArray is 8.\n        if number == 8\n            break\n        // Skip the rest of the current iteration and proceed to the next iteration if the number is even.\n        else if number % 2 == 0\n            continue\n        // Convert the number to a \"string\", append \", \", and concatenate the result with the current tempString.\n        // This code represents the loop's return expression.\n        tempString += str.tostring(number) + \", \"\n\n    // Display the value of the finalLabelText within a label on the current bar.\n    label.new(bar_index, 0, finalLabelText, color = color.blue, textcolor = color.white, size = size.huge)\n\nNote that:\n\n- The label displays only _odd_ numbers from the array because the script does not reassign the tempString when the loop iteration’s number is even. However, it does not include the _last_ odd number from the array (15) because the loop stops when number == 8, preventing iteration over the remaining randomArray elements.\n- When the script exits the loop due to the break keyword, the loop’s return value becomes the last evaluated result from the tempString reassignment expression. In this case, the last time that code executes is on the iteration where number == 9.\n\n​ for ​ loops\n\nThe for loop statement creates a _count-controlled_ loop, which uses a _counter_ variable to manage the iterative executions of its local code block. The counter starts at a predefined initial value, and the loop increments or decrements the counter by a fixed amount after each iteration. The loop stops its iterations after the counter reaches a specified final value.\n\nPine Script uses the following syntax to define a for loop:\n\n`\n\n[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the following parts define the _loop header_:\n\n- counter represents the counter variable, which can be any valid identifier. The loop increments or decrements this variable’s value from the initial value ( from_num) to the final value ( to_num) by a fixed amount ( step_num) after each iteration. The last possible iteration occurs when the variable’s value reaches the to_num value.\n- from_num is the counter variable’s initial value on the first iteration.\n- to_num is the _final_ counter value for which the loop’s header allows a new iteration. The loop adjusts the counter value by the step_num amount until it reaches or passes this value. If the script modifies the to_num during a loop iteration, the loop header uses the new value to control the allowed subsequent iterations.\n- step_num is a positive value representing the amount by which the counter value increases or decreases until it reaches or passes the to_num value. If the from_num value is greater than the _initial_ to_num value, the loop _subtracts_ this amount from the counter value after each iteration. Otherwise, the loop _adds_ this amount after each iteration. The default is 1.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThis simple script demonstrates a for loop that draws several labels at future bar indices during its execution on the last historical chart bar. The loop’s counter starts at 0, then increases by 1 until it reaches a value of 10, at which point the final iteration occurs:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Simple for loop demo\")\nif barstate.islastconfirmedhistory\n    // Define a for loop that iterates from i == 0 to i == 10 by 1 (11 total iterations).\n    for i = 0 to 10\n        // Draw a new label i bars ahead of the current bar.\n        label.new(bar_index + i, 0, str.tostring(i), textcolor = color.white, size = size.large)\n\nNote that:\n\n- The i variable represents the loop’s _counter_. This variable is local to the loop’s scope, meaning no _outer scopes_ can access it. The code uses the variable within the loop’s body to determine the location and text of each label drawing.\n- Programmers often use i, j, and k as loop counter identifiers. However, _any_ valid variable name is allowed. For example, this code behaves the same if we name the counter offset instead of i.\n- The for loop structure _automatically_ manages the counter variable. We do not need to define code in the loop’s body to increment its value.\n\nThe direction in which a for loop adjusts its counter depends on the _initial_ from_num and to_num values in the loop’s header, and the direction does not change across iterations. The loop counts _upward_ after each iteration when the to_num value is _above_ the from_num value, as shown in the previous example. If the to_num value is _below_ the from_num value, the loop counts _downward_ instead.\n\nThe script below calculates and plots the volume-weighted moving average (VWMA) of open prices across a specified number of bars. Then, it uses a downward-counting for loop to compare the last historical bar’s value to the values from previous bars, starting with the oldest bar in the specified lookback window. On each loop iteration, the script retrieves a previous bar’s vwmaOpen value, calculates the difference from the current bar’s value, and displays the result in a label at the past bar’s opening price:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for loop demo\", \"VWMA differences\", true, max_labels_count = 500)\n//@variable Display color for indicator visuals.\nconst color DISPLAY_COLOR = color.rgb(17, 127, 218)\n//@variable The number of bars in the vwmaOpen calculation.\nint maLengthInput = input.int(20, \"VWMA length\", 1)\n//@variable The number of past bars to look back through and compare to the current bar.\nint lookbackInput = input.int(15, \"Lookback length\", 1, 500)\n//@variable The volume-weighted moving average of open values over maLengthInput bars.\nfloat vwmaOpen = ta.vwma(open, maLengthInput)\nif barstate.islastconfirmedhistory\n    // Define a for loop that counts downward from i == lookbackInput to i == 1.\n    for i = lookbackInput to 1\n        //@variable The difference between the vwmaOpen from i bars ago and the current vwmaOpen.\n        float vwmaDifference = vwmaOpen[i] - vwmaOpen\n        //@variable A \"string\" representation of vwmaDifference, rounded to two fractional digits.\n        string displayText = (vwmaDifference > 0 ? \"+\" : \"\") + str.tostring(vwmaDifference, \"0.00\")\n        // Draw a label showing the displayText at the open of the bar from i bars back.\n        label.new(\n             bar_index - i, open[i], displayText, textcolor = color.white, color = DISPLAY_COLOR,\n             style = label.style_label_lower_right, size = size.normal\n         )\n// Plot the vwmaOpen value.\nplot(vwmaOpen, \"VWMA\", color = DISPLAY_COLOR, linewidth = 2)\n\nNote that:\n\n- The script uses the loop’s counter ( i) to within the history-referencing operator to retrieve past values of the vwmaOpen series. It also uses the counter to determine the location of each label drawing.\n- The loop in this example _decreases_ the counter by one on each iteration because the final counter value in the loop’s header ( 1) is less than the starting value ( lookbackInput).\n\nProgrammers can use for loops to iterate through collections, such as arrays and matrices. The loop’s counter can serve as an _index_ for retrieving or modifying a collection’s contents. For example, this code block uses array.get() inside a for loop to successively retrieve elements from an array:\n\nPine Script®\nCopied\n\nint lastIndex = array.size(myArray) - 1\nfor i = 0 to lastIndex\nelement = array.get(i)\n\nNote that:\n\n- Array _indexing_ starts from 0, but the array.size() function _counts_ array elements starting from 1. Therefore, we must subtract 1 from the array’s size to get the maximum index value. This way, the loop counter avoids representing an out-of-bounds index on the last loop iteration.\n- The for…in loop statement is often the _preferred_ way to loop through collections. However, programmers may prefer a for loop for some tasks, such as looping through stepped index values, iterating over a collection’s contents in reverse or a nonlinear order, and more. See the Looping through arrays and Looping through matrices sections to learn more about the best practices for looping through these collection types.\n\nThe script below executes ta.rsi() and ta.mom() calls to calculate the RSI and momentum of close prices over three different lengths (10, 20, and 50), then displays the results using a table on the last chart bar. It stores “string” values for the header title within arrays and the “float” values of the calculated indicators within a 2x3 matrix. The script uses a for loop to access the elements in the arrays and initialize the displayTable header cells. It then uses _nested_ for loops to iterate over the _row_ and _column_ indices in the taMatrix, access elements, convert their values to strings, and populate the remaining table cells:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for loop with collections demo\", \"Table of TA Indexes\", overlay = true)\n// Calculate the RSI and momentum of close values with constant lengths of 10, 20, and 50.\nfloat rsi10 = ta.rsi(close, 10)\nfloat rsi20 = ta.rsi(close, 20)\nfloat rsi50 = ta.rsi(close, 50)\nfloat mom10 = ta.mom(close, 10)\nfloat mom20 = ta.mom(close, 20)\nfloat mom50 = ta.mom(close, 50)\n\nif barstate.islast\n    //@variable A table that displays indicator values in the top-right corner of the chart.\n    var table displayTable = table.new(\n         position.top_right, columns = 5, rows = 4, border_color = color.black, border_width = 1\n     )\n    //@variable An array containing the \"string\" titles to display within the side header of each table row.\n    array<string> sideHeaderTitles = array.from(\"TA Index\", \"RSI\", \"Momentum\")\n    //@variable An array containing the \"string\" titles to representing the length of each displayed indicator.\n    array<string> topHeaderTitles = array.from(\"10\", \"20\", \"50\")\n    //@variable A matrix containing the values to display within the table.\n    matrix<float> taMatrix = matrix.new<float>()\n    // Populate the taMatrix with indicator values. The first row contains RSI data and the second contains momentum.\n    taMatrix.add_row(0, array.from(rsi10, rsi20, rsi50, mom10, mom20, mom50))\n    taMatrix.reshape(2, 3)\n    // Initialize top header cells.\n    displayTable.cell(1, 0, \"Bars Length\", text_color = color.white, bgcolor = color.blue)\n    displayTable.merge_cells(1, 0, 3, 0)\n    // Initialize additional header cells within a for loop.\n    for i = 0 to 2\n        displayTable.cell(0, i + 1, sideHeaderTitles.get(i), text_color = color.white, bgcolor = color.blue)\n        displayTable.cell(i + 1, 1, topHeaderTitles.get(i), text_color = color.white, bgcolor = color.purple)\n    // Use nested for loops to iterate through the row and column indices of the taMatrix.\n    for i = 0 to taMatrix.rows() - 1\n        for j = 0 to taMatrix.columns() - 1\n            //@variable The value stored in the taMatrix at the i row and j column.\n            float elementValue =  taMatrix.get(i, j)\n            // Initialize a cell in the displayTable at the i + 2 row and j + 1 column showing a \"string\"\n            // representation of the elementValue.\n            displayTable.cell(\n                 column = j + 1, row = i + 2, text = str.tostring(elementValue, \".\"), text_color = chart.fg_color\n             )\n\nNote that:\n\n- Both arrays of header names ( sideHeaderTitles and topHeaderTitles) contain the same number of elements, enabling the script to iterate through their contents simultaneously using a single for loop.\n- The nested for loops iterate over _all_ the index values in the taMatrix. The _outer_ loop iterates over each _row_ index, and the _inner_ loop iterates over every _column_ index on each outer loop iteration.\n- The script creates and displays the table only on the last historical bar and all realtime bars because the historical states of tables are _never_ visible. See the Reducing drawing updates of the Profiling and optimization page for more information.\n\nIt’s important to note that a for loop’s header _dynamically_ evaluates the to_num value at the start of _every iteration_. If the to_num argument is a variable and the script changes its value during an iteration, the loop uses the _new value_ to update its stopping condition. Likewise, the stopping condition can change across iterations when the to_num argument is an expression or function call that depends on data modified in the loop’s scope, such as a call to array.size() on a locally resized array or str.length() on an adjusted string. Therefore, scripts can use for loops to perform iterative tasks where the exact number of required iterations is _not predictable_ in advance, similar to while loops.\n\nFor example, the following script uses a dynamic for loop to determine the historical offset of the most recent bar whose close differs from the current bar’s close by at least one standard deviation. The script declares a barOffset variable with an initial value of zero and uses that variable to define the loop counter’s to_num boundary. Within the loop’s scope, the script increments the barOffset by one if the referenced bar’s close is not far enough from the current bar’s value. Each time the barOffset value increases, the loop increases its final counter value, allowing an _extra iteration_. The script plots the barOffset and the corresponding bar’s close for visual reference:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for loop with dynamic to_num demo\")\n//@variable The length of the standard deviation.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n//@variable The standard deviation of close prices over lengthInput bars.\nfloat stdev = ta.stdev(close, lengthInput)\n//@variable The minimum bars back where the past bar's close differs from the current close by at least stdev.\n//          Used as the weight value in the weighted average.\nint barOffset = 0\n// Define a for loop that iterates from 0 to barsBack.\nfor i = 0 to barOffset\n    // Add 1 for each bar where the distance from that bar's close to the current bar's close is less than stdev.\n    // Each time barsBack increases, it changes the loop's to_num boundary, allowing another iteration.\n    barOffset += math.abs(close - close[i]) < stdev ? 1 : 0\n//@variable A gradient color for the barOffset plot.\ncolor offsetColor = color.from_gradient(barOffset, 0, lengthInput, color.blue, color.orange)\n// Plot the barOffset in a separate pane.\nplot(barOffset, \"Bar offset\", offsetColor, 1, plot.style_columns)\n// Plot the historical close price from barOffset bars back in the main chart pane.\nplot(close[barOffset], \"Historical bar's price\", color.blue, 3, force_overlay = true)\n\nNote that:\n\n- Changing the to_num value on an iteration does not affect the established _direction_ in which the loop adjusts its counter variable. For instance, if the loop in this example changed barOffset to -1 on any iteration, it would stop immediately after that iteration ends without reducing the i value.\n- The script uses force_overlay = true in the second plot() call to display the historical closing price on the main chart pane.\n\n​ while ​ loops\n\nThe while loop statement creates a _condition-controlled_ loop, which uses a _conditional expression_ to control the executions of its local block. The loop continues its iterations as long as the specified condition remains true.\n\nPine Script uses the following syntax to define a while loop:\n\n`\n\n[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the condition in the loop’s _header_ can be a literal, variable, expression, or function call that returns a “bool” value.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nA while loop’s header evaluates its condition before each iteration. Consequently, when the script modifies the condition within an iteration, the loop’s header reflects those changes on the _next_ iteration.\n\nDepending on the specified condition in the loop header, a while loop can behave similarly to a for loop, continuing iteration until a _counter_ variable reaches a specified limit. For example, the following script uses a for loop and while loop to perform the same task. Both loops draw a label displaying their respective counter value on each iteration:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"while loop with a counter condition demo\")\nif barstate.islastconfirmedhistory\n    // A for loop that creates blue labels displaying each i value.\n    for i = 0 to 10\n        label.new(\n             bar_index + i, 0, str.tostring(i), color = color.blue, textcolor = color.white,\n             size = size.large, style = label.style_label_down\n         )\n    //@variable An \"int\" to use as a counter within a while loop.\n    int j = 0\n    // A while loop that creates orange labels displaying each j value.\n    while j <= 10\n        label.new(\n             bar_index + j, 0, str.tostring(j), color = color.orange, textcolor = color.white,\n             size = size.large, style = label.style_label_up\n         )\n        // Update the j counter within the local block.\n        j += 1\n\nNote that:\n\n- When a while loop uses count-based logic, it must explicitly manage the user-specified counter within the local block. In contrast, a for loop increments its counter automatically.\n- The script declares the variable the while loop uses as a counter _outside_ the loop’s scope, meaning its value is usable in additional calculations after the loop terminates.\n- If this code did not increment the j variable within the while loop’s body, the value would _never_ reach 10, meaning the loop would run _indefinitely_ until causing a runtime error.\n\nBecause a while loop’s execution depends on its condition remaining true, and the condition might not change on a specific iteration, the _precise_ number of expected iterations might not be knowable _before_ the loop begins. Therefore, while loops are often helpful in scenarios where the exact loop boundaries are _unknown_.\n\nThe script below tracks when the chart’s close crosses outside Keltner Channels with a user-specified length and channel width. When the price crosses outside the current bar’s channel, the script draws a box highlighting all the previous _consecutive_ bars with close values within that price window. The script uses a while loop to analyze past bars’ prices and incrementally adjust the left side of each new box until the drawing covers all the latest consecutive bars in the current range:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"while loop demo\", \"Price window boxes\", true)\n//@variable The length of the channel.\nint lengthInput = input.int(20, \"Channel length\", 1, 4999)\n//@variable The width multiplier of the channel.\nfloat widthInput = input.float(2.0, \"Width multiplier\", 0)\n//@variable The lengthInput-bar EMA of close prices.\nfloat ma = ta.ema(close, lengthInput)\n//@variable The lengthInput-bar ATR, multiplied by the widthInput.\nfloat atr = ta.atr(lengthInput) * widthInput\n//@variable The lower bound of the channel.\nfloat channelLow = ma - atr\n//@variable The upper bound of the channel.\nfloat channelHigh = ma + atr\n//@variable Is true when the close price is outside the current channel range, false otherwise.\nbool priceOutsideChannel = close < channelLow or close > channelHigh\n// Check if the close crossed outside the channel range, then analyze the past bars within the current range.\nif priceOutsideChannel and not priceOutsideChannel[1]\n    //@variable A box that highlights consecutive past bars within the current channel's price window.\n    box windowBox = box.new(\n         bar_index, channelHigh, bar_index, channelLow, border_width = 2, bgcolor = color.new(color.gray, 85)\n     )\n    //@variable The lookback index for box adjustment. The while loop increments this value on each iteration.\n    int i = 1\n    // Use a while loop to look backward through close prices. The loop iterates as long as the past close\n    // from i bars ago is between the current bar's channelLow and channelHigh.\n    while close[i] >= channelLow and close[i] <= channelHigh\n        // Adjust the left side of the box.\n        windowBox.set_left(bar_index - i)\n        // Add 1 to the i value to check the close from the next bar back on the next iteration.\n        i += 1\n// Plot the channelLow and channelHigh for visual reference.\nplot(channelLow, \"Channel low\")\nplot(channelHigh, \"Channel high\")\n`\n\nNote that:\n\n- The left and right edges of boxes sit within the horizontal _center_ of their respective bars, meaning that each drawing spans from the middle of the first consecutive bar to the middle of the last bar within each window.\n- This script uses the i variable as a history-referencing index within the _conditional expression_ the while loop checks on each iteration. The variable does not behave as a loop counter, as the iteration boundaries are unknown. The loop executes its local block repeatedly until the condition becomes false.\n\n​ for...in ​ loops\n\nThe for…in loop statement creates a _collection-controlled_ loop, which uses the _contents_ of a collection to control its iterations. This loop structure is often the preferred approach for looping through arrays, matrices, and maps.\n\nA for…in loop traverses a collection _in order_, retrieving one of its stored items on each iteration. Therefore, the loop’s boundaries depend directly on the number of _items_ ( array _elements_, matrix _rows_, or map _key-value pairs_).\n\nPine Script features _two_ general forms of the for…in loop statement. The _first form_ uses the following syntax:\n\n`\n\n[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere item is a _variable_ that holds sequential values or references from the specified collection_id. The variable starts with the collection’s _first item_ and takes on successive items in order after each iteration. This form is convenient when a script must access values from an array or matrix iteratively but does not require the item’s _index_ in its calculations.\n\nThe _second form_ has a slightly different syntax that includes a tuple in its _header_:\n\n`\n\n[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere index is a variable that contains the _index_ or _key_ of the retrieved item. This form is convenient when a task requires using a collection’s items _and_ their indices in iterative calculations. This form of the for…in loop is _required_ when directly iterating through the contents of a map. See this section below for more information.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThe iterative behavior of a for…in loop depends on the _type_ of collection the header specifies as the collection_id:\n\n- When using an array in the header, the loop performs _element-wise_ iteration, meaning the retrieved item on each iteration is one of the array’s _elements_.\n- When using a matrix in the header, the loop performs _row-wise_ iteration, which means that each item represents a _row array_.\n- When using a map in the header, the loop performs _pair-wise_ iteration, which retrieves a _key_ and corresponding _value_ on each iteration.\n\nLooping through arrays\n\nPine scripts can iterate over the elements of arrays using any loop structure. However, the for…in loop is typically the most convenient because it automatically verifies the size of an array when controlling iterations. With other loop structures, programmers must carefully set the header’s boundaries or conditions to _prevent_ the loop from attempting to access an element at a _nonexistent_ index.\n\nFor example, a for loop can access an array’s elements using the counter variable as the lookup index in functions such as array.get(). However, programmers must ensure the counter always represents a _valid index_ to prevent out-of-bounds errors. Additionally, if an array might be _empty_, programmers must set conditions to prevent the loop’s execution entirely.\n\nThe code below shows a for loop whose counter boundaries depend on the number of elements in an array. If the array is empty, containing zero elements, the header’s final counter value is na, which _prevents_ iteration. Otherwise, the final value is _one less_ than the array’s size (i.e., the index of the last element):\n\nPine Script®\nCopied\n\nfor index = 0 to (array.size(myArray) == 0 ? na : array.size(myArray) - 1)\n    element = array.get(myArray, index)\n\nIn contrast, a for…in loop automatically validates an array’s size and _directly_ accesses its elements, providing a more convenient solution than a traditional for loop. The line below achieves the _same effect_ as the code above without requiring the programmer to define boundaries explicitly or use the array.get() function to access each element:\n\nPine Script®\nCopied\n\nfor element in myArray\n\nThe following example examines bars on a lower timeframe to gauge the strength of _intrabar_ trends within each chart bar. The script uses a request.security\\_lower\\_tf() call to retrieve an array of intrabar hl2 prices from a calculated lowerTimeframe. Then, it uses a for…in loop to access each price within the intrabarPrices array and compare the value to the current close to calculate the bar’s strength. The script plots the strength as columns in a separate pane:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for element in array demo\", \"Intrabar strength\")\n//@variable A valid timeframe closest to one-tenth of the current chart's timeframe, \"1\" if the timeframe is too small.\nvar string lowerTimeframe = timeframe.from_seconds(math.max(int(timeframe.in_seconds() / 10), 60))\n//@variable An array of intrabar hl2 prices calculated from the lowerTimeframe.\narray<float> intrabarPrices = request.security_lower_tf(\"\", lowerTimeframe, hl2)\n//@variable The excess trend strength of intrabarPrices.\nfloat strength = 0.0\n// Loop directly through the intrabarPrices array. Each iteration's price represents an array element.\nfor price in intrabarPrices\n    // Subtract 1 from the strength if the retrieved price is above the current bar's close price.\n    if price > close\n        strength -= 1\n    // Add 1 to the strength if the retrieved price is below the current bar's close price.\n    else if price < close\n        strength += 1\n//@variable Is color.teal when the strength is positive, color.maroon otherwise.\ncolor strengthColor = strength > 0 ? color.teal : color.maroon\n// Plot the strength as columns colored by the strengthColor.\nplot(strength, \"Intrabar strength\", strengthColor, 1, plot.style_columns)\n\nThe second form of the for…in loop is a convenient solution when a script’s calculations require accessing each element _and_ corresponding index within an array:\n\nPine Script®\nCopied\n\nfor [index, element] in myArray\n\nFor example, suppose we want to display a _numerated_ list of array elements within a label while excluding values at specific indices. We can use the second form of the for…in loop structure to accomplish this task. The simple script below declares a stringArray variable that references an array of predefined “string” values. On the last historical bar, the script uses a for…in loop to access each index and element in the stringArray to construct the labelText, which it uses in a label.new() call after the loop ends:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for [index, item] in array demo\", \"Array numerated output\")\n//@variable An array of \"string\" values to display as a numerated list.\nvar array<string> stringArray = array.from(\"First\", \"Second\", \"Third\", \"Before Last\", \"Last\")\nif barstate.islastconfirmedhistory\n    //@variable A \"string\" modified within a loop to display within the label.\n    string labelText = \"Array values: \\n\"\n    // Loop through the stringArray, accessing each index and corresponding element.\n    for [index, element] in stringArray\n        // Skip the third element (at index == 2) in the labelText. Include an \"ELEMENT SKIPPED\" message instead.\n        if index == 2\n            labelText += \"-- ELEMENT SKIPPED -- \\n\"\n            continue\n        labelText += str.tostring(index + 1) + \": \" + element + \"\\n\"\n    // Display the labelText within a label.\n    label.new(\n         bar_index, 0, labelText, textcolor = color.white, size = size.huge,\n         style = label.style_label_center, textalign = text.align_left\n     )\n\nNote that:\n\n- This example adds 1 to the index in the str.tostring() call to start the numerated list with a value of \"1\", because array indices always begins at 0.\n- On the _third_ loop iteration, when index == 2, the script adds an \"-- ELEMENT SKIPPED --\" message to the labelText instead of the retrieved element and uses the continue keyword to skip the remainder of the iteration. See this section above to learn more about loop keywords.\n\nLet’s explore an advanced example demonstrating the utility of for…in loops. The following indicator draws a fixed number of horizontal lines at pivot high values calculated from a ta.pivothigh() call, and it analyzes the lines within a loop to determine which ones represent active ( _uncrossed_) pivots.\n\nEach time the script detects a new pivot high point, it creates a new line, _inserts_ that line at the beginning of the pivotLines array, then removes the oldest element and deletes its ID. The script accesses each line within the array using a for…in loop, analyzing and modifying the properties of the line referenced on each iteration. When the current high crosses above the pivotLine, the script changes its style to signify that it is no longer an active level. Otherwise, it extends the line’s x2 coordinate and uses its price to calculate the average _active_ pivot value. The script also plots each pivot high value and the average active pivot value on the chart:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for...in loop with arrays demo\", \"Active high pivots\", true, max_lines_count = 500)\n//@variable The number of bars required on the left and right to confirm a pivot point.\nint pivotBarsInput = input.int(5, \"Pivot leg length\", 1)\n//@variable The number of recent pivot lines to analyze. Controls the size of the pivotLines array.\nint maxRecentLines = input.int(20, \"Maximum recent lines\", 1, 500)\n//@variable An array that acts as a queue holding the most recent pivot high lines.\nvar array<line> pivotLines = array.new<line>(maxRecentLines)\n//@variable The pivot high price, or na if no pivot is found.\nfloat highPivotPrice = ta.pivothigh(pivotBarsInput, pivotBarsInput)\nif not na(highPivotPrice)\n    //@variable The chart.point for the start of the line. Does not contain time information.\n    firstPoint = chart.point.from_index(bar_index - pivotBarsInput, highPivotPrice)\n    //@variable The chart.point for the end of each line. Does not contain time information.\n    secondPoint = chart.point.from_index(bar_index, highPivotPrice)\n    //@variable A horizontal line at the new pivot level.\n    line hiPivotLine = line.new(firstPoint, secondPoint, width = 2, color = color.green)\n    // Insert the hiPivotLine at the beginning of the pivotLines array.\n    pivotLines.unshift(hiPivotLine)\n    // Remove the oldest line from the array and delete its ID.\n    line.delete(pivotLines.pop())\n//@variable The sum of active pivot prices.\nfloat activePivotSum = 0.0\n//@variable The number of active pivot high levels.\nint numActivePivots = 0\n// Loop through the pivotLines array, directly accessing each pivotLine element.\nfor pivotLine in pivotLines\n    //@variable The x2 coordinate of the pivotline.\n    int lineEnd = pivotLine.get_x2()\n    // Move to the next pivotline in the array if the current line is inactive.\n    if pivotLine.get_x2() < bar_index - 1\n        continue\n    //@variable The price value of the pivotLine.\n    float pivotPrice = pivotLine.get_price(bar_index)\n    // Change the style of the pivotLine and stop extending its display if the high is above the pivotPrice.\n    if high > pivotPrice\n        pivotLine.set_color(color.maroon)\n        pivotLine.set_style(line.style_dotted)\n        pivotLine.set_width(1)\n        continue\n    // Extend the pivotLine and add the pivotPrice to the activePivotSum when the loop allows a full iteration.\n    pivotLine.set_x2(bar_index)\n    activePivotSum  += pivotPrice\n    numActivePivots += 1\n//@variable The average active pivot high value.\nfloat avgActivePivot = activePivotSum / numActivePivots\n// Plot crosses at the highPivotPrice, offset backward by the pivotBarsInput.\nplot(highPivotPrice, \"High pivot marker\", color.green, 3, plot.style_cross, offset = -pivotBarsInput)\n// Plot the avgActivePivot as a line with breaks.\nplot(avgActivePivot, \"Avg. active pivot\", color.orange, 3, plot.style_linebr)\n\nNote that:\n\n- The loop in this example executes on _every bar_ because it has to compare active pivot line prices with the current high value, then use the remaining active prices to calculate the bar’s avgActivePivot value.\n- Pine Script features several ways to calculate averages, many of which _do not_ require a loop. However, a loop is necessary in this example because the script uses information only available on the current bar to determine which prices contribute toward the average.\n- The _first_ form of the for…in loop is the most convenient option in this example because we need direct access to the lines referenced within the pivotLines array, but we do not need the corresponding _index_ values.\n\nLooping through matrices\n\nPine scripts can iterate over the contents of a matrix in several different ways. Unlike arrays, matrices use _two_ indices to reference their elements because they store data in a _rectangular_ format. The first index refers to _rows_, and the second refers to _columns_. If a programmer opts to use for or while loops to iterate through matrices instead of using for…in, they must carefully define the loop boundaries or conditions to avoid out-of-bounds errors.\n\nThis code block shows a for loop that performs _row-wise_ iteration, looping through each _row index_ in a matrix and using the value in a matrix.row() call to retrieve a row array. If the matrix is empty, the loop statement uses a final loop counter value of na to _prevent_ iteration. Otherwise, the final counter is the last row index, which is _one less_ than the value returned by matrix.rows():\n\nPine Script®\nCopied\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\n    rowArray = myMatrix.row(rowIndex)\n\nNote that:\n\n- If we replace the matrix.rows() and matrix.row() calls with matrix.columns() and matrix.col(), the loop performs _column-wise_ iteration instead.\n\nThe for…in loop statement is the more convenient approach to loop over and access the rows of a matrix in order, as it automatically validates the number of rows and retrieves an array of the current row’s elements on each iteration:\n\nPine Script®\nCopied\n\nfor rowArray in myMatrix\n\nWhen a script’s calculations require access to each row from a matrix and its corresponding _index_, programmers can use the second form of the for…in loop:\n\nPine Script®\nCopied\n\nfor [rowIndex, rowArray] in myMatrix\n\nNote that:\n\n- The for…in loop only performs row-wise iteration on matrices. To _emulate_ column-wise iteration, programmers can use a for…in loop on a transposed copy.\n\nThe following example creates a custom string representing the rows of a matrix with extra information. When the script executes on the last historical bar, it creates a 3x3 matrix populated with values from math.random() calls. Using the first form of the for…in loop, the script iterates through each row in the matrix to create a “string” value representing the row’s contents, its average, and whether the average is above 0.5. Before the end of each iteration, the script concatenates the constructed string with the labelText value. After the loop ends, the script creates a label to display the labelText variable’s final value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for row in matrix demo\", \"Custom matrix label\")\n//@variable Generates a random value between 0 and 1, rounded to 4 decimal places.\nrand() =>\n    math.round(math.random(), 4)\nif barstate.islastconfirmedhistory\n    //@variable A matrix of randomized values to format and display in a label.\n    matrix<float> randomMatrix = matrix.new<float>()\n    // Add a row of 9 randomized values and reshape the matrix to 3x3.\n    randomMatrix.add_row(\n         0, array.from(rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand())\n     )\n    randomMatrix.reshape(3, 3)\n    //@variable A custom \"string\" representation of randomMatrix information. Modified within a loop.\n    string labelText = \"Matrix rows: \\n\"\n    // Loop through the rows in the randomMatrix.\n    for row in randomMatrix\n        //@variable The average element value within the row.\n        float rowAvg = row.avg()\n        //@variable An upward arrow when the rowAvg is above 0.5, a downward arrow otherwise.\n        string directionChar = rowAvg > 0.5 ? \"⬆\" : \"⬇\"\n        // Add a \"string\" representing the row array, its average, and the directionChar to the labelText.\n        labelText += str.format(\"Row: {0} Avg: {1} {2}\\n\", row, rowAvg, directionChar)\n\n    // Draw a label displaying the labelText on the current bar.\n    label.new(\n         bar_index, 0, labelText, color = color.purple, textcolor = color.white, size = size.huge,\n         style = label.style_label_center, textalign = text.align_left\n     )\n\nWorking with matrices often entails iteratively accessing their _elements_, not just their rows and columns, typically using _nested loops_. For example, this code block uses an outer for loop to iterate over row indices. The inner for loop iterates over column indices on _each_ outer loop iteration and calls matrix.get() to access an element:\n\nPine Script®\nCopied\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\n    for columnIndex = 0 to myMatrix.columns() - 1\n        element = myMatrix.get(rowIndex, columnIndex)\n\nAlternatively, a more convenient approach for this type of task is to use nested for…in loops. The outer for…in loop in this code block retrieves each row array in a matrix, and the inner for…in statement loops through that array:\n\nPine Script®\nCopied\n\nfor rowArray in myMatrix\n    for element in rowArray\n\nThe script below creates a 3x2 matrix, then accesses and modifies its elements within nested for…in loops. Both loops use the second form of the for…in statement to retrieve index values and corresponding items. The outer loop accesses a row index and row array from the matrix. The inner loop accesses each index and respective element from that array.\n\nWithin the nested loop’s iterations, the script converts each element to a “string” and initializes a table cell at the rowIndex row and colIndex column. Then, it uses the loop header variables within matrix.set() to update the matrix element. After the outer loop terminates, the script displays a “string” representation of the _updated_ matrix within a label:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Nested for...in loops on matrices demo\")\nif barstate.islastconfirmedhistory\n    //@variable  A matrix containing numbers to display.\n    matrix<float> displayNumbers = matrix.new<float>()\n    // Populate the displayNumbers matrix and reshape to 3x2.\n    displayNumbers.add_row(0, array.from(1, 2, 3, 4, 5, 6))\n    displayNumbers.reshape(3, 2)\n    //@variable A table that displays the elements of the displayNumbers before modification.\n    table displayTable = table.new(\n         position = position.middle_center, columns = displayNumbers.columns(), rows = displayNumbers.rows(),\n         bgcolor = color.purple, border_color = color.white, border_width = 2\n     )\n    // Loop through the displayNumbers, retrieving the rowIndex and the current row.\n    for [rowIndex, row] in displayNumbers\n        // Loop through the current row on each outer loop iteration to retrieve the colIndex and element.\n        for [colIndex, element] in row\n            // Initialize a table cell at the rowIndex row and colIndex column displaying the current element.\n            displayTable.cell(column = colIndex, row = rowIndex, text = str.tostring(element),\n                 text_color = color.white, text_size = size.huge\n             )\n            // Update the displayNumbers value at the rowIndex and colIndex.\n            displayNumbers.set(rowIndex, colIndex, math.round(math.exp(element), 3))\n    // Draw a label to display a \"string\" representation of the updated displayNumbers matrix.\n    label.new(\n         x = bar_index, y = 0, text = \"Matrix now modified: \\n\" + str.tostring(displayNumbers), color = color.orange,\n         textcolor = color.white, size = size.huge, style = label.style_label_up\n     )\n\nLooping through maps\n\nThe for…in loop statement is the primary, most convenient approach for iterating over the data within Pine Script maps.\n\nUnlike arrays and matrices, maps are _unordered collections_ that store data in _key-value pairs_. Rather than traversing an internal lookup index, a script references the _keys_ from the pairs within a map to access its _values_. Therefore, when looping through a map, scripts must perform _pair-wise_ iteration, which entails retrieving key-value pairs across iterations rather than indexed elements or rows.\n\nNote that:\n\n- Although maps are unordered collections, Pine Script internally tracks the _insertion order_ of their key-value pairs.\n\nOne way to access the data from a map is to use the map.keys() function, which returns an array containing all the _keys_ from the map, sorted in their insertion order. A script can use the for…in structure to loop through the array of keys and call map.get() to retrieve corresponding values:\n\nPine Script®\nCopied\n\nfor key in myMap.keys()\n    value = myMap.get(key)\n\nHowever, the more convenient, _recommended_ approach is to loop through a map directly _without_ creating new arrays. To loop through a map directly, use the second form of the for…in loop statement. Using this loop with a map creates a tuple containing a _key_ and respective _value_ on each iteration. As when looping through a map.keys() array, this _direct_ for…in loop iterates through a map’s contents in their insertion order:\n\nPine Script®\nCopied\n\nfor [key, value] in myMap\n\nNote that:\n\n- The second form of the for…in loop is the only way to iterate _directly_ through a map. A script cannot directly loop through this collection type without retrieving a key and value on each iteration.\n\nLet’s consider a simple example demonstrating how a for…in loop works on a map. When the script below executes on the last historical bar, it declares a simpleMap variable to reference a map of “string” keys and “float” values. The script uses map.put() to insert the keys from the newKeys array into the collection with corresponding values from math.random() calls. Then, it uses a for…in loop to iterate through the key-value pairs from the map and construct the displayText string. After the loop ends, the script uses a label to visualize the string:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Looping through map demo\")\nif barstate.islastconfirmedhistory\n    //@variable A map of \"string\" keys and \"float\" values to render within a label.\n    map<string, float> simpleMap = map.new<string, float>()\n    //@variable An array of \"string\" values representing the keys to put into the map.\n    array<string> newKeys = array.from(\"A\", \"B\", \"C\", \"D\", \"E\")\n    // Put key-value pairs into the simpleMap.\n    for key in newKeys\n        simpleMap.put(key, math.random(1, 20))\n    //@variable A \"string\" representation of the simpleMap contents. Modified within a loop.\n    string displayText = \"simpleMap content: \\n \"\n    // Loop through each key-value pair within the simpleMap.\n    for [key, value] in simpleMap\n        // Add a \"string\" representation of the pair to the displayText.\n        displayText += key + \": \" + str.tostring(value, \".\") + \"\\n \"\n\n    // Draw a label showing the displayText on the current bar.\n    label.new(\n         x = bar_index, y = 0, text = displayText, color = color.green, textcolor = color.white,\n         size = size.huge, textalign = text.align_left, style = label.style_label_center\n     )\n\nNote that:\n\n- This script uses both forms of the for…in loop statement. The first loop iterates through the “string” elements of the newKeys array to put key-value pairs into the map referenced by simpleMap`, and the second iterates directly through the map’s key-value pairs to construct the custom string.\n\nPrevious\\\\\nConditional structures Next\\\\\nBuilt-ins",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression"
    ]
  },
  "c9937776": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Variable declarations\n\nIntroduction\n\nVariables are identifiers that hold values. They must be _declared_ in your code\nbefore you use them. The syntax of variable declarations is:\n\n``\n\n[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n`\n\nor\n\n`\n\n<tuple_declaration> = <function_call> | <structure>\n`\n\nwhere:\n\n- | means OR, and parts enclosed in square brackets ( []) can\nappear zero or one time.\n- <declaration\\_mode> is the variable’s\ndeclaration mode. It can be\nvar\nor\nvarip,\nor nothing.\n- <type> is a valid _type keyword_ with an optional _qualifier prefix_. Specifying a variable’s type is optional in most cases. See the Type system page to learn more.\n- <identifier> is the variable’s\nname.\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <structure> can be an\nif,\nfor,\nwhile\nor\nswitch _structure_.\n- <tuple\\_declaration> is a comma-separated list of variable names\nenclosed in square brackets ( []), e.g.,\n[ma, upperBand, lowerBand].\n\nThese are all valid variable declarations. Note that the last declaration requires four\nlines of code because it uses the returned value from an if statement:\n\nPine Script®\nCopied\n\nBULL_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round_to_mintick(close)\nsma = ta.sma(close, 14)\nvar barRange = float(na)\nvar firstBarOpen = open\nvarip float lastClose = na\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\n    color.green\nelse\n    color.red\n\nThe formal syntax of a variable declaration is:\n\n`\n\n<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum\n`\n\nInitialization with ​ na ​\n\nIn most cases, an explicit type declaration is redundant because type is\nautomatically inferred from the value on the right of the = at compile\ntime, so the decision to use them is often a matter of preference. For\nexample:\n\nPine Script®\nCopied\n\nbaseLine0 = na          // compile time error!\nfloat baseLine1 = na    // OK\nbaseLine2 = float(na)   // OK\n\nIn the first line of the example, the compiler cannot determine the type\nof the baseLine0 variable because\nna is a\ngeneric value of no particular type. The declaration of the baseLine1\nvariable is correct because its\nfloat\ntype is declared explicitly. The declaration of the baseLine2 variable\nis also correct because its type can be derived from the expression\nfloat(na), which is an explicit cast of the\nna value\nto the\nfloat\ntype. The declarations of baseLine1 and baseLine2 are equivalent.\n\nTuple declarations\n\nFunction calls or structures are allowed to return multiple values. When\nwe call them and want to store the values they return, a _tuple_\n_declaration_ must be used, which is a comma-separated set of one or more\nvalues enclosed in brackets. This allows us to declare multiple\nvariables simultaneously. As an example, the\nta.bb()\nbuilt-in function for Bollinger bands returns three values:\n\nPine Script®\nCopied\n\n[bbMiddle, bbUpper, bbLower] = ta.bb(close, 5, 4)\n\nUsing an underscore (​ _ ​) as an identifier\n\nWhen declaring a variable, it is possible to use a single underscore ( _) as its identifier. A value assigned to such a variable cannot be accessed. You can assign any number of values to a _ identifier anywhere in the script, even if the current scope already has such an assignment.\n\nThis is particularly useful when a tuple returns unneeded values. Let’s write another Bollinger Bands script. Here, we only need the bands themselves, without the center line:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Underscore demo\")\n// We do not need the middle Bollinger Bands value, and do not use it.\n// To make this clear, we assign it to the _ identifier.\n[_, bbUpper, bbLower] = ta.bb(close, 5, 4)\n// We can continue to use _ in the same code without causing compilation errors:\n[bbMiddleLong, _, _] = ta.bb(close, 20, 2)\nplot(bbUpper)\n\nVariable reassignment\n\nA variable reassignment is done using the\n:=\nreassignment operator. It can only be done after a variable has been\nfirst declared and given an initial value. Reassigning a new value to a\nvariable is often necessary in calculations, and it is always necessary\nwhen a variable from the global scope must be assigned a new value from\nwithin a structure’s local block, e.g.:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"\", \"\", true)\nsensitivityInput = input.int(2, \"Sensitivity\", minval = 1, tooltip = \"Higher values make color changes less sensitive.\")\nma = ta.sma(close, 20)\nmaUp = ta.rising(ma, sensitivityInput)\nmaDn = ta.falling(ma, sensitivityInput)\n// On first bar only, initialize color to gray\nvar maColor = color.gray\nif maUp\n    // MA has risen for two bars in a row; make it lime.\n    maColor := color.lime\nelse if maDn\n    // MA has fallen for two bars in a row; make it fuchsia.\n    maColor := color.fuchsia\nplot(ma, \"MA\", maColor, 2)\n\nNote that:\n\n- We initialize maColor on the first bar only, so it preserves its\nvalue across bars.\n- On every bar, the\nif\nstatement checks if the MA has been rising or falling for the\nuser-specified number of bars (the default is 2). When that happens,\nthe value of maColor must be reassigned a new value from within\nthe\nif\nlocal blocks. To do this, we use the\n:= reassignment operator.\n- If we did not use the\n:= reassignment operator, the effect would be to initialize\na new maColor local variable which would have the same name as\nthat of the global scope, but actually be a very confusing\nindependent entity that would persist only for the length of the\nlocal block, and then disappear without a trace.\n\nAll user-defined variables in Pine Script are _mutable_, which means\ntheir value can be changed using the\n:=\nreassignment operator. Assigning a new value to a variable may change\nits _type qualifier_ (see the page on Pine Script’s\ntype system for more\ninformation). A variable can be assigned a new value as many times as\nneeded during the script’s execution on one bar, so a script can\ncontain any number of reassignments of one variable. A variable’s\ndeclaration mode determines how new values assigned to a variable will be\nsaved.\n\nDeclaration modes\n\nUnderstanding the impact that declaration modes have on the behavior of\nvariables requires prior knowledge of Pine Script’s\nexecution model.\n\nWhen you declare a variable, if a declaration mode is specified, it must\ncome first. Three modes can be used:\n\n- “On each bar”, when none is specified\n- var\n- varip\n\nOn each bar\n\nWhen no explicit declaration mode is specified, i.e. no\nvar or\nvarip\nkeyword is used, the variable is declared and initialized on each bar,\ne.g., the following declarations from our first set of examples in this\npage’s introduction:\n\nPine Script®\nCopied\n\nBULL_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round_to_mintick(close)\nst = ta.supertrend(4, 14)\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\n    color.green\nelse\n    color.red\n\n​ var ​\n\nWhen the\nvar\nkeyword is used, the variable is only initialized once, on the first bar\nif the declaration is in the global scope, or the first time the local\nblock is executed if the declaration is inside a local block. After\nthat, it will preserve its last value on successive bars, until we\nreassign a new value to it. This behavior is very useful in many cases\nwhere a variable’s value must persist through the iterations of a\nscript across successive bars. For example, suppose we’d like to count\nthe number of green bars on the chart:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Green Bars Count\")\nvar count = 0\nisGreen = close >= open\nif isGreen\n    count := count + 1\nplot(count)\n\nWithout the var modifier, variable count would be reset to zero\n(thus losing its value) every time a new bar update triggered a script\nrecalculation.\n\nDeclaring variables on the first bar only is often useful to manage\ndrawings more efficiently. Suppose we want to extend the last bar’s\nclose\nline to the right of the right chart. We could write:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Inefficient version\", \"\", true)\ncloseLine = line.new(bar_index - 1, close, bar_index, close, extend = extend.right, width = 3)\nline.delete(closeLine[1])\n\nbut this is inefficient because we are creating and deleting the line on\neach historical bar and on each update in the realtime bar. It is more\nefficient to use:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Efficient version\", \"\", true)\nvar closeLine = line.new(bar_index - 1, close, bar_index, close, extend = extend.right, width = 3)\nif barstate.islast\n    line.set_xy1(closeLine, bar_index - 1, close)\n    line.set_xy2(closeLine, bar_index, close)\n\nNote that:\n\n- We initialize closeLine on the first bar only, using the\nvar\ndeclaration mode\n- We restrict the execution of the rest of our code to the chart’s\nlast bar by enclosing our code that updates the line in an\nif barstate.islast\nstructure.\n\nThere is a very slight penalty performance for using the\nvar\ndeclaration mode. For that reason, when declaring constants, it is\npreferable not to use\nvar if\nperformance is a concern, unless the initialization involves\ncalculations that take longer than the maintenance penalty, e.g.,\nfunctions with complex code or string manipulations.\n\n​ varip ​\n\nUnderstanding the behavior of variables using the\nvarip\ndeclaration mode requires prior knowledge of Pine Script’s\nexecution model and\nbar states.\n\nThe\nvarip\nkeyword can be used to declare variables that escape the _rollback_\n_process_, which is explained in the page on Pine Script’s\nexecution model.\n\nWhereas scripts only execute once at the close of historical bars, when\na script is running in realtime, it executes every time the chart’s\nfeed detects a price or volume update. At every realtime update, Pine\nScript’s runtime normally resets the values of a script’s variables\nto their last committed value, i.e., the value they held when the\nprevious bar closed. This is generally handy, as each realtime script\nexecution starts from a known state, which simplifies script logic.\n\nSometimes, however, script logic requires code to be able to save\nvariable values between different executions in the realtime bar.\nDeclaring variables with\nvarip\nmakes that possible. The “ip” in\nvarip\nstands for _intrabar persist_.\n\nLet’s look at the following code, which does not use\nvarip:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"\")\nint updateNo = na\nif barstate.isnew\n    updateNo := 1\nelse\n    updateNo := updateNo + 1\nplot(updateNo, style = plot.style_circles)\n\nOn historical bars,\nbarstate.isnew\nis always true, so the plot shows a value of “1” because the else\npart of the\nif\nstructure is never executed. On realtime bars,\nbarstate.isnew\nis only\ntrue\nwhen the script first executes on the bar’s “open”. The plot will\nthen briefly display “1” until subsequent executions occur. On the\nnext executions during the realtime bar, the second branch of the\nif\nstatement is executed because\nbarstate.isnew\nis no longer true. Since updateNo is initialized to\nna at\neach execution, the updateNo + 1 expression yields\nna, so\nnothing is plotted on further realtime executions of the script.\n\nIf we now use\nvarip\nto declare the updateNo variable, the script behaves very differently:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"\")\nvarip int updateNo = na\nif barstate.isnew\n    updateNo := 1\nelse\n    updateNo := updateNo + 1\nplot(updateNo, style = plot.style_circles)\n\nThe difference now is that updateNo tracks the number of realtime\nupdates that occur on each realtime bar. This can happen because the\nvarip\ndeclaration allows the value of updateNo` to be preserved between\nrealtime updates; it is no longer rolled back at each realtime execution\nof the script. The test on\nbarstate.isnew\nallows us to reset the update count when a new realtime bar comes in.\n\nBecause\nvarip\nonly affects the behavior of your code in the realtime bar, it follows\nthat backtest results on strategies designed using logic based on\nvarip\nvariables will not be able to reproduce that behavior on historical\nbars, which will invalidate test results on them. This also entails that\nplots on historical bars will not be able to reproduce the script’s\nbehavior in realtime.\n\nPrevious\\\\\nIdentifiers Next\\\\\nOperators",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>",
      "<tuple_declaration> = <function_call> | <structure>",
      "<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum"
    ]
  },
  "2cd6ab48": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Operators\n\nIntroduction\n\nSome operators are used to build _expressions_ returning a result:\n\n- Arithmetic operators\n- Comparison operators\n- Logical operators\n- The\n?:\nternary operator\n- The\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nhistory-referencing operator\n\nOther operators are used to assign values to variables:\n\n- = is used to assign a value to a variable, but only when you\ndeclare the variable (the first time you use it)\n- := is used to assign a value to a previously declared\nvariable. The following operators can also be used in such a way:\n+=, -=, *=, /=, %=\n\nAs is explained in the Type system page, _qualifiers_ and _types_ play a critical role in\ndetermining the type of results that expressions yield. This, in turn,\nhas an impact on how and with what functions you will be allowed to use\nthose results. Expressions always return a value with the strongest\nqualifier used in the expression, e.g., if you multiply an “input int”\nwith a “series int”, the expression will produce a “series int”\nresult, which you will not be able to use as the argument to length in\nta.ema().\n\nThis script will produce a compilation error:\n\n//@version=6\nindicator(\"\")\nlenInput = input.int(14, \"Length\")\nfactor = year > 2020 ? 3 : 1\nadjustedLength = lenInput \\* factor\nma = ta.ema(close, adjustedLength) // Compilation error!\nplot(ma)\n\nThe compiler will complain: _Cannot call ‘ta.ema’ with argument_\n_‘length’=‘adjustedLength’. An argument of ‘series int’ type was_\n_used but a ‘simple int’ is expected;_. This is happening because\nlenInput is an “input int” but factor is a “series int” (it can\nonly be determined by looking at the value of\nyear\non each bar). The adjustedLength variable is thus assigned a “series\nint” value. Our problem is that the Reference Manual entry for\nta.ema()\ntells us that its length parameter requires a “simple” value, which\nis a weaker qualifier than “series”, so a “series int” value is not\nallowed.\n\nThe solution to our conundrum requires:\n\n- Using another moving average function that supports a “series int”\nlength, such as\nta.sma(),\nor\n- Not using a calculation producing a “series int” value for our\nlength.\n\nArithmetic operators\n\nThere are five arithmetic operators in Pine Script®:\n\n| Operator | Meaning |\n| --- | --- |\n| + | Addition and string concatenation |\n| - | Subtraction |\n| * | Multiplication |\n| / | Division |\n| % | Modulo (remainder after division) |\n\nThe arithmetic operators above are all _binary_, meaning they need two _operands_ — or values — to work on, as in the example operation 1 + 2. The + and - can also be _unary_ operators, which means they work on one operand, as in the example values -1 or +1.\n\nIf both operands are numbers but at least one of these is of\nfloat\ntype, the result will also be a\nfloat.\nIf both operands are of\nint\ntype, the result will also be an\nint.\nIf at least one operand is\nna, the\nresult is also\nna.\n\nNote that when using the division operator with “int” operands, if the two “int” values are not evenly divisible, the result of the division is always a number with a fractional value, e.g., 5/2 = 2.5. To discard the fractional remainder, wrap the division with the int() function, or round the result using math.round(), math.floor(), or math.ceil().\n\nThe + operator also serves as the concatenation operator for strings.\n\"EUR\"+\"USD\" yields the \"EURUSD\" string.\n\nThe % operator calculates the modulo by rounding down the quotient to\nthe lowest possible value. Here is an easy example that helps illustrate\nhow the modulo is calculated behind the scenes:\n\n//@version=6\nindicator(\"Modulo function\")\nmodulo(series int a, series int b) =>\na - b \\* math.floor(nz(a/b))\nplot(modulo(-1, 100))\n\nComparison operators\n\nThere are six comparison operators in Pine Script:\n\n| Operator | Meaning |\n| --- | --- |\n| < | Less Than |\n| <= | Less Than or Equal To |\n| != | Not Equal |\n| == | Equal |\n| > | Greater Than |\n| >= | Greater Than or Equal To |\n\nComparison operations are binary, and return a result of type “bool”, i.e., true or false. The == equal and != not equal operators can work with operands of any fundamental type, such as colors and strings, while the other comparison operators are only applicable to numerical values. Therefore, \"a\" != \"b\" is a valid comparison, but \"a\" > \"b\" is invalid.\n\nExamples:\n\n1 > 2 // false\n1 != 1 // false\nclose >= open // Depends on values of \\close\\ and \\open\\\n\nLogical operators\n\nThere are three logical operators in Pine Script:\n\n| Operator | Meaning |\n| --- | --- |\n| not | Negation |\n| and | Logical Conjunction |\n| or | Logical Disjunction |\n\nThe operator not is unary. When applied to a true, operand the\nresult will be false, and vice versa.\n\nand operator truth table:\n\n| a | b | a and b |\n| --- | --- | --- |\n| true | true | true |\n| true | false | false |\n| false | true | false |\n| false | false | false |\n\nor operator truth table:\n\n| a | b | a or b |\n| --- | --- | --- |\n| true | true | true |\n| true | false | true |\n| false | true | true |\n| false | false | false |\n\n​ ?: ​ ternary operator\n\nThe\n?:\nternary operator is used to create expressions of the form:\n\ncondition ? valueWhenConditionIsTrue : valueWhenConditionIsFalse\n\nThe ternary operator returns a result that depends on the value of condition. If it is true, then it returns valueWhenConditionIsTrue. Otherwise, if condition is false, then it returns valueWhenConditionIsFalse.\n\nA combination of ternary expressions can be used to achieve the same\neffect as a\nswitch\nstructure, e.g.:\n\ntimeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.ismonthly ? color.blue : na\n\nThe example is calculated from left to right:\n\n- If\ntimeframe.isintraday\nis true, then color.red is returned. If it is false, then\ntimeframe.isdaily\nis evaluated.\n- If\ntimeframe.isdaily\nis true, then color.green is returned. If it is false, then\ntimeframe.ismonthly\nis evaluated.\n- If\ntimeframe.ismonthly\nis true, then color.blue is returned, otherwise\nna\nis returned.\n\nNote that the return values on each side of the : are expressions ---\nnot local blocks, so they will not affect the limit of 500 local blocks\nper scope.\n\n[​ [] ​ history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/\\-history-referencing-operator)\n\nIt is possible to refer to past values of\ntime series using the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nhistory-referencing operator. Past values are values a variable had on\nbars preceding the bar where the script is currently executing — the\n_current bar_. See the\nExecution model\npage for more information about the way scripts are executed on bars.\n\nThe\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator is used after a variable, expression or function call. The\nvalue used inside the square brackets of the operator is the offset in\nthe past we want to refer to. To refer to the value of the\nvolume\nbuilt-in variable two bars away from the current bar, one would use\nvolume[2].\n\nBecause series grow dynamically, as the script calculates on successive bars, a constant historical offset refers to different bars. Let’s see how the value returned by the same offset is dynamic, and why series are very different from arrays. In Pine Script, the\nclose\nvariable, or close[0] which is equivalent, holds the value of the\ncurrent bar’s “close”. If your code is now executing on the third\nbar of the _dataset_ (the set of all bars on your chart), close will\ncontain the price at the close of that bar, close[1] will contain the\nprice at the close of the preceding bar (the dataset’s second bar), and\nclose[2], the first bar. close[3] will return\nna\nbecause no bar exists in that position, and thus its value is _not_\n_available_.\n\nWhen the same code is executed on the next bar, the fourth in the\ndataset, close will now contain the closing price of that bar, and the\nsame close[1] used in your code will now refer to the “close” of the\nthird bar in the dataset. The close of the first bar in the dataset will\nnow be close[3], and this time close[4] will return\nna.\n\nIn the Pine Script runtime environment, as your code is executed once\nfor each historical bar in the dataset, starting from the left of the\nchart, Pine Script is adding a new element in the series at index 0 and\npushing the pre-existing elements in the series one index further away.\nArrays, in comparison, can have constant or variable sizes, and their\ncontent or indexing structure is not modified by the runtime\nenvironment. Pine Script series are thus very different from arrays and\nonly share familiarity with them through their indexing syntax.\n\nWhen the market for the chart’s symbol is open and the script is\nexecuting on the chart’s last bar, the _realtime bar_,\nclose\nreturns the value of the current price. It will only contain the actual\nclosing price of the realtime bar the last time the script is executed\non that bar, when it closes.\n\nPine Script has a variable that contains the number of the bar the\nscript is executing on:\nbar\\_index.\nOn the first bar,\nbar\\_index\nis equal to 0 and it increases by 1 on each successive bar the script\nexecutes on. On the last bar,\nbar\\_index\nis equal to the number of bars in the dataset minus one.\n\nThere is another important consideration to keep in mind when using the\n[] operator in Pine Script. We have seen cases when a history\nreference may return the\nna\nvalue.\nna\nrepresents a value which is not a number and using it in any expression\nwill produce a result that is also\nna\n(similar to NaN). Such cases often\nhappen during the script’s calculations in the early bars of the\ndataset, but can also occur in later bars under certain conditions.\nIf your code does not explicitly handle these special cases using the na() and nz() functions, na values can introduce invalid results in your script’s calculations that can affect calculations all the way to the realtime bar.\n\nThese are all valid uses of the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator:\n\nhigh\\[10\\]\nta.sma(close, 10)\\[1\\]\nta.highest(high, 10)\\[20\\]\nclose > nz(close\\[1\\], open)\n\nNote that the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator can only be used once on the same value. This is not allowed:\n\nclose\\[1\\]\\[2\\] // Error: incorrect use of \\[\\] operator\n\nOperator precedence\n\nThe order of calculations is determined by the operators’ precedence.\nOperators with greater precedence are calculated first. Below is a list\nof operators sorted by decreasing precedence:\n\n| Precedence | Operator |\n| --- | --- |\n| 9 | [] |\n| 8 | unary +, unary -, not |\n| 7 | *, /, % |\n| 6 | +, - |\n| 5 | >, <, >=, <= |\n| 4 | ==, != |\n| 3 | and |\n| 2 | or |\n| 1 | ?: |\n\nIf in one expression there are several operators with the same\nprecedence, then they are calculated left to right.\n\nIf the expression must be calculated in a different order than\nprecedence would dictate, then parts of the expression can be grouped\ntogether with parentheses.\n\n​ = ​ assignment operator\n\nThe = operator assigns an initial value or reference to a declared variable. It means _this is a new variable, and it starts with this value_.\n\nThese are all valid variable declarations:\n\ni = 1\nMS\\_IN\\_ONE\\_MINUTE = 1000 \\* 60\nshowPlotInput = input.bool(true, \"Show plots\")\npHi = ta.pivothigh(5, 5)\nplotColor = color.green\n\nSee the\nVariable declarations page for more information on how to declare variables.\n\n​ := ​ reassignment operator\n\nThe := is used to _reassign_ a value to an existing variable. It says\n_use this variable that was declared earlier in my script, and give it a_\n_new value_.\n\nVariables which have been first declared, then reassigned using :=,\nare called _mutable_ variables. All the following examples are valid\nvariable reassignments. You will find more information on how\nvar\nworks in the section on the\n\\var\\ declaration mode:\n\n//@version=6\nindicator(\"\", \"\", true)\n// Declare \\pHi\\ and initilize it on the first bar only.\nvar float pHi = na\n// Reassign a value to \\pHi\\\npHi := nz(ta.pivothigh(5, 5), pHi)\nplot(pHi)\n\nNote that:\n\n- We declare pHi with this code: var float pHi = na. The\nvar\nkeyword tells Pine Script that we only want that variable\ninitialized with\nna\non the dataset’s first bar. The float keyword tells the compiler\nwe are declaring a variable of type “float”. This is necessary\nbecause, contrary to most cases, the compiler cannot automatically\ndetermine the type of the value on the right side of the = sign.\n- While the variable declaration will only be executed on the first\nbar because it uses\nvar,\nthe pHi := nz(ta.pivothigh(5, 5), pHi) line will be executed on\nall the chart’s bars. On each bar, it evaluates if the\nta.pivothigh()\ncall returns\nna\nbecause that is what the function does when it hasn’t found a new\npivot. The\nnz()\nfunction is the one doing the “checking for\nna”\npart. When its first argument ( ta.pivothigh(5, 5)) is\nna,\nit returns the second argument ( pHi) instead of the first. When\nta.pivothigh()\nreturns the price point of a newly found pivot, that value is\nassigned to pHi. When it returns\nna\nbecause no new pivot was found, we assign the previous value of\npHi to itself, in effect preserving its previous value.\n\nThe output of our script looks like this:\n\nNote that:\n\n- The line preserves its previous value until a new pivot is found.\n- Pivots are detected five bars after the pivot actually occurs\nbecause our ta.pivothigh(5, 5) call says that we require five\nlower highs on both sides of a high point for it to be detected as a\npivot.\n\nSee the\nVariable reassignment section for more information on how to reassign values to\nvariables.\n\nPrevious\\\\\nVariable declarations Next\\\\\nConditional structures",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": []
  },
  "274c0849": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Conditional structures\n\nIntroduction\n\nThe conditional structures in Pine Script® are\nif and\nswitch.\nThey can be used:\n\n- For their side effects, i.e., when they don’t return a value but do\nthings, like reassign values to variables or call functions.\n- To return a value or a tuple which can then be assigned to one (or\nmore, in the case of tuples) variable.\n\nConditional structures, like the\nfor and\nwhile\nstructures, can be embedded; you can use an\nif or\nswitch\ninside another structure.\n\nSome Pine Script built-in functions are not callable from within the\nlocal blocks of conditional structures, including barcolor(), bgcolor(), plot(), plotshape(), plotchar(), plotarrow(), plotcandle(), plotbar(), hline(), fill(), alertcondition(), indicator(), strategy(), and library().\n\nThis restriction does not entail their functionality cannot be controlled by\nconditions evaluated by your script — only that it cannot be done by\nincluding them in conditional structures. Note that while input*.()\nfunction calls are allowed in local blocks, their functionality is the\nsame as if they were in the script’s _global scope_.\n\nThe local blocks in conditional structures must be indented by four\nspaces or a tab.\n\n​ if ​ structure\n\n​ if ​ used for its side effects\n\nAn if\nstructure used for its side effects has the following syntax:\n\n``\n\nif <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <expression> must be of “bool” type or be auto-castable to that\ntype, which is only possible for “int” or “float” values (see\nthe Type system page).\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- There can be zero or more else if clauses.\n- There can be zero or one else clause.\n\nWhen the <expression> following the\nif\nevaluates to\ntrue,\nthe first local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen the <expression> following the\nif\nevaluates to\nfalse,\nthe successive else if clauses are evaluated, if there are any. When\nthe <expression> of one evaluates to\ntrue,\nits local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to\ntrue\nand an else clause exists, its local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to true and no else clause exists, na is returned. The only exception to this is if the structure returns “bool” values — in that case, false is returned instead.\n\nUsing if\nstructures for their side effects can be useful to manage the order flow\nin strategies, for example. While the same functionality can often be\nachieved using the when parameter in strategy.*() calls, code using\nif\nstructures is easier to read:\n\nPine Script®\nCopied\n\nif (ta.crossover(source, lower))\n    strategy.entry(\"BBandLE\", strategy.long, stop=lower,\n                   oca_name=\"BollingerBands\",\n                   oca_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\n    strategy.cancel(id=\"BBandLE\")\n\nRestricting the execution of your code to specific bars ican be done\nusing if\nstructures, as we do here to restrict updates to our label to the\nchart’s last bar:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"\", \"\", true)\nvar ourLabel = label.new(bar_index, na, na, color = color(na), textcolor = color.orange)\nif barstate.islast\n    label.set_xy(ourLabel, bar_index + 2, hl2[1])\n    label.set_text(ourLabel, str.tostring(bar_index + 1, \"bars in chart\"))\n\nNote that:\n\n- We initialize the ourLabel variable on the script’s first bar\nonly, as we use the\nvar\ndeclaration mode. The value used to initialize the variable is\nprovided by the\nlabel.new()\nfunction call, which returns a label ID pointing to the label it\ncreates. We use that call to set the label’s properties because\nonce set, they will persist until we change them.\n- What happens next is that on each successive bar the Pine Script\nruntime will skip the initialization of ourLabel, and the\nif\nstructure’s condition\n( barstate.islast)\nis evaluated. It returns false on all bars until the last one, so\nthe script does nothing on most historical bars after bar zero.\n- On the last bar,\nbarstate.islast\nbecomes true and the structure’s local block executes, modifying on\neach chart update the properties of our label, which displays the\nnumber of bars in the dataset.\n- We want to display the label’s text without a background, so we\nmake the label’s background\nna\nin the\nlabel.new()\nfunction call, and we use hl2[1] for the label’s _y_ position\nbecause we don’t want it to move all the time. By using the average\nof the previous bar’s\nhigh\nand\nlow\nvalues, the label doesn’t move until the moment when the next\nrealtime bar opens.\n- We use bar_index + 2 in our\nlabel.set\\_xy()\ncall to offset the label to the right by two bars.\n\n​ if ​ used to return a value\n\nAn if\nstructure used to return one or more values has the following syntax:\n\n`\n\n[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed. If other local blocks return “bool” values, false will be returned instead.\n\nThis is an example:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"\", \"\", true)\nstring barState = if barstate.islastconfirmedhistory\n    \"islastconfirmedhistory\"\nelse if barstate.isnew\n    \"isnew\"\nelse if barstate.isrealtime\n    \"isrealtime\"\nelse\n    \"other\"\nf_print(_text) =>\n    var table _t = table.new(position.middle_right, 1, 1)\n    table.cell(_t, 0, 0, _text, bgcolor = color.yellow)\nf_print(barState)\n\nIt is possible to omit the _else_ block. In this case, if the\ncondition is false, an _empty_ value ( na, false, or \"\") will be\nassigned to the var_declarationX variable.\n\nThis is an example showing how\nna is\nreturned when no local block is executed. If close > open is false\nin here,\nna is\nreturned:\n\nPine Script®\nCopied\n\nx = if close > open\n    close\n\nScripts can contain if structures with nested if and other\nconditional structures. For example:\n\nPine Script®\nCopied\n\nif condition1\n    if condition2\n        if condition3\n            expression\n\nHowever, nesting these structures is not recommended from a performance\nperspective. When possible, it is typically more optimal to compose a\nsingle if statement with multiple logical operators rather than\nseveral nested if blocks:\n\nPine Script®\nCopied\n\nif condition1 and condition2 and condition3\n    expression\n\n​ switch ​ structure\n\nThe\nswitch\nstructure exists in two forms. One switches on the different values of a\nkey expression:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nThe other form does not use an expression as a key; it switches on the\nevaluation of different expressions:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed.\n- The => <local_block> at the end allows you to specify a return\nvalue which acts as a default to be used when no other case in the\nstructure is executed.\n\nOnly one local block of a\nswitch\nstructure is executed. It is thus a _structured switch_ that doesn’t\n_fall through_ cases. Consequently, break statements are unnecessary.\n\nBoth forms are allowed as the value used to initialize a variable.\n\nAs with the\nif\nstructure, if no local block is exectuted,\nthe expression returns either false (when other local blocks return a “bool” value) or na (in all other cases).\n\n​ switch ​ with an expression\n\nLet’s look at an example of a\nswitch\nusing an expression:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Switch using an expression\", \"\", true)\nstring maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\nint maLength = input.int(10, \"MA length\", minval = 2)\nfloat ma = switch maType\n    \"EMA\" => ta.ema(close, maLength)\n    \"SMA\" => ta.sma(close, maLength)\n    \"RMA\" => ta.rma(close, maLength)\n    \"WMA\" => ta.wma(close, maLength)\n    =>\n        runtime.error(\"No matching MA type found.\")\n        float(na)\nplot(ma)\n\nNote that:\n\n- The expression we are switching on is the variable maType, which\nis of “input int” type (see here for an explanation of what the\n“ input” qualifier is). Since it cannot change during the\nexecution of the script, this guarantees that whichever MA type the\nuser selects will be executing on each bar, which is a requirement\nfor functions like\nta.ema()\nwhich require a “simple int” argument for their length\nparameter.\n- If no matching value is found for maType, the\nswitch\nexecutes the last local block introduced by =>, which acts as a\ncatch-all. We generate a runtime error in that block. We also end it\nwith float(na) so the local block returns a value whose type is\ncompatible with that of the other local blocks in the structure, to\navoid a compilation error.\n\n​ switch ​ without an expression\n\nThis is an example of a\nswitch\nstructure which does not use an expression:\n\nPine Script®\nCopied\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\nbool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nswitch\n    longCondition  => strategy.entry(\"Long ID\", strategy.long)\n    shortCondition => strategy.entry(\"Short ID\", strategy.short)\n\nNote that:\n\n- We are using the\nswitch\nto select the appropriate strategy order to emit, depending on\nwhether the longCondition or shortCondition “bool” variables\nare true.\n- The building conditions of longCondition and shortCondition are\nexclusive. While they can both be false simultaneously, they\ncannot be true at the same time. The fact that only one local\nblock of the\nswitch\nstructure is ever executed is thus not an issue for us.\n- We evaluate the calls to\nta.crossover()\nand\nta.crossunder() prior to entry in the\nswitch\nstructure. Not doing so, as in the following example, would prevent\nthe functions to be executed on each bar, which would result in a\ncompiler warning and erratic behavior:\n\nPine Script®\nCopied\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\nswitch\n    // Compiler warning! Will not calculate correctly!\n    ta.crossover( ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Long ID\", strategy.long)\n    ta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Short ID\", strategy.short)\n\nMatching local block type requirement\n\nWhen multiple local blocks are used in structures, the type of the\nreturn value of all its local blocks must match. This applies only if\nthe structure is used to assign a value to a variable in a declaration,\nbecause a variable can only have one type, and if the statement returns\ntwo incompatible types in its branches, the variable type cannot be\nproperly determined. If the structure is not assigned anywhere, its\nbranches can return different values.\n\nThis code compiles fine because\nclose\nand\nopen\nare both of the float type:\n\nPine Script®\nCopied\n\nx = if close > open\n    close\nelse\n    open\n\nThis code does not compile because the first local block returns a\nfloat value, while the second one returns a string, and the result\nof the if-statement is assigned to the x variable:\n\nPine Script®\nCopied\n\n// Compilation error!\nx = if close > open\n    close\nelse\n    \"open\"\n`\n\nPrevious\\\\\nOperators Next\\\\\nLoops",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>"
    ]
  },
  "33019bbf": {
    "title": "PineScript Style Guide",
    "type": "style_guide",
    "content": "Type system\n\nIntroduction\n\nThe Pine Script® type system determines the compatibility of a script’s\nvalues with various functions and operations. While it’s possible to\nwrite simple scripts without knowing anything about the type system, a\nreasonable understanding of it is necessary to achieve any degree of\nproficiency with the language, and an in-depth knowledge of its\nsubtleties allows programmers to harness its full potential.\n\nPine Script uses types to classify all values, and it uses qualifiers to determine whether values and references are constant, established on the first script execution, or dynamic across executions. This system applies to all Pine values and references, including literals, variables, expressions, function returns, and function arguments.\n\nThe type system closely intertwines with Pine’s\nexecution model and\ntime series concepts.\nUnderstanding all three is essential for making the most of the power of\nPine Script.\n\nQualifiers\n\nPine Script _qualifiers_ identify when values are accessible to a\nscript:\n\n- Values and references qualified as\nconst are established at compile time (i.e., when saving the\nscript in the Pine Editor or adding it to the chart).\n- Values qualified as\ninput are established at input time (i.e., when confirming values\nbased on user input, primarily from the “Settings/Inputs” tab).\n- Values qualified as\nsimple are established at bar zero (i.e., the first\nscript execution).\n- Values qualified as\nseries can change throughout the script’s executions.\n\nPine Script bases the dominance of type qualifiers on the following\nhierarchy: const < input < simple < series, where “const” is\nthe _weakest_ qualifier and “series” is the _strongest_. The qualifier\nhierarchy translates to this rule: whenever a variable, function, or\noperation is compatible with a specific qualified type, values with\n_weaker_ qualifiers are also allowed.\n\nScripts always qualify their expressions’ returned types based on the\n_dominant qualifier_ in their calculations. For example, evaluating an\nexpression that involves “input” and “series” values will return a\nvalue qualified as “series”. Furthermore, scripts cannot change a\nvalue’s qualifier to one that’s _lower_ on the hierarchy. If a value\nacquires a _stronger_ qualifier (e.g., a value initially inferred as\n“simple” becomes “series” later in the script’s executions), that\nstate is irreversible.\n\nIt’s important to note that “series” values are the only ones\nthat can change across script executions, including those from various\nbuilt-ins, such as\nclose\nand\nvolume,\nas well as the results of expressions involving “series” values. All\nvalues qualified as “const”, “input”, or “simple” remain\nconsistent across all script executions.\n\nconst\n\nValues or references qualified as “const” are established at _compile_\n_time_, before the script starts its executions. Compilation initially\noccurs when saving a script in the Pine Editor, which does not require\nit to run on a chart. Values or references with the “const” qualifier\n_never change_ between script executions, not even on the first\nexecution.\n\nAll _literal_ values and the results returned by expressions involving\nonly values qualified as “const” automatically adopt the “const”\nqualifier.\n\nThese are some examples of literal values:\n\n- _literal int_: 1, -1, 42\n- _literal float_: 1., 1.0, 3.14, 6.02E-23, 3e8\n- _literal bool_: true, false\n- _literal color_: FF55C6, FF55C6ff\n- _literal string_: \"A text literal\",\n\"Embedded single quotes 'text'\", 'Embedded double quotes \"text\"'\n\nOur Style guide\nrecommends using uppercase SNAKE\\_CASE to name “const” variables for\nreadability. While not a requirement, one can also use the\nvar\nkeyword when declaring “const” variables so the script only\ninitializes them on the _first bar_ of the dataset. See\nthis section of our User Manual for more information.\n\nBelow is an example that uses “const” values within the\nindicator()\nand\nplot()\nfunctions, which both require a value of the “const string” qualified\ntype as their title argument:\n\nPine Script®\nCopied\n\n//@version=6\n// The following global variables are all of the \"const string\" qualified type:\n//@variable The title of the indicator.\nINDICATOR_TITLE = \"const demo\"\n//@variable The title of the first plot.\nvar PLOT1_TITLE = \"High\"\n//@variable The title of the second plot.\nconst string PLOT2_TITLE = \"Low\"\n//@variable The title of the third plot.\nPLOT3_TITLE = \"Midpoint between \" + PLOT1_TITLE + \" and \" + PLOT2_TITLE\nindicator(INDICATOR_TITLE, overlay = true)\nplot(high, PLOT1_TITLE)\nplot(low, PLOT2_TITLE)\nplot(hl2, PLOT3_TITLE)\n\nThe following example will raise a compilation error since it uses\nsyminfo.ticker,\nwhich returns a “simple” value because it depends on chart information\nthat’s only accessible after the script’s first execution:\n\nPine Script®\nCopied\n\n`//@version=6\n//@variable The title in the indicator() call.\nvar NAME = \"My indicator for \" + syminfo.ticker\nindicator(NAME, \"\", true) // Causes an error because NAME is qualified as a \"simple string\".\nplot(close)\n\nThe\nconst\nkeyword allows the declaration of variables and parameters with constant\n_value assignments_. Declaring a variable with this keyword instructs\nthe script to forbid using _reassignment_ and _compound assignment_\noperations on it. For example, this script declares the myVar variable\nwith the keyword, then attempts to assign a new “float” value to the\nvariable with the addition assignment operator\n( +=),\nresulting in a compilation error:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Cannot reassign const demo\")\n//@variable A \"float\" variable declared as const, preventing reassignment.\nconst float myVar = 0.0\nmyVar += 1.0 // Causes an error. Reassignment and compound assignments are not allowed on const variables.\nplot(myVar)\n\nIt’s crucial to note that declaring a variable with the\nconst\nkeyword forces it to maintain a constant reference to the value returned\nby a specific expression, but that _does not_ necessarily define the\nnature of the assigned value. For example, a script can declare a\nconst\nvariable that maintains a constant reference to an expression returning\nthe _ID_ of a _special type_. Although the script cannot _reassign_ the\nvariable, the assigned ID is a “series” value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Constant reference to 'series' ID demo\")\n//@variable A label variable declared as const, preventing reassignment.\n//          Although the reference is constant, the ID of the label is a \"series\" value.\nconst label myVar = label.new(bar_index, close)\n\ninput\n\nMost values qualified as “input” are established after initialization\nvia the input.*() functions. These functions produce values that users\ncan modify within the “Inputs” tab of the script’s settings. When one\nchanges any of the values in this tab, the script _restarts_ from the\nbeginning of the chart’s history to ensure its inputs are consistent\nthroughout its executions. Some of Pine’s built-in variables, such as\nchart.bg\\_color\nalso use the “input” qualifier, even though input.*() functions do\nnot return them, since the script receives their values at _input time_.\n\nThe following script plots the value of a sourceInput from the symbolInput and timeframeInput context. The request.security() call is valid in this script since its symbol and timeframe parameters allow “series string” arguments by default, meaning they can also accept “input string” values because the “input” qualifier is _lower_ on the hierarchy:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"input demo\", overlay = true)\n//@variable The symbol to request data from. Qualified as \"input string\".\nsymbolInput = input.symbol(\"AAPL\", \"Symbol\")\n//@variable The timeframe of the data request. Qualified as \"input string\".\ntimeframeInput = input.timeframe(\"D\", \"Timeframe\")\n//@variable The source of the calculation. Qualified as \"series float\".\nsourceInput = input.source(close, \"Source\")\n//@variable The sourceInput value from the requested context. Qualified as \"series float\".\nrequestedSource = request.security(symbolInput, timeframeInput, sourceInput)\nplot(requestedSource)\n\nsimple\n\nValues qualified as “simple” are available on the first script\nexecution, and they remain consistent across subsequent executions.\n\nUsers can explicitly define variables and parameters that accept\n“simple” values by including the simple keyword in their\ndeclaration.\n\nMany built-in variables return “simple” qualified values because they\ndepend on information that a script can only obtain once it starts\nrunning on the chart. Additionally, many built-in functions require\n“simple” arguments that do not change over time. Wherever a script\nallows “simple” values, it can also accept values qualified as\n“input” or “const”.\n\nThis script highlights the background to warn users that they’re using\na non-standard chart type. It uses the value of\nchart.is\\_standard\nto calculate the isNonStandard variable, then uses that variable’s\nvalue to calculate a warningColor that also references a “simple”\nvalue. The color parameter of\nbgcolor()\nallows a “series color” argument, meaning it can also accept a\n“simple color” value since “simple” is lower on the hierarchy:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"simple demo\", overlay = true)\n//@variable Is true when the current chart is non-standard. Qualified as \"simple bool\".\nisNonStandard = not chart.is_standard\n//@variable Is orange when the the current chart is non-standard. Qualified as \"simple color\".\nsimple color warningColor = isNonStandard ? color.new(color.orange, 70) : na\n// Colors the chart's background to warn that it's a non-standard chart type.\nbgcolor(warningColor, title = \"Non-standard chart color\")\n\nseries\n\nValues qualified as “series” provide the most flexibility in scripts\nsince they can change across executions.\n\nUsers can explicitly define variables and parameters that accept\n“series” values by including the series keyword in their\ndeclarations.\n\nBuilt-in variables such as\nopen,\nhigh,\nlow,\nclose,\nvolume,\ntime,\nand\nbar\\_index,\nand the result from any expression using such built-ins, are qualified\nas “series”. The result of any function or operation that returns a\ndynamic value will always be a “series”, as will the results from\nusing the history-referencing operator\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nto access historical values. Wherever a script allows “series” values,\nit will also accept values with any other qualifier, as “series” is\nthe _highest_ qualifier on the hierarchy.\n\nThis script displays the\nhighest\nand\nlowest\nvalue of a sourceInput over lengthInput bars. The values assigned to\nthe highest and lowest variables are of the “series float”\nqualified type, as they can change throughout the script’s execution:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"series demo\", overlay = true)\n//@variable The source value to calculate on. Qualified as \"series float\".\nseries float sourceInput = input.source(close, \"Source\")\n//@variable The number of bars in the calculation. Qualified as \"input int\".\nlengthInput = input.int(20, \"Length\")\n//@variable The highest sourceInput value over lengthInput bars. Qualified as \"series float\".\nseries float highest = ta.highest(sourceInput, lengthInput)\n//@variable The lowest sourceInput value over lengthInput bars. Qualified as \"series float\".\nlowest = ta.lowest(sourceInput, lengthInput)\nplot(highest, \"Highest source\", color.green)\nplot(lowest, \"Lowest source\", color.red)\n\nTypes\n\nPine Script _types_ classify values and determine the functions and\noperations they’re compatible with. They include:\n\n- The fundamental types:\nint,\nfloat,\nbool,\ncolor,\nand string\n- The special types:\nplot,\nhline,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nchart.point,\narray,\nmatrix, and\nmap\n- User-defined types (UDTs)\n- Enums\n- void\n\nFundamental types refer to the underlying nature of a value, e.g., a\nvalue of 1 is of the “int” type, 1.0 is of the “float” type,\n“AAPL” is of the “string” type, etc. Special types and user-defined\ntypes utilize _IDs_ that refer to objects of a specific type. For\nexample, a value of the “label” type contains an ID that acts as a\n_pointer_ referring to a “label” object. The “void” type refers to\nthe output from a function or method that does not return a usable value.\n\nPine Script can automatically convert values from some types into\nothers. The auto-casting rules are: int → float → bool. See the\nType casting section of this page for more information.\n\nIn most cases, Pine Script can automatically determine a value’s type.\nHowever, we can also use type keywords to _explicitly_ specify types for\nreadability and for code that requires explicit definitions (e.g.,\ndeclaring a variable assigned to\nna). For\nexample:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Types demo\", overlay = true)\n//@variable A value of the \"const string\" type for the ma plot's title.\nstring MA_TITLE = \"MA\"\n//@variable A value of the \"input int\" type. Controls the length of the average.\nint lengthInput = input.int(100, \"Length\", minval = 2)\n//@variable A \"series float\" value representing the last close that crossed over the ma.\nvar float crossValue = na\n//@variable A \"series float\" value representing the moving average of close.\nfloat ma = ta.sma(close, lengthInput)\n//@variable A \"series bool\" value that's true when the close crosses over the ma.\nbool crossUp = ta.crossover(close, ma)\n//@variable A \"series color\" value based on whether close is above or below its ma.\ncolor maColor = close > ma ? color.lime : color.fuchsia\n// Update the crossValue.\nif crossUp\n    crossValue := close\nplot(ma, MA_TITLE, maColor)\nplot(crossValue, \"Cross value\", style = plot.style_circles)\nplotchar(crossUp, \"Cross Up\", \"▲\", location.belowbar, size = size.small)\n\nint\n\nValues of the “int” type represent integers, i.e., whole numbers\nwithout any fractional quantities.\n\nInteger literals are numeric values written in _decimal_ notation. For\nexample:\n\nPine Script®\nCopied\n\n1\n-1\n750\n\nBuilt-in variables such as\nbar\\_index,\ntime,\ntimenow,\ndayofmonth,\nand\nstrategy.wintrades\nall return values of the “int” type.\n\nfloat\n\nValues of the “float” type represent floating-point numbers, i.e.,\nnumbers that can contain whole and fractional quantities.\n\nFloating-point literals are numeric values written with a . delimiter.\nThey may also contain the symbol e or E (which means “10 raised to\nthe power of X”, where X is the number after the e or E symbol).\nFor example:\n\nPine Script®\nCopied\n\n3.14159    // Rounded value of Pi (π)\n- 3.0\n6.02e23    // 6.02 * 10^23 (a very large value)\n1.6e-19    // 1.6 * 10^-19 (a very small value)\n\nThe internal precision of “float” values in Pine Script is 1e-16.\n\nBuilt-in variables such as\nclose,\nhlcc4,\nvolume,\nta.vwap,\nand\nstrategy.position\\_size\nall return values of the “float” type.\n\nbool\n\nValues of the “bool” type represent the truth value of a comparison or\ncondition, which scripts can use in\nconditional structures and other expressions.\n\nThere are only two literals that represent boolean values:\n\nPine Script®\nCopied\n\ntrue    // true value\nfalse   // false value\n\nA bool variable can never be na, and any conditional\\\\\nstructure that can return na will return false instead. For example, an if condition returns bool values, when the condition is not met and the else block is not specified, it will returns false.\n\nBuilt-in variables such as\nbarstate.isfirst,\nchart.is\\_heikinashi,\nsession.ismarket,\nand\ntimeframe.isdaily\nall return values of the “bool” type.\n\ncolor\n\nColor literals have the following format: RRGGBB or RRGGBBAA. The\nletter pairs represent _hexadecimal_ values between 00 and FF (0 to\n255 in decimal) where:\n\n- RR, GG and BB pairs respectively represent the values for the\ncolor’s red, green and blue components.\n- AA is an optional value for the color’s opacity (or _alpha_\ncomponent) where 00 is invisible and FF opaque. When the literal\ndoes not include an AA pair, the script treats it as fully opaque\n(the same as using FF).\n- The hexadecimal letters in the literals can be uppercase or\nlowercase.\n\nThese are examples of “color” literals:\n\nPine Script®\nCopied\n\n000000      // black color\nFF0000      // red color\n00FF00      // green color\n0000FF      // blue color\nFFFFFF      // white color\n808080      // gray color\n3ff7a0      // some custom color\nFF000080    // 50% transparent red color\nFF0000ff    // same as FF0000, fully opaque red color\nFF000000    // completely transparent red color\n\nPine Script also has\nbuilt-in color constants, including\ncolor.green,\ncolor.red,\ncolor.orange,\ncolor.blue\n(the default color in plot*() functions and many of the default\ncolor-related properties in\ndrawing types), etc.\n\nWhen using built-in color constants, it is possible to add transparency\ninformation to them via the\ncolor.new()\nfunction.\n\nNote that when specifying red, green or blue components in color.*()\nfunctions, we use “int” or “float” arguments with values between 0\nand 255. When specifying transparency, we use a value between 0 and 100,\nwhere 0 means fully opaque and 100 means completely transparent. For\nexample:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Shading the chart's background\", overlay = true)\n//@variable A \"const color\" value representing the base for each day's color.\ncolor BASE_COLOR = color.rgb(0, 99, 165)\n//@variable A \"series int\" value that modifies the transparency of the BASE_COLOR in color.new().\nint transparency = 50 + int(40 * dayofweek / 7)\n// Color the background using the modified BASE_COLOR.\nbgcolor(color.new(BASE_COLOR, transparency))\n\nSee the User Manual’s page on colors for more information on using colors in scripts.\n\nstring\n\nValues of the “string” type represent sequences of letters, numbers,\nsymbols, spaces, and other characters.\n\nString literals in Pine are characters enclosed in single or double\nquotation marks. For example:\n\nPine Script®\nCopied\n\n\"This is a string literal using double quotes.\"\n'This is a string literal using single quotes.'\n\nSingle and double quotation marks are functionally equivalent in Pine\nScript. A “string” enclosed within double quotation marks can contain\nany number of single quotation marks and vice versa:\n\nPine Script®\nCopied\n\n\"It's an example\"\n'The \"Star\" indicator'\n\nScripts can _escape_ the enclosing delimiter in a “string” using the\nbackslash character ( \\). For example:\n\nPine Script®\nCopied\n\n'It\\'s an example'\n\"The \\\"Star\\\" indicator\"\n\nWe can create “string” values containing the new line escape character\n( \\n) for displaying multiline text with plot() and log.()\nfunctions and objects of\ndrawing types. For example:\n\nPine Script®\nCopied\n\n\"This\\nString\\nHas\\nOne\\nWord\\nPer\\nLine\"\n\nWe can use the\n+ operator\nto concatenate “string” values:\n\nPine Script®\nCopied\n\n\"This is a \" + \"concatenated string.\"\n\nThe built-ins in the str.*() namespace create “string” values using\nspecialized operations. For instance, this script creates a _formatted_\n_string_ to represent “float” price values and displays the result\nusing a label:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Formatted string demo\", overlay = true)\n//@variable A \"series string\" value representing the bar's OHLC data.\nstring ohlcString = str.format(\"Open: {0}\\nHigh: {1}\\nLow: {2}\\nClose: {3}\", open, high, low, close)\n// Draw a label containing the ohlcString.\nlabel.new(bar_index, high, ohlcString, textcolor = color.white)\n\nBuilt-in variables such as\nsyminfo.tickerid,\nsyminfo.currency,\nand\ntimeframe.period\nreturn values of the “string” type.\n\nRefer to the Strings page to learn more about Pine strings. For information about displaying text from “string” values, see the Text and shapes and Debugging pages.\n\nplot and hline\n\nPine Script’s\nplot()\nand\nhline()\nfunctions return IDs that respectively reference instances of the\n“plot” and “hline” types. These types display calculated values and\nhorizontal levels on the chart, and one can assign their IDs to\nvariables for use with the built-in\nfill()\nfunction.\n\nFor example, this script plots two EMAs on the chart and fills the space\nbetween them using a\nfill()\ncall:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"plot fill demo\", overlay = true)\n//@variable A \"series float\" value representing a 10-bar EMA of close.\nfloat emaFast = ta.ema(close, 10)\n//@variable A \"series float\" value representing a 20-bar EMA of close.\nfloat emaSlow = ta.ema(close, 20)\n//@variable The plot of the emaFast value.\nemaFastPlot = plot(emaFast, \"Fast EMA\", color.orange, 3)\n//@variable The plot of the emaSlow value.\nemaSlowPlot = plot(emaSlow, \"Slow EMA\", color.gray, 3)\n// Fill the space between the emaFastPlot and emaSlowPlot.\nfill(emaFastPlot, emaSlowPlot, color.new(color.purple, 50), \"EMA Fill\")\n\nIt’s important to note that unlike other special types, there is no\nplot or hline keyword in Pine to explicitly declare a variable’s\ntype as “plot” or “hline”.\n\nUsers can control where their scripts’ plots display via the variables\nin the display. namespace and a plot() function’s force_overlay\nparameter. Additionally, one script can use the values from another\nscript’s plots as _external inputs_ via the\ninput.source()\nfunction (see our User Manual’s section on\nsource inputs).\n\nDrawing types\n\nPine Script drawing types allow scripts to create custom drawings on\ncharts. They include the following:\nline,\nlinefill,\nbox,\npolyline,\nlabel,\nand\ntable.\n\nEach type also has a namespace containing all the built-ins that create\nand manage drawing instances. For example, the following *.new()\nconstructors create new objects of these types in a script:\nline.new(),\nlinefill.new(),\nbox.new(),\npolyline.new(),\nlabel.new(),\nand\ntable.new().\n\nEach of these functions returns an _ID_ which is a reference that\nuniquely identifies a drawing object. IDs are always qualified as\n“series”, meaning their qualified types are “series line”, “series\nlabel”, etc. Drawing IDs act like pointers, as each ID references a\nspecific instance of a drawing in all the functions from that drawing’s\nnamespace. For instance, the ID of a line returned by a\nline.new()\ncall is used later to refer to that specific object once it’s time to\ndelete it with\nline.delete().\n\nChart points\n\nChart points are special types that represent coordinates on the chart.\nScripts use the information from\nchart.point\nobjects to determine the chart locations of\nlines,\nboxes,\npolylines,\nand labels.\n\nObjects of this type contain three _fields_: time, index, and\nprice. Whether a drawing instance uses the time or price field\nfrom a\nchart.point\nas an x-coordinate depends on the drawing’s xloc property.\n\nWe can use any of the following functions to create chart points in a\nscript:\n\n- chart.point.new() -\nCreates a new\nchart.point\nwith a specified time, index, and price.\n- chart.point.now() -\nCreates a new\nchart.point\nwith a specified price y-coordinate. The time and index fields\ncontain the\ntime\nand\nbar\\_index\nof the bar the function executes on.\n- chart.point.from\\_index() -\nCreates a new\nchart.point\nwith an index x-coordinate and price y-coordinate. The time\nfield of the resulting instance is\nna,\nmeaning it will not work with drawing objects that use an xloc\nvalue of\nxloc.bar\\_time.\n- chart.point.from\\_time() -\nCreates a new\nchart.point\nwith a time x-coordinate and price y-coordinate. The index\nfield of the resulting instance is\nna,\nmeaning it will not work with drawing objects that use an xloc\nvalue of\nxloc.bar\\_index.\n- chart.point.copy() -\nCreates a new\nchart.point\ncontaining the same time, index, and price information as the\nid in the function call.\n\nThis example draws lines connecting the previous bar’s\nhigh\nto the current bar’s\nlow on\neach chart bar. It also displays labels at both points of each line. The\nline and labels get their information from the firstPoint and\nsecondPoint variables, which reference chart points created using\nchart.point.from\\_index()\nand\nchart.point.now():\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Chart points demo\", overlay = true)\n//@variable A new chart.point at the previous bar_index and high.\nfirstPoint = chart.point.from_index(bar_index - 1, high[1])\n//@variable A new chart.point at the current bar's low.\nsecondPoint = chart.point.now(low)\n// Draw a new line connecting coordinates from the firstPoint and secondPoint.\n// This line uses the index fields from the points as x-coordinates.\nline.new(firstPoint, secondPoint, color = color.purple, width = 3)\n// Draw a label at the firstPoint. Uses the point's index field as its x-coordinate.\nlabel.new(\n     firstPoint, str.tostring(firstPoint.price), color = color.green,\n     style = label.style_label_down, textcolor = color.white\n)\n// Draw a label at the secondPoint. Uses the point's index field as its x-coordinate.\nlabel.new(\n     secondPoint, str.tostring(secondPoint.price), color = color.red,\n     style = label.style_label_up, textcolor = color.white\n)\n\nCollections\n\nCollections in Pine Script ( arrays, matrices,\nand maps) utilize reference\nIDs, much like other special types (e.g., labels). The type of the ID\ndefines the type of _elements_ the collection will contain. In Pine, we\nspecify array, matrix, and map types by appending a\ntype template to the\narray,\nmatrix,\nor map\nkeywords:\n\n- array<int> defines an array containing “int” elements.\n- array<label> defines an array containing “label” IDs.\n- array<UDT> defines an array containing IDs referencing objects of\na\nuser-defined type (UDT).\n- matrix<float> defines a matrix containing “float” elements.\n- matrix<UDT> defines a matrix containing IDs referencing objects of\na\nuser-defined type (UDT).\n- map<string, float> defines a map containing “string” keys and\n“float” values.\n- map<int, UDT> defines a map containing “int” keys and IDs of\nuser-defined type (UDT) instances as values.\n\nFor example, one can declare an “int” array with a single element\nvalue of 10 in any of the following, equivalent ways:\n\nPine Script®\nCopied\n\na1 = array.new<int>(1, 10)\narray<int> a2 = array.new<int>(1, 10)\na3 = array.from(10)\narray<int> a4 = array.from(10)\n\nNote that:\n\n- The int[] syntax can also specify an array of “int”\nelements, but its use is discouraged. No equivalent exists to\nspecify the types of matrices or maps in that way.\n- Type-specific built-ins exist for arrays, such as\narray.new\\_int(),\nbut the more generic array.new<type>()\nform is preferred, which would be array.new<int>() to create\nan array of “int” elements.\n\nUser-defined types\n\nThe\ntype\nkeyword allows the creation of _user-defined types_ (UDTs) from which\nscripts can create objects. UDTs are composite types; they contain an arbitrary number\nof _fields_ that can be of any type, including other user-defined types.\n\nThe syntax to declare a user-defined type is:\n\n`\n\n[export ]type <UDT_identifier>\n\n    <field_type> <field_name>[ = <value>]\n\n    ...\n`\n\nwhere:\n\n- export\nis the keyword that a\nlibrary\nscript uses to export the user-defined type. To learn more about\nexporting UDTs, see our User Manual’s\nLibraries\npage.\n- <UDT_identifier> is the name of the user-defined type.\n- <field_type> is the type of the field.\n- <field_name> is the name of the field.\n- <value> is an optional default value for the field, which the\nscript will assign to it when creating new objects of that UDT. If\none does not provide a value, the field’s default is\nna.\nThe same rules as those governing the default values of parameters\nin function signatures apply to the default values of fields. For\nexample, a UDT’s default values cannot use results from the\nhistory-referencing operator\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nor expressions.\n\nThis example declares a pivotPoint UDT with an “int” pivotTime\nfield and a “float” priceLevel field that will respectively hold\ntime and price information about a calculated pivot:\n\nPine Script®\nCopied\n\n    //@type             A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    type pivotPoint\n        int   pivotTime\n        float priceLevel\n\nUser-defined types support _type recursion_, i.e., the fields of a UDT\ncan reference objects of the same UDT. Here, we’ve added a nextPivot\nfield to our previous pivotPoint type that references another\npivotPoint instance:\n\nPine Script®\nCopied\n\n    //@type             A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    //@field nextPivot  A pivotPoint instance containing additional pivot information.\n    type pivotPoint\n        int        pivotTime\n        float      priceLevel\n        pivotPoint nextPivot\n\nScripts can use two built-in methods to create and copy UDTs: new()\nand copy(). See our User Manual’s page on\nObjects to learn more\nabout working with UDTs.\n\nEnum types\n\nThe enum keyword allows the creation of an _enum_, otherwise known as an _enumeration_, _enumerated type_, or _enum type_. An enum is a unique type construct containing distinct, named fields representing _members_ (i.e., possible values) of the type. Enums allow programmers to control the values accepted by variables, conditional expressions, and collections, and they facilitate convenient dropdown input creation with the input.enum() function.\n\nThe syntax to declare an enum is as follows:\n\n`\n\n[export ]enum <enumName>\n\n    <field_1>[ = <title_1>]\n\n    <field_2>[ = <title_2>]\n\n    ...\n\n    <field_N>[ = <title_N>]\n`\n\nwhere:\n\n- export\nis the optional keyword allowing a\nlibrary\nto export the enum for use in other scripts. See\nthis section to learn more about exporting enum types.\n- <enumName> is the name of the enum type. Scripts can use the\nenum’s name as the type keyword in\nvariable declarations and\ntype templates.\n- <field_*> is the name of an enum field, representing a named\nmember (value) of the enumName type. Each field must have a unique\nname that does not match the name or title of any other field in the\nenum. To retrieve an enum member, reference its field name using dot\nnotation syntax (i.e., enumName.fieldName).\n- <title_*> is a “const string” title assigned to a field. If one\ndoes not specify a title, the field’s title is the “string”\nrepresentation of its name. The\ninput.enum()\nfunction displays field titles within its dropdown in the script’s\n“Settings/Inputs” tab. Users can also retrieve a field’s title\nwith the\nstr.tostring()\nfunction. As with field names, each field’s title must not match\nthe name or title of any other field in the enum.\n\nThis example declares an maChoice enum. Each field within this\ndeclaration represents a distinct member of the maChoice enum type:\n\nPine Script®\nCopied\n\n//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"\n\nNote that:\n\n- All the enum’s possible values are available upon the _first_\nscript execution and do not change across subsequent executions.\nHence, they automatically adopt the\nsimple qualifier.\n\nThe script below uses the maChoice enum within an\ninput.enum()\ncall to create a _dropdown_ input in the “Settings/Inputs” tab that\ndisplays all the field titles. The maInput value represents the member\nof the enum that corresponds to the user-selected title. The script uses\nthe selected member within a\nswitch\nstructure to determine the built-in moving average it calculates:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Enum types demo\", overlay = true)\n//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"\n//@variable The maChoice member representing a selected moving average name.\nmaChoice maInput = input.enum(maChoice.sma, \"Moving average type\")\n//@variable The length of the moving average.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n//@variable The moving average selected by the maInput.\nfloat selectedMA = switch maInput\n    maChoice.sma => ta.sma(close, lengthInput)\n    maChoice.ema => ta.ema(close, lengthInput)\n    maChoice.wma => ta.wma(close, lengthInput)\n    maChoice.hma => ta.hma(close, lengthInput)\n// Plot the selectedMA.\nplot(selectedMA, \"Selected moving average\", color.teal, 3)\n\nSee the Enums page and the\nEnum input section of the Inputs page to learn more about using enums and enum inputs.\n\nvoid\n\nThere is a “void” type in Pine Script. Functions having only\nside-effects and returning no usable result return the “void” type. An\nexample of such a function is\nalert();\nit does something (triggers an alert event), but it returns no usable\nvalue.\n\nScripts cannot use “void” results in expressions or assign them to\nvariables. No void keyword exists in Pine Script since one cannot\ndeclare a variable of the “void” type.\n\n​ na ​ value\n\nThere is a special value in Pine Script called\nna,\nwhich is an acronym for _not available_. We use\nna to\nrepresent an undefined value from a variable or expression. It is\nsimilar to null in Java and None in Python.\n\nScripts can automatically cast\nna\nvalues to almost any type. However, in some cases, the compiler cannot\ninfer the type associated with an\nna value\nbecause more than one type-casting rule may apply. For example:\n\nPine Script®\nCopied\n\n// Compilation error!\nmyVar = na\n\nThe above line of code causes a compilation error because the compiler\ncannot determine the nature of the myVar variable, i.e., whether the\nvariable will reference numeric values for plotting, string values for\nsetting text in a label, or other values for some other purpose later in\nthe script’s execution.\n\nTo resolve such errors, we must explicitly declare the type associated\nwith the variable. Suppose the myVar variable will reference “float”\nvalues in subsequent script iterations. We can resolve the error by\ndeclaring the variable with the\nfloat\nkeyword:\n\nPine Script®\nCopied\n\nfloat myVar = na\n\nor by explicitly casting the\nna value\nto the “float” type via the\nfloat()\nfunction:\n\nPine Script®\nCopied\n\nmyVar = float(na)\n\nTo test if the value from a variable or expression is\nna, we\ncall the\nna()\nfunction, which returns true if the value is undefined. For example:\n\nPine Script®\nCopied\n\n//@variable Is 0 if the myVar is na, close otherwise.\nfloat myClose = na(myVar) ? 0 : close\n\nDo not use the == comparison operator to test for\nna\nvalues, as scripts cannot determine the equality of an undefined value:\n\nPine Script®\nCopied\n\n//@variable Returns the close value. The script cannot compare the equality of na values, as they're undefined.\nfloat myClose = myVar == na ? 0 : close\n\nBest coding practices often involve handling\nna\nvalues to prevent undefined values in calculations.\n\nWe can ensure the expression also returns an actionable value on the\nfirst bar by replacing the undefined past value with a value from the\ncurrent bar. This line of code uses the\nnz()\nfunction to replace the past bar’s\nclose\nwith the current bar’s\nopen\nwhen the value is\nna:\n\nPine Script®\nCopied\n\n//@variable Is true when the close exceeds the last bar's close (or the current open if the value is na).\nbool risingClose = close > nz(close[1], open)\n\nProtecting scripts against\nna\ninstances helps to prevent undefined values from propagating in a\ncalculation’s results. For example, this script declares an\nallTimeHigh variable on the first bar. It then uses the\nmath.max()\nbetween the allTimeHigh and the bar’s\nhigh\nto update the allTimeHigh throughout its execution:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of na.\nvar float allTimeHigh = na\n// Reassign the value of the allTimeHigh.\n// Returns na on all bars because math.max() can't compare the high to an undefined value.\nallTimeHigh := math.max(allTimeHigh, high)\nplot(allTimeHigh) // Plots na on all bars.\n\nThis script plots a value of\nna on\nall bars, as we have not included any\nna\nprotection in the code. To fix the behavior and plot the intended result\n(i.e., the all-time high of the chart’s prices), we can use\nnz() to\nreplace\nna\nvalues in the allTimeHigh series:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of na.\nvar float allTimeHigh = na\n// Reassign the value of the allTimeHigh.\n// We've used nz() to prevent the initial na value from persisting throughout the calculation.\nallTimeHigh := math.max(nz(allTimeHigh), high)\nplot(allTimeHigh)\n\nType templates\n\nType templates specify the data types that collections\n( arrays,\nmatrices, and\nmaps) can contain.\n\nTemplates for arrays and\nmatrices consist of a\nsingle type identifier surrounded by angle brackets, e.g., <int>,\n<label>, and <PivotPoint> (where PivotPoint is a\nuser-defined type (UDT)).\n\nTemplates for maps consist of\ntwo type identifiers enclosed in angle brackets, where the first\nspecifies the type of _keys_ in each key-value pair, and the second\nspecifies the _value_ type. For example, <string, float> is a type\ntemplate for a map that holds string keys and float values.\n\nUsers can construct type templates from:\n\n- Fundamental types:\nint,\nfloat,\nbool,\ncolor,\nand string\n- The following special types:\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable, and\nchart.point\n- User-defined types (UDTs)\n- Enum types\n\nNote that:\n\n- Maps can use any of\nthese types as _values_, but they can only accept fundamental\ntypes or enum types as _keys_.\n\nScripts use type templates to declare variables that reference\ncollections, and when creating new collection instances. For example:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Type templates demo\")\n//@variable A variable initially assigned to na that accepts arrays of \"int\" values.\narray<int> intArray = na\n//@variable An empty matrix that holds \"float\" values.\nfloatMatrix = matrix.new<float>()\n//@variable An empty map that holds \"string\" keys and \"color\" values.\nstringColorMap = map.new<string, color>()\n\nType casting\n\nPine Script includes an automatic type-casting mechanism that _casts_\n(converts) “int” values to “float” when necessary. Variables\nor expressions requiring “float” values can also use “int” values\nbecause any integer can be represented as a floating point number with\nits fractional part equal to 0.\n\nIt’s sometimes necessary to cast one type to another when auto-casting\nrules do not suffice. For such cases, the following type-casting\nfunctions are available:\nint(),\nfloat(),\nbool(),\ncolor(),\nstring(),\nline(),\nlinefill(),\nlabel(),\nbox(),\nand\ntable().\n\nThe example below shows a code that tries to use a “const float” value\nas the length argument in the\nta.sma()\nfunction call. The script will fail to compile, as it cannot\nautomatically convert the “float” value to the required “int” type:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Explicit casting demo\", overlay = true)\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, LENGTH) // Compilation error. The length parameter requires an \"int\" value.\nplot(sma)\n\nThe code raises the following error: _“Cannot call ‘ta.sma’ with_\n_argument ‘length’=‘LENGTH’. An argument of ‘const float’ type was_\n_used but a ‘series int’ is expected.”_\n\nThe compiler is telling us that the code is using a “float” value\nwhere an “int” is required. There is no auto-casting rule to cast a\n“float” to an “int”, so we must do the job ourselves. In this\nversion of the code, we’ve used the\nint()\nfunction to explicitly convert our “float” LENGTH value to the\n“int” type within the\nta.sma()\ncall:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"explicit casting demo\")\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, int(LENGTH)) // Compiles successfully since we've converted the LENGTH to \"int\".\nplot(sma)\n\nExplicit type casting is also handy when declaring variables assigned to\nna, as\nexplained in the\nprevious section.\n\nFor example, once could explicitly declare a variable with a value of\nna as a\n“label” type in either of the following, equivalent ways:\n\nPine Script®\nCopied\n\n// Explicitly specify that the variable references \"label\" objects:\nlabel myLabel = na\n// Explicitly cast the na value to the \"label\" type:\nmyLabel = label(na)\n\nTuples\n\nA _tuple_ is a comma-separated set of expressions enclosed in brackets.\nWhen a function, method,\nor other local block returns more than one value, scripts return those\nvalues in the form of a tuple.\n\nFor example, the following\nuser-defined function returns the sum and product of two “float” values:\n\nPine Script®\nCopied\n\n//@function Calculates the sum and product of two values.\ncalcSumAndProduct(float a, float b) =>\n    //@variable The sum of a and b.\n    float sum = a + b\n    //@variable The product of a and b.\n    float product = a * b\n    // Return a tuple containing the sum and product.\n    [sum, product]\n\nWhen we call this function later in the script, we use a _tuple_\n_declaration_ to declare multiple variables corresponding to the values\nreturned by the function call:\n\nPine Script®\nCopied\n\n// Declare a tuple containing the sum and product of the high and low, respectively.\n[hlSum, hlProduct] = calcSumAndProduct(high, low)\n\nKeep in mind that unlike declaring single variables, we cannot\nexplicitly define the types the tuple’s variables ( hlSum and\nhlProduct in this case), will contain. The compiler automatically\ninfers the types associated with the variables in a tuple.\n\nIn the above example, the resulting tuple contains values of the same\ntype (“float”). However, it’s important to note that tuples can\ncontain values of _multiple types_. For example, the chartInfo()\nfunction below returns a tuple containing “int”, “float”, “bool”,\n“color”, and “string” values:\n\nPine Script®\nCopied\n\n//@function Returns information about the current chart.\nchartInfo() =>\n    //@variable The first visible bar's UNIX time value.\n    int firstVisibleTime = chart.left_visible_bar_time\n    //@variable The close value at the firstVisibleTime.\n    float firstVisibleClose = ta.valuewhen(ta.cross(time, firstVisibleTime), close, 0)\n    //@variable Is true when using a standard chart type, false otherwise.\n    bool isStandard = chart.is_standard\n    //@variable The foreground color of the chart.\n    color fgColor = chart.fg_color\n    //@variable The ticker ID of the current chart.\n    string symbol = syminfo.tickerid\n    // Return a tuple containing the values.\n    [firstVisibleTime, firstVisibleClose, isStandard, fgColor, symbol]\n\nTuples are especially handy for requesting multiple values in one\nrequest.security()\ncall.\n\nFor instance, this roundedOHLC() function returns a tuple containing\nOHLC values rounded to the nearest prices that are divisible by the\nsymbol’s minimum tick size ( syminfo.mintick). We call this function as the expression argument in\nrequest.security()\nto request a tuple containing daily OHLC values:\n\nPine Script®\nCopied\n\n//@function Returns a tuple of OHLC values, rounded to the nearest tick.\nroundedOHLC() =>\n    [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n[op, hi, lo, cl] = request.security(syminfo.tickerid, \"D\", roundedOHLC())\n\nWe can also achieve the same result by directly passing a tuple of\nrounded values as the expression in the\nrequest.security()\ncall:\n\nPine Script®\nCopied\n\n[op, hi, lo, cl] = request.security(\n     syminfo.tickerid, \"D\",\n     [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n)\n\nLocal blocks of\nconditional structures, including\nif and\nswitch\nstatements, can return tuples. For example:\n\nPine Script®\nCopied\n\n[v1, v2] = if close > open\n    [high, close]\nelse\n    [close, low]\n\nand:\n\nPine Script®\nCopied\n\n[v1, v2] = switch\nclose > open => [high, close]\n=>              [close, low]\n\nHowever, ternaries cannot contain tuples, as the return values in a\nternary statement are not considered local blocks:\n\nPine Script®\nCopied\n\n// Not allowed.\n[v1, v2] = close > open ? [high, close] : [close, low]\n\nNote that all items within a tuple returned from a function are\nqualified as “simple” or “series”, depending on its contents. If a\ntuple contains a “series” value, all other elements within the tuple\nwill also adopt the “series” qualifier. For example:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Qualified types in tuples demo\")\ngetParameters(float source, simple int length) =>\n    // The second item in the tuple becomes a \"series\" if source is a \"series\"\n    // because all returned tuple elements adopt the strongest qualifier.\n    [source, length]\n// Although the length argument is a \"const int\", the len variable is a \"series\" because src is a \"series\".\n[src, len] = getParameters(close, 20)\n// Causes a compilation error because ta.ema() requires a \"simple int\" length argument.\nplot(ta.ema(src, len))\n`\n\nPrevious\\\\\nExecution model Next\\\\\nScript structure",
    "tags": [
      "style",
      "guide",
      "naming",
      "formatting",
      "conventions"
    ],
    "examples": [
      "[export ]type <UDT_identifier>\n\n    <field_type> <field_name>[ = <value>]\n\n    ...",
      "[export ]enum <enumName>\n\n    <field_1>[ = <title_1>]\n\n    <field_2>[ = <title_2>]\n\n    ...\n\n    <field_N>[ = <title_N>]"
    ]
  },
  "872264b7": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nArrays\n\nIntroduction\n\nPine Script Arrays are one-dimensional collections that can hold\nmultiple value references. Think of them as a better way to handle cases\nwhere one would otherwise need to explicitly declare a set of similar\nvariables (e.g., price00, price01, price02, …).\n\nAll elements in an array must be of the same built-in type, user-defined type, or enum type.\n\nScripts reference arrays using array IDs similar to the IDs of lines, labels, and other _special types_. Pine Script does not use an indexing operator to reference individual array elements.\nInstead, functions including array.get() and array.set() read and write the values of array elements.\n\nScripts reference the elements of an array using an _index_, which\nstarts at 0 and extends to the number of elements in the array minus\none. Arrays in Pine Script can have a dynamic size that varies across\nbars, as one can change the number of elements in an array on each\niteration of a script. Scripts can contain multiple array instances. The\nsize of arrays is limited to 100,000 elements.\n\nDeclaring arrays\n\nPine Script uses the following syntax to declare arrays:\n\n``\n\n[var/varip ][array<type>/<type[]> ]<identifier> = <expression>\n`\n\nWhere <type> is a\ntype template for the array that declares the type of values it will\ncontain, and the <expression> returns either an array of the specified\ntype or na.\n\nWhen declaring a variable as an array, we can use the\narray\nkeyword followed by a\ntype template. Alternatively, we can use the type name followed by the\n[] modifier (not to be confused with the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) _history-referencing operator_).\n\nSince Pine always uses type-specific functions to create arrays, the\narray<type>/type[] part of the declaration is redundant, except when\ndeclaring an array variable assigned to na. Even when not required,\nexplicitly declaring the array type helps clearly state the intention to\nreaders.\n\nThis line of code declares an array variable named prices that points\nto na. In this case, we must specify the type to declare that the\nvariable can reference arrays containing “float” values:\n\nPine Script®\nCopied\n\narray<float> prices = na\n\nWe can also write the above example in this form:\n\nPine Script®\nCopied\n\nfloat[] prices = na\n\nWhen declaring an array and the <expression> is not na, use one of\nthe following functions: array.new<type>(),\narray.from(),\nor\narray.copy().\nFor array.new<type>() calls, the arguments of\nthe function’s size and initial_value parameters can be “series” to allow\ndynamic sizing and initialization of array elements. The following\nexample creates an array containing zero “float” elements, and this\ntime, the array reference returned by the array.new\\<float\\>()\nfunction call is assigned to the prices variable:\n\nPine Script®\nCopied\n\nprices = array.new<float>(0)\n\nThe initial_value parameter of the array.new*() functions allows users to\nset all elements in the array to a specified value. If no argument is\nprovided for initial_value, the array is filled with na values.\n\nThis line declares an array ID named prices pointing to an array\ncontaining two elements, each assigned to the bar’s close value:\n\nPine Script®\nCopied\n\nprices = array.new<float>(2, close)\n\nTo create an array and initialize its elements with different values,\nuse\narray.from().\nThis function infers the array’s size and the type of elements it will\nhold from the arguments in the function call. As with array.new*\nfunctions, it accepts “series” arguments. All values supplied to the\nfunction must be of the same type.\n\nFor example, all three of these lines of code will create identical\n“bool” arrays with the same two elements:\n\nPine Script®\nCopied\n\nstatesArray = array.from(close > open, high != close)\nbool[] statesArray = array.from(close > open, high != close)\narray<bool> statesArray = array.from(close > open, high != close)\n\nUsing ​ var ​ and ​ varip ​ keywords\n\nUsers can utilize\nvar and\nvarip\nkeywords to instruct a script to declare an array variable only once on\nthe first execution of the script on the first chart bar. Array\nvariables declared using these keywords point to the same array\ninstances until explicitly reassigned, allowing an array and its element\nreferences to persist across bars.\n\nWhen declaring an array variable using these keywords and pushing a new\nvalue to the end of the referenced array on each bar, the array will\ngrow by one on each bar and be of size bar_index + 1\n( bar\\_index\nstarts at zero) by the time the script executes on the last bar, as this\ncode demonstrates:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Using var\")\n//@variable An array that expands its size by 1 on each bar.\nvar a = array.new<float>(0)\narray.push(a, close)\nif barstate.islast\n    //@variable A string containing the size of a and the current bar_index value.\n    string labelText = \"Array size: \" + str.tostring(a.size()) + \"\\nbar_index: \" + str.tostring(bar_index)\n    // Display the labelText.\n    label.new(bar_index, 0, labelText, size = size.large)\n\nThe same code without the\nvar\nkeyword would re-declare the array on each bar. In this case, after\nexecution of the\narray.push()\ncall, the\narray.size() _method_\ncall ( a.size()) would return a value of 1.\n\nReading and writing array elements\n\nScripts can write values to existing individual array elements using\narray.set(),\nand read using array.get().\nWhen using these functions, it is imperative that the index in the\nfunction call is always less than or equal to the array’s size (because\narray indices start at zero). To get the size of an array, use the\narray.size()\nfunction.\n\nThe following example uses the\nset()\nmethod to populate a fillColors array with instances of one base color\nusing different transparency levels. It then uses\narray.get()\nto retrieve one of the colors from the array based on the location of\nthe bar with the highest price within the last lookbackInput bars:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Distance from high\", \"\", true)\nlookbackInput = input.int(100)\nFILL_COLOR = color.green\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(5)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    fillColors.set(0, color.new(FILL_COLOR, 70))\n    fillColors.set(1, color.new(FILL_COLOR, 75))\n    fillColors.set(2, color.new(FILL_COLOR, 80))\n    fillColors.set(3, color.new(FILL_COLOR, 85))\n    fillColors.set(4, color.new(FILL_COLOR, 90))\n// Find the offset to highest high. Change its sign because the function returns a negative value.\nlastHiBar = - ta.highestbars(high, lookbackInput)\n// Convert the offset to an array index, capping it to 4 to avoid a runtime error.\n// The index used by array.get() will be the equivalent of floor(fillNo).\nfillNo = math.min(lastHiBar / (lookbackInput / 5), 4)\n// Set background to a progressively lighter fill with increasing distance from location of highest high.\nbgcolor(array.get(fillColors, fillNo))\n// Plot key values to the Data Window for debugging.\nplotchar(lastHiBar, \"lastHiBar\", \"\", location.top, size = size.tiny)\nplotchar(fillNo, \"fillNo\", \"\", location.top, size = size.tiny)\n\nAnother technique for initializing the elements in an array is to create\nan _empty array_ (an array with no elements), then use\narray.push()\nto append new elements to the end of the array, increasing the size\nof the array by one on each call. The following code is functionally\nidentical to the initialization section from the preceding script:\n\nPine Script®\nCopied\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    array.push(fillColors, color.new(FILL_COLOR, 70))\n    array.push(fillColors, color.new(FILL_COLOR, 75))\n    array.push(fillColors, color.new(FILL_COLOR, 80))\n    array.push(fillColors, color.new(FILL_COLOR, 85))\n    array.push(fillColors, color.new(FILL_COLOR, 90))\n\nThis code is equivalent to the one above, but it uses\narray.unshift()\nto insert new elements at the _beginning_ of the fillColors array:\n\nPine Script®\nCopied\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    array.unshift(fillColors, color.new(FILL_COLOR, 90))\n    array.unshift(fillColors, color.new(FILL_COLOR, 85))\n    array.unshift(fillColors, color.new(FILL_COLOR, 80))\n    array.unshift(fillColors, color.new(FILL_COLOR, 75))\n    array.unshift(fillColors, color.new(FILL_COLOR, 70))\n\nWe can also use\narray.from()\nto create the same fillColors array with a single function call:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Using var\")\nFILL_COLOR = color.green\nvar array<color> fillColors = array.from(\n     color.new(FILL_COLOR, 70),\n     color.new(FILL_COLOR, 75),\n     color.new(FILL_COLOR, 80),\n     color.new(FILL_COLOR, 85),\n     color.new(FILL_COLOR, 90)\n)\n// Cycle background through the array's colors.\nbgcolor(array.get(fillColors, bar_index % (fillColors.size())))\n\nThe array.fill()\nfunction points all array elements, or the elements within the index_from to index_to range, to a specified value. Without the\nlast two optional parameters, the function fills the whole array, so:\n\nPine Script®\nCopied\n\na = array.new<float>(10, close)\n\nand:\n\nPine Script®\nCopied\n\na = array.new<float>(10)\na.fill(close)\n\nare equivalent, but:\n\nPine Script®\nCopied\n\na = array.new<float>(10)\na.fill(close, 1, 3)\n\nonly fills the second and third elements (at index 1 and 2) of the array\nwith close. Note how the\narray.fill() function’s\nlast parameter, index_to, must have a value one greater than the last index the\nfunction will fill. The remaining elements will hold na values, as the\narray.new<type>()\nfunction call does not contain an initial_value argument.\n\nLooping through array elements\n\nWhen looping through an array’s element indices and the array’s size\nis unknown, one can use the\narray.size()\nfunction to get the maximum index value. For example:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected for loop\", overlay = true)\n//@variable An array of close prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in a.\nstring labelText = \"\"\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\n    labelText += str.tostring(array.get(a, i)) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\n\nNote that:\n\n- We use the\nrequest.security\\_lower\\_tf()\nfunction which returns an array of\nclose\nprices at the 1 minute timeframe.\n- This code example will throw an error if you use it on a chart\ntimeframe smaller than 1 minute.\n- for\nloops do not execute if the to expression is\nna.\nNote that the to value is only evaluated once upon entry.\n\nAn alternative method to loop through an array is to use a\nfor…in\nloop. This approach is a variation of the standard for loop that can\niterate over the value references and indices in an array. Here is an\nexample of how we can write the code example from above using a\nfor...in loop:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for...in loop\", overlay = true)\n//@variable An array of close prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in a.\nstring labelText = \"\"\nfor price in a\n    labelText += str.tostring(price) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\n\nNote that:\n\n- for…in\nloops can return a tuple containing each index and corresponding\nelement. For example, for [i, price] in a returns the i\nindex and price value for each element in a.\n\nA\nwhile\nloop statement can also be used:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"while loop\", overlay = true)\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\nstring labelText = \"\"\nint i = 0\nwhile i < array.size(a)\n    labelText += str.tostring(array.get(a, i)) + \"\\n\"\n    i += 1\nlabel.new(bar_index, high, text = labelText)\n\nScope\n\nUsers can declare arrays within the global scope of a script, as well as\nthe local scopes of\nfunctions,\nmethods, and\nconditional structures. Unlike some of the other built-in types, namely\n_fundamental_ types, scripts can modify globally-assigned arrays from\nwithin local scopes, allowing users to implement global variables that\nany function in the script can directly interact with. We use the\nfunctionality here to calculate progressively lower or higher price\nlevels:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Bands\", \"\", true)\n//@variable The distance ratio between plotted price levels.\nfactorInput = 1 + (input.float(-2., \"Step %\") / 100)\n//@variable A single-value array holding the lowest ohlc4 value within a 50 bar window from 10 bars back.\nlevel = array.new<float>(1, ta.lowest(ohlc4, 50)[10])\nnextLevel(val) =>\n    newLevel = level.get(0) * val\n    // Write new level to the global level array so we can use it as the base in the next function call.\n    level.set(0, newLevel)\n    newLevel\nplot(nextLevel(1))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\n\nHistory referencing\n\nThe history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) can\naccess the history of array variables, allowing scripts to interact with\npast array instances previously assigned to a variable.\n\nTo illustrate this, let’s create a simple example to show how one can\nfetch the previous bar’s close value in two equivalent ways. This\nscript uses the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator to get the array instance assigned to a on the previous bar,\nthen uses an\narray.get()\nmethod call to retrieve the value of the first element ( previousClose1).\nFor previousClose2, we use the history-referencing operator on the\nclose variable directly to retrieve the value. As we see from the\nplots, previousClose1 and previousClose2 both return the same value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"History referencing\")\n//@variable A single-value array declared on each bar.\na = array.new<float>(1)\n// Set the value of the only element in a to close.\narray.set(a, 0, close)\n//@variable The array instance assigned to a on the previous bar.\nprevious = a[1]\npreviousClose1 = na(previous) ? na : previous.get(0)\npreviousClose2 = close[1]\nplot(previousClose1, \"previousClose1\", color.gray, 6)\nplot(previousClose2, \"previousClose2\", color.white, 2)\n\nInserting and removing array elements\n\nInserting\n\nThe following three functions can insert new elements into an array.\n\narray.unshift()\ninserts a new element at the beginning of an array (index 0) and\nincreases the index values of any existing elements by one.\n\narray.insert()\ninserts a new element at the specified index and increases the index\nof existing elements at or after the index by one.\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.insert()\")\na = array.new<float>(5, 0)\nfor i = 0 to 4\n    array.set(a, i, i + 1)\nif barstate.islast\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a), size = size.large)\n    array.insert(a, 2, 999)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a), style = label.style_label_up, size = size.large)\n\narray.push()\nadds a new element at the end of an array.\n\nRemoving\n\nThese four functions remove elements from an array. The first three also\nreturn the value of the removed element.\n\narray.remove()\nremoves the element at the specified index and returns that element’s\nvalue.\n\narray.shift()\nremoves the first element from an array and returns its value.\n\narray.pop()\nremoves the last element of an array and returns its value.\n\narray.clear()\nremoves all elements from an array. Note that clearing an array won’t\ndelete any objects its elements referenced. See the example below that\nillustrates how this works:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.clear() example\", overlay = true)\n// Create a label array and add a label to the array on each new bar.\nvar a = array.new<label>()\nlabel lbl = label.new(bar_index, high, \"Text\", color = color.red)\narray.push(a, lbl)\nvar table t = table.new(position.top_right, 1, 1)\n// Clear the array on the last bar. This doesn't remove the labels from the chart.\nif barstate.islast\n    array.clear(a)\n    table.cell(t, 0, 0, \"Array elements count: \" + str.tostring(array.size(a)), bgcolor = color.yellow)\n\nUsing an array as a stack\n\nStacks are LIFO (last in, first out) constructions. They behave somewhat\nlike a vertical pile of books to which books can only be added or\nremoved one at a time, always from the top. Pine Script arrays can be\nused as a stack, in which case we use the\narray.push()\nand\narray.pop()\nfunctions to add and remove elements at the end of the array.\n\narray.push(prices, close) will add a new element to the end of the\nprices array, increasing the array’s size by one.\n\narray.pop(prices) will remove the end element from the prices array,\nreturn its value and decrease the array’s size by one.\n\nSee how the functions are used here to track successive lows in rallies:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Lows from new highs\", \"\", true)\nvar lows = array.new<float>(0)\nflushLows = false\n//@function Removes the last element from the id stack when cond is true.\narray_pop(id, cond) => cond and array.size(id) > 0 ? array.pop(id) : float(na)\nif ta.rising(high, 1)\n    // Rising highs; push a new low on the stack.\n    lows.push(low)\n    // Force the return type of this if block to be the same as that of the next block.\n    bool(na)\nelse if lows.size() >= 4 or low < array.min(lows)\n    // We have at least 4 lows or price has breached the lowest low;\n    // sort lows and set flag indicating we will plot and flush the levels.\n    array.sort(lows, order.ascending)\n    flushLows := true\n// If needed, plot and flush lows.\nlowLevel = array_pop(lows, flushLows)\nplot(lowLevel, \"Low 1\", low > lowLevel ? color.silver : color.purple, 2, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 2\", low > lowLevel ? color.silver : color.purple, 3, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 3\", low > lowLevel ? color.silver : color.purple, 4, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 4\", low > lowLevel ? color.silver : color.purple, 5, plot.style_linebr)\nif flushLows\n    // Clear remaining levels after the last 4 have been plotted.\n    lows.clear()\n\nUsing an array as a queue\n\nQueues are FIFO (first in, first out) constructions. They behave\nsomewhat like cars arriving at a red light. New cars are queued at the\nend of the line, and the first car to leave will be the first one that\narrived to the red light.\n\nIn the following code example, we let users decide through the script’s\ninputs how many labels they want to have on their chart. We use that\nquantity to determine the size of the array of labels we then create,\ninitializing the array’s elements to na.\n\nWhen a new pivot is detected, we create a label for it, saving the\nlabel’s ID in the pLabel variable. We then queue the ID of that label\nby using\narray.push()\nto append the new label’s ID to the end of the array, making our array\nsize one greater than the maximum number of labels to keep on the chart.\n\nLastly, we de-queue the oldest label by removing the array’s first\nelement using\narray.shift()\nand deleting the label referenced by that array element’s value. As we\nhave now de-queued an element from our queue, the array contains\npivotCountInput elements once again. Note that on the dataset’s first\nbars we will be deleting na label IDs until the maximum number of\nlabels has been created, but this does not cause runtime errors. Let’s\nlook at our code:\n\nPine Script®\nCopied\n\n//@version=6\nMAX_LABELS = 100\nindicator(\"Show Last n High Pivots\", \"\", true, max_labels_count = MAX_LABELS)\npivotCountInput = input.int(5, \"How many pivots to show\", minval = 0, maxval = MAX_LABELS)\npivotLegsInput  = input.int(3, \"Pivot legs\", minval = 1, maxval = 5)\n// Create an array containing the user-selected max count of label IDs.\nvar labelIds = array.new<label>(pivotCountInput)\npHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nif not na(pHi)\n    // New pivot found; plot its label pivotLegsInput bars behind the current bar_index.\n    pLabel = label.new(bar_index - pivotLegsInput, pHi, str.tostring(pHi, format.mintick), textcolor = color.white)\n    // Queue the new label's ID by appending it to the end of the array.\n    array.push(labelIds, pLabel)\n    // De-queue the oldest label ID from the queue and delete the corresponding label.\n    label.delete(array.shift(labelIds))\n\nNegative indexing\n\nThe array.get(), array.set(), array.insert(), and array.remove() functions support _negative indexing_, which references elements starting from the end of the array. An index of -1 refers to the last element in the array, an index of -2 refers to the second to last element, and so on.\n\nWhen using a _positive_ index, functions traverse the array _forwards_ from the beginning of the array ( _first to last_ element). The first element’s index is 0, and the last element’s index is array.size() - 1. When using a _negative_ index, functions traverse the array _backwards_ from the end of the array ( _last to first_ element). The last element’s index is -1, and the first element’s index is –array.size():\n\nPine Script®\nCopied\n\narray<string> myArray = array.from(\"first\", \"second\", \"third\", \"fourth\", \"last\")\n// Positive indexing: Indexes forwards from the beginning of the array.\nmyArray.get(0)                        // Returns \"first\" element\nmyArray.get(myArray.size() - 1)       // Returns \"last\" element\nmyArray.get(4)                        // Returns \"last\" element\n// Negative indexing: Indexes backwards from the end of the array.\nmyArray.get(-1)                       // Returns \"last\" element\nmyArray.get(-myArray.size())          // Returns \"first\" element\nmyArray.get(-5)                       // Returns \"first\" element\n\nLike positive indexing, negative indexing is bound by the size of the array. For example, functions operating on an array of 5 elements only accept indices of 0 to 4 (first to last element) or -1 to -5 (last to first element). Any other indices are out of bounds and will raise a runtime error.\n\nWe can use negative indices to retrieve, update, add, and remove array elements. This simple script creates an “int” countingArray and calls the array.get(), array.set(), array.insert(), and array.remove() functions to perform various array operations using negative indices. It displays each array operation and its corresponding result using a table:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Negative indexing demo\", overlay = false)\n//@variable A table that displays various array operations and their results.\nvar table displayTable = table.new(\n     position.middle_center, 2, 15, bgcolor = color.white,\n     frame_color = color.black, frame_width = 1, border_width = 1\n)\n//@function Initializes a displayTable row to output a \"string\" of an arrayOperation and the operationResult.\ndisplayRow(int rowID, string arrayOperation, operationResult) =>\n    //@variable Is white if the rowID is even, light blue otherwise. Used to set alternating table row colors.\n    color rowColor = rowID % 2 == 0 ? color.white : color.rgb(33, 149, 243, 75)\n    // Display the arrayOperation in the row's first cell.\n    displayTable.cell(0, rowID, arrayOperation, text_color = color.black,\n         text_halign = text.align_left, bgcolor = rowColor, text_font_family = font.family_monospace\n     )\n    // Display the operationResult in the row's second cell.\n    displayTable.cell(1, rowID, str.tostring(operationResult), text_color = color.black,\n         text_halign = text.align_right, bgcolor = rowColor\n     )\nif barstate.islastconfirmedhistory\n    //@variable Array of \"int\" numbers. Holds six multiples of 10, counting from 10 to 60.\n    array<int> countingArray = array.from(10, 20, 30, 40, 50, 60)\n    // Initialize the table's header cells.\n    displayTable.cell(0, 0, \"ARRAY OPERATION\")\n    displayTable.cell(1, 0, \"RESULT\")\n    // Display the initial countingArray values.\n    displayTable.cell(0, 1, \"Initial countingArray\",\n         text_color = color.black, text_halign = text.align_center, bgcolor = color.yellow)\n    displayTable.cell(1, 1, str.tostring(countingArray),\n         text_color = color.black, text_halign = text.align_right, bgcolor = color.yellow)\n    // Retrieve array elements using negative indices in array.get().\n    displayRow(2, \"countingArray.get(0)\", countingArray.get(0))\n    displayRow(3, \"countingArray.get(-1)\", countingArray.get(-1))\n    displayRow(4, \"countingArray.get(-countingArray.size())\", countingArray.get(-countingArray.size()))\n    // Update array elements using negative indices in array.set() and array.insert().\n    countingArray.set(-2, 99)\n    displayRow(5, \"countingArray.set(-2, 99)\", countingArray)\n    countingArray.insert(-5, 878)\n    displayRow(6, \"countingArray.insert(-5, 878)\", countingArray)\n    // Remove array elements using negative indices in array.remove().\n    countingArray.remove(-3)\n    displayRow(7, \"countingArray.remove(-3)\", countingArray)\n\nNote that not all array operations can use negative indices. For example, search functions like array.indexof() and array.binary\\_search() return the _positive_ index of an element if it’s found in the array. If the value is not found, the functions return -1. However, this returned value is not a negative index, and using it as one would incorrectly reference the last array element. If a script needs to use a search function’s returned index in subsequent array operations, it must appropriately differentiate between this -1 result and other valid indices.\n\nCalculations on arrays\n\nWhile series variables can be viewed as a horizontal set of values\nstretching back in time, Pine Script’s one-dimensional arrays can be\nviewed as vertical structures residing on each bar. As an array’s set\nof elements is not a\ntime series,\nPine Script’s usual mathematical functions are not allowed on them.\nSpecial-purpose functions must be used to operate on all of an array’s\nvalues. The available functions are:\narray.abs(),\narray.avg(),\narray.covariance(),\narray.min(),\narray.max(),\narray.median(),\narray.mode(),\narray.percentile\\_linear\\_interpolation(),\narray.percentile\\_nearest\\_rank(),\narray.percentrank(),\narray.range(),\narray.standardize(),\narray.stdev(),\narray.sum(),\narray.variance().\n\nNote that contrary to the usual mathematical functions in Pine Script,\nthose used on arrays do not return na when some of the values they\ncalculate on have na values. There are a few exceptions to this rule:\n\n- When all array elements have na value or the array contains no\nelements, na is returned. array.standardize() however, will\nreturn an empty array.\n- array.mode() will return na when no mode is found.\n\nManipulating arrays\n\nConcatenation\n\nTwo arrays can be merged — or concatenated — using\narray.concat().\nWhen arrays are concatenated, the second array is appended to the end of\nthe first, so the first array is modified while the second one remains\nintact. The function returns the array ID of the first array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.concat()\")\na = array.new<float>(0)\nb = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(b, 2)\narray.push(b, 3)\nif barstate.islast\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\n    c = array.concat(a, b)\n    array.push(c, 4)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b) + \"\\nc: \" + str.tostring(c), style = label.style_label_up, size = size.large)\n\nCopying\n\nYou can copy an array using\narray.copy().\nHere we copy the array a to a new array named _b:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.copy()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\nif barstate.islast\n    b = array.copy(a)\n    array.push(b, 2)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\n\nNote that simply using _b = a in the previous example would not have\ncopied the array, but only its ID. From thereon, both variables would\npoint to the same array, so using either one would affect the same\narray.\n\nJoining\n\nThe array.join() function converts an “int”, “float”, or “string” array’s elements into strings, then _joins_ each one to form a single “string” value with a specified separator inserted between each combined value. It provides a convenient alternative to converting values to strings with str.tostring() and performing repeated string concatenation operations.\n\nThe following script demonstrates the array.join() function’s behaviors. It requests tuples of “string”, “int”, and “float” values from three different contexts with request.security() calls, creates separate arrays for each type with array.from(), then creates joined strings with the array.join() function. Lastly, it creates another array from those strings with array.from() and joins them with another array.join() call, using a newline as the separator, and displays the final string in the table:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Joining demo\")\n//@function Returns a tuple containing the ticker ID (\"string\"), bar index (\"int\"), and closing price (\"float\").\ndataRequest() =>\n    [syminfo.tickerid, bar_index, close]\nif barstate.islast\n    //@variable A single-cell table displaying the results of array.join() calls.\n    var table displayTable = table.new(position.middle_center, 1, 1, color.blue)\n    // Request data for three symbols.\n    [ticker1, index1, price1] = request.security(\"SPY\", \"\", dataRequest())\n    [ticker2, index2, price2] = request.security(\"GLD\", \"\", dataRequest())\n    [ticker3, index3, price3] = request.security(\"TLT\", \"\", dataRequest())\n    // Create separate \"string\", \"int\", and \"float\" arrays to hold the requested data.\n    array<string> tickerArray = array.from(ticker1, ticker2, ticker3)\n    array<int> indexArray = array.from(index1, index2, index3)\n    array<float> priceArray = array.from(price1, price2, price3)\n    // Convert each array's data to strings and join them with different separators.\n    string joined1 = array.join(tickerArray, \", \")\n    string joined2 = indexArray.join(\"|\")\n    string joined3 = priceArray.join(\"\\n\")\n    //@variable A joined \"string\" containing the joined1, joined2, and joined3 values.\n    string displayText = array.from(joined1, joined2, joined3).join(\"\\n---\\n\")\n    // Initialize a cell to show the displayText.\n    displayTable.cell(0, 0, displayText, text_color = color.white, text_size = 36)\n\nNote that:\n\n- Each array.join() call inserts the specified separator only between each element string. It does _not_ include the separator at the start or end of the returned value.\n- The array.join() function uses the same numeric format as the default for str.tostring(). See the String conversion and formatting section of the Strings page to learn more.\n- Calls to array.join() cannot directly convert elements of “bool”, “color”, or other types to strings. Scripts must convert data of these types separately.\n\nSorting\n\nScripts can sort arrays containing “int”, “float”, or “string” elements in ascending or descending order using the array.sort() function. The direction in which the function sorts the array’s elements depends on its order parameter, which accepts the order.ascending or order.descending constants. The default argument is order.ascending, meaning the function sorts the elements in ascending order of value.\n\nThe function sorts arrays of “int” and “float” elements based on their _numeric_ values.\n\nThe example below declares two arrays with references assigned to the a and b variables, and it concatenates those arrays to form a combined c array. The script creates Pine Logs showing formatted text representing the unsorted arrays, and the results of using array.sort() to sort all three arrays in ascending and descending order:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Sorting numeric arrays demo\")\nif barstate.isfirst\n    //@variable A formatting string.\n    string formatString = \"\\n{0}:\\n{1}\\n{2}\\n{3}\"\n    // Create two three-element arrays.\n    array<float> a = array.from(2.1, 0.5, 1.2)\n    array<float> b = array.from(0.1, 1.4, 0.6)\n    //@variable A combined array containing the elements from a and b.\n    array<float> c = array.copy(a).concat(b)\n    // Log formatted text showing the unsorted a, b, and c arrays.\n    log.info(formatString, \"Unsorted\", a, b, c)\n    // Sort the a, b, and c arrays in ascending order (default).\n    array.sort(a)\n    array.sort(b)\n    c.sort()\n    // Log formatted text showing the a, b, and c arrays sorted in ascending order.\n    log.info(formatString, \"Ascending\", a, b, c)\n    // Sort the a, b, and c arrays in descending order.\n    a.sort(order.descending)\n    b.sort(order.descending)\n    c.sort(order.descending)\n    // Log formatted text showing the a, b, and c arrays sorted in descending order.\n    log.info(formatString, \"Descending\", a, b, c)\n\nNote that:\n\n- Each array.sort() call directly _modifies_ the order of the elements in the original array. To get sorted elements _without_ reorganizing the original array, use the array.sort\\_indices() function. This function returns a new array of “int” values representing the _indices_ of the elements sorted in ascending or descending order.\n\nThe array.sort() function sorts arrays of “string” values based on the _Unicode values_ of their characters. The sorting algorithm starts with each element’s _first_ character position, then successively uses additional characters if multiple elements have matching characters at the same position.\n\nThis example creates an array of arbitrary strings on the first bar, then sorts the array’s contents in ascending order with an array.sort() call. The script logs formatted representations of the array in the Pine Logs pane before and after calling the array.sort() function:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Sorting string arrays demo\")\nif barstate.isfirst\n    //@variable An array of arbitrary \"string\" values.\n    array<string> stringArray = array.from(\"abC\", \"Abc\", \"ABc\", \"ABC\", \"!\", \"123\", \"12.3\", \" \")\n    // Log the original stringArray.\n    log.info(\"Unsorted: {0}\", stringArray)\n    // Sort the array in ascending order (default) and log the result.\n    stringArray.sort()\n    log.info(\"Ascending: {0}\", stringArray)\n\nNote that:\n\n- Whitespace and control characters have lower Unicode values than other characters, which is why the \" \" element appears first in the sorted array.\n- Some ASCII punctuation marks and symbols have lower Unicode values than digit or letter characters. The \"!\" element comes before the elements with word characters because its Unicode value is U+0021. However, some other ASCII punctuation and symbol characters, such as the Left Curly Bracket { (U+007B), have higher Unicode values than ASCII digits and letters.\n- ASCII digits have lower Unicode values than letter characters. For example, the 1 character’s value is U+0031, and the A character’s value is U+0041.\n- Uppercase ASCII letters come _before_ lowercase characters in the Unicode Standard. For instance, the a character has the Unicode value U+0061, which is larger than the value for A.\n\nReversing\n\nUse\narray.reverse()\nto reverse an array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.reverse()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\nif barstate.islast\n    array.reverse(a)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a))\n\nSlicing\n\nSlicing an array using\narray.slice()\ncreates a shallow copy of a subset of the parent array. You determine\nthe size of the subset to slice using the index_from and index_to\nparameters. The index_to argument must be one greater than the end of\nthe subset you want to slice.\n\nThe shallow copy created by the slice acts like a window on the parent\narray’s content. The indices used for the slice define the window’s\nposition and size over the parent array. If, as in the example below, a\nslice is created from the first three elements of an array (indices 0 to\n2), then regardless of changes made to the parent array, and as long as\nit contains at least three elements, the shallow copy will always\ncontain the parent array’s first three elements.\n\nAdditionally, once the shallow copy is created, operations on the copy\nare mirrored on the parent array. Adding an element to the end of the\nshallow copy, as is done in the following example, will widen the window\nby one element and also insert that element in the parent array at index\n3\\. In this example, to slice the subset from index 0 to index 2 of array\na, we must use sliceOfA = array.slice(a, 0, 3):\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.slice()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 3)\nif barstate.islast\n    // Create a shadow of elements at index 1 and 2 from array a.\n    sliceOfA = array.slice(a, 0, 3)\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA))\n    // Remove first element of parent array a.\n    array.remove(a, 0)\n    // Add a new element at the end of the shallow copy, thus also affecting the original array a.\n    array.push(sliceOfA, 4)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA), style = label.style_label_up)\n\nSearching arrays\n\nWe can test if a value is part of an array with the\narray.includes()\nfunction, which returns true if the element is found. We can find the\nfirst occurrence of a value in an array by using the\narray.indexof()\nfunction. The first occurence is the one with the lowest index. We can\nalso find the last occurrence of a value with\narray.lastindexof():\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Searching in arrays\")\nvalueInput = input.int(1)\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 1)\nif barstate.islast\n    valueFound      = array.includes(a, valueInput)\n    firstIndexFound = array.indexof(a, valueInput)\n    lastIndexFound  = array.lastindexof(a, valueInput)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a) +\n      \"\\nFirst \" + str.tostring(valueInput) + (firstIndexFound != -1 ? \" value was found at index: \" + str.tostring(firstIndexFound) : \" value was not found.\") +\n      \"\\nLast \" + str.tostring(valueInput)  + (lastIndexFound  != -1 ? \" value was found at index: \" + str.tostring(lastIndexFound) : \" value was not found.\"))\n\nWe can also perform a binary search on an array but note that performing\na binary search on an array means that the array will first need to be\nsorted in ascending order only. The\narray.binary\\_search()\nfunction will return the value’s index if it was found or -1 if it\nwasn’t. If we want to always return an existing index from the array\neven if our chosen value wasn’t found, then we can use one of the other\nbinary search functions available. The\narray.binary\\_search\\_leftmost()\nfunction, which returns an index if the value was found or the first\nindex to the left where the value would be found. The\narray.binary\\_search\\_rightmost()\nfunction is almost identical and returns an index if the value was found\nor the first index to the right where the value would be found.\n\nError handling\n\nMalformed array.*() call syntax in Pine scripts will cause the usual\ncompiler error messages to appear in Pine Editor’s console, at the\nbottom of the window, when you save a script. Refer to the Pine Script\nv6 Reference\\\\\nManual when in\ndoubt regarding the exact syntax of function calls.\n\nScripts using arrays can also throw runtime errors, which appear as\nan exclamation mark next to the indicator’s name on the chart. We\ndiscuss those runtime errors in this section.\n\nIndex xx is out of bounds. Array size is yy\n\nThis error is the most frequent one programmers encounter when using arrays. The error occurs when the script references a _nonexistent_ array index. The “xx”\nvalue represents the out-of-bounds index the function tried to use, and “yy” represents the array’s size. Recall that array indices start at zero — not one — and end at the array’s size, minus one. For instance, the last valid index in a three-element array is 2.\n\nTo avoid this error, you must make provisions in your code logic to prevent using an index value outside the array’s boundaries. This code example generates the error because the last i value in the loop’s iterations is beyond the valid index range for the a array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Out of bounds index\")\na = array.new<float>(3)\nfor i = 1 to 3\n    array.set(a, i, i)\nplot(array.pop(a))\n\nTo resolve the error, last i value in the loop statement should be less than or equal to 2:\n\nPine Script®\nCopied\n\nfor i = 0 to 2\n\nTo iterate over all elements in an array of _unknown_ size with a for loop, set the loop counter’s final value to one less than the array.size() value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected for loop\")\nsizeInput = input.int(0, \"Array size\", minval = 0, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\n    array.set(a, i, i)\nplot(array.pop(a))\n\nWhen sizing arrays dynamically using a field in the script’s\n_Settings/Inputs_ tab, protect the boundaries of that value using\ninput.int()‘s\nminval and maxval parameters:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected array size\")\nsizeInput = input.int(10, \"Array size\", minval = 1, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to sizeInput - 1\n    array.set(a, i, i)\nplot(array.size(a))\n\nSee the Looping through array elements\nsection of this page for more information.\n\nCannot call array methods when ID of array is ‘na’\n\nWhen an array ID is initialized to na, operations on it are not\nallowed, since no array exists. All that exists at that point is an\narray variable containing the na value rather than a valid array ID\npointing to an existing array. Note that an array created with no\nelements in it, as you do when you use a = array.new_int(0), has a\nvalid ID nonetheless. This code will throw the error we are discussing:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Array methods on na array\")\narray<int> a = na\narray.push(a, 111)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a))\n\nTo avoid it, create an array with size zero using:\n\nPine Script®\nCopied\n\narray<int> a = array.new_int(0)\n\nor:\n\nPine Script®\nCopied\n\na = array.new_int(0)\n\nArray is too large. Maximum size is 100000\n\nThis error will appear if your code attempts to declare an array with a\nsize greater than 100,000. It will also occur if, while dynamically\nappending elements to an array, a new element would increase the\narray’s size past the maximum.\n\nCannot create an array with a negative size\n\nWe haven’t found any use for arrays of negative size yet, but if you\never do, we may allow them :)\n\nCannot use shift() if array is empty.\n\nThis error will occur if\narray.shift()\nis called to remove the first element of an empty array.\n\nCannot use pop() if array is empty.\n\nThis error will occur if\narray.pop()\nis called to remove the last element of an empty array.\n\nIndex ‘from’ should be less than index ‘to’\n\nWhen two indices are used in functions such as\narray.slice(),\nthe first index must always be smaller than the second one.\n\nSlice is out of bounds of the parent array\n\nThis message occurs whenever the parent array’s size is modified in\nsuch a way that it makes the shallow copy created by a slice point\noutside the boundaries of the parent array. This code will reproduce it\nbecause after creating a slice from index 3 to 4 (the last two elements\nof our five-element parent array), we remove the parent’s first\nelement, making its size four and its last index 3. From that moment on,\nthe shallow copy which is still pointing to the “window” at the parent\narray’s indices 3 to 4, is pointing out of the parent array’s\nboundaries:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Slice out of bounds\")\na = array.new<float>(5, 0)\nb = array.slice(a, 3, 5)\narray.remove(a, 0)\nc = array.indexof(b, 2)\nplot(c)\n`\n\nPrevious\\\\\nMethods Next\\\\\nMatrices",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[var/varip ][array<type>/<type[]> ]<identifier> = <expression>"
    ]
  },
  "dad4fa3d": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nObjects\n\nIntroduction\n\nPine Script objects are instances of _user-defined types_ (UDTs). They\nare the equivalent of variables containing parts called _fields_, each\nable to hold independent values that can be of various types.\n\nExperienced programmers can think of UDTs as methodless classes. They\nallow users to create custom types that organize different values under\none logical entity.\n\nCreating objects\n\nBefore an object can be created, its type must be defined. The\nUser-defined types section of the\nType system page\nexplains how to do so.\n\nLet’s define a pivotPoint type to hold pivot information:\n\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar\\_time\n\nNote that:\n\n- We use the\ntype\nkeyword to declare the creation of a UDT.\n- We name our new UDT pivotPoint.\n- After the first line, we create a local block containing the type\nand name of each field.\n- The x field will hold the x-coordinate of the pivot. It is\ndeclared as an “int” because it will hold either a timestamp or a\nbar index of “int” type.\n- y is a “float” because it will hold the pivot’s price.\n- xloc is a field that will specify the units of x:\nxloc.bar\\_index\nor\nxloc.bar\\_time.\nWe set its default value to\nxloc.bar\\_time\nby using the = operator. When an object is created from that UDT,\nits xloc field will thus be set to that value.\n\nNow that our pivotPoint UDT is defined, we can proceed to create\nobjects from it. We create objects using the UDT’s new() built-in\nmethod. To create a new foundPoint object from our pivotPoint UDT,\nwe use:\n\nfoundPoint = pivotPoint.new()\n\nWe can also specify field values for the created object using the\nfollowing:\n\nfoundPoint = pivotPoint.new(time, high)\n\nOr the equivalent:\n\nfoundPoint = pivotPoint.new(x = time, y = high)\n\nAt this point, the foundPoint object’s x field will contain the\nvalue of the\ntime\nbuilt-in when it is created, y will contain the value of\nhigh\nand the xloc field will contain its default value of\nxloc.bar\\_time\nbecause no value was defined for it when creating the object.\n\nObject placeholders can also be created by declaring\nna\nobject names using the following:\n\npivotPoint foundPoint = na\n\nThis example displays a label where high pivots are detected. The pivots\nare detected legsInput bars after they occur, so we must plot the\nlabel in the past for it to appear on the pivot:\n\n//@version=6\nindicator(\"Pivot labels\", overlay = true)\nint legsInput = input(10)\n\n// Define the \\pivotPoint\\ UDT.\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar\\_time\n\n// Detect high pivots.\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\nif not na(pivotHighPrice)\n// A new high pivot was found; display a label where it occurred \\legsInput\\ bars back.\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\nlabel.new(\nfoundPoint.x,\nfoundPoint.y,\nstr.tostring(foundPoint.y, format.mintick),\nfoundPoint.xloc,\ntextcolor = color.white)\n\nTake note of this line from the above example:\n\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nThis could also be written using the following:\n\npivotPoint foundPoint = na\nfoundPoint := pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nWhen using the\nvar\nkeyword while declaring a variable assigned to an object of a\nuser-defined type, the keyword automatically applies to all the object’s\nfields:\n\n//@version=6\nindicator(\"Objects using \\var\\ demo\")\n\n//@type A custom type to hold index, price, and volume information.\ntype BarInfo\nint index = bar\\_index\nfloat price = close\nfloat vol = volume\n\n//@variable A \\BarInfo\\ instance whose fields persist through all iterations, starting from the first bar.\nvar BarInfo firstBar = BarInfo.new()\n//@variable A \\BarInfo\\ instance declared on every bar.\nBarInfo currentBar = BarInfo.new()\n\n// Plot the \\index\\ fields of both instances to compare the difference.\nplot(firstBar.index)\nplot(currentBar.index)\n\nIt’s important to note that assigning an object to a variable that uses\nthe\nvarip\nkeyword does _not_ automatically allow the object’s fields to persist\nwithout rolling back on each _intrabar_ update. One must apply the\nkeyword to each desired field in the type declaration to achieve this\nbehavior. For example:\n\n//@version=6\nindicator(\"Objects using \\varip\\ fields demo\")\n\n//@type A custom type that counts the bars and ticks in the script's execution.\ntype Counter\nint bars = 0\nvarip int ticks = 0\n\n//@variable A \\Counter\\ object whose reference persists throughout all bars.\nvar Counter counter = Counter.new()\n\n// Add 1 to the \\bars\\ and \\ticks\\ fields. The \\ticks\\ field is not subject to rollback on unconfirmed bars.\ncounter.bars += 1\ncounter.ticks += 1\n\n// Plot both fields for comparison.\nplot(counter.bars, \"Bar counter\", color.blue, 3)\nplot(counter.ticks, \"Tick counter\", color.purple, 3)\n\nNote that:\n\n- We used the\nvar\nkeyword to specify that the Counter object assigned to the\ncounter variable persists throughout the script’s execution.\n- The bars field rolls back on realtime bars, whereas the\nticks field does not since we included\nvarip\nin its declaration.\n\nChanging field values\n\nThe value of an object’s fields can be changed using the\n:=\nreassignment operator.\n\nThis line of our previous example:\n\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nCould be written using the following:\n\nfoundPoint = pivotPoint.new()\nfoundPoint.x := time\\[legsInput\\]\nfoundPoint.y := pivotHighPrice\n\nCollecting objects\n\nPine Script collections ( arrays, matrices, and maps) can contain\nobjects, allowing users to add virtual dimensions to their data\nstructures. To declare a collection of objects, pass a UDT name into its\ntype template.\n\nThis example declares an empty\narray\nthat will hold objects of a pivotPoint user-defined type:\n\npivotHighArray = array.new<pivotPoint>()\n\nTo explicitly declare the type of a variable as an\narray,\nmatrix,\nor map\nof a\nuser-defined type, use the collection’s type keyword followed by its\ntype template. For example:\n\nvar array<pivotPoint> pivotHighArray = na\npivotHighArray := array.new<pivotPoint>()\n\nLet’s use what we have learned to create a script that detects high\npivot points. The script first collects historical pivot information in\nan\narray.\nIt then loops through the array on the last historical bar, creating a\nlabel for each pivot and connecting the pivots with lines:\n\n//@version=6\nindicator(\"Pivot Points High\", overlay = true)\n\nint legsInput = input(10)\n\n// Define the \\pivotPoint\\ UDT containing the time and price of pivots.\ntype pivotPoint\nint openTime\nfloat level\n\n// Create an empty \\pivotPoint\\ array.\nvar pivotHighArray = array.new<pivotPoint>()\n\n// Detect new pivots (\\na\\ is returned when no pivot is found).\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\n\n// Add a new \\pivotPoint\\ object to the end of the array for each detected pivot.\nif not na(pivotHighPrice)\n// A new pivot is found; create a new object of \\pivotPoint\\ type, setting its \\openTime\\ and \\level\\ fields.\nnewPivot = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n// Add the new pivot object to the array.\narray.push(pivotHighArray, newPivot)\n\n// On the last historical bar, draw pivot labels and connecting lines.\nif barstate.islastconfirmedhistory\nvar pivotPoint previousPoint = na\nfor eachPivot in pivotHighArray\n// Display a label at the pivot point.\nlabel.new(eachPivot.openTime, eachPivot.level, str.tostring(eachPivot.level, format.mintick), xloc.bar\\_time, textcolor = color.white)\n// Create a line between pivots.\nif not na(previousPoint)\n// Only create a line starting at the loop's second iteration because lines connect two pivots.\nline.new(previousPoint.openTime, previousPoint.level, eachPivot.openTime, eachPivot.level, xloc = xloc.bar\\_time)\n// Save the pivot for use in the next iteration.\npreviousPoint := eachPivot\n\nCopying objects\n\nIn Pine, objects are assigned by reference. When an existing object is\nassigned to a new variable, both point to the same object.\n\nIn the example below, we create a pivot1 object and set its x field\nto 1000. Then, we declare a pivot2 variable containing the reference\nto the pivot1 object, so both point to the same instance. Changing\npivot2.x will thus also change pivot1.x, as both refer to the x\nfield of the same object:\n\n//@version=6\nindicator(\"\")\ntype pivotPoint\nint x\nfloat y\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivot1\npivot2.x := 2000\n// Both plot the value 2000.\nplot(pivot1.x)\nplot(pivot2.x)\n\nTo create a copy of an object that is independent of the original, we\ncan use the built-in copy() method in this case.\n\nIn this example, we declare the pivot2 variable referring to a copied\ninstance of the pivot1 object. Now, changing pivot2.x will not\nchange pivot1.x, as it refers to the x field of a separate object:\n\n//@version=6\nindicator(\"\")\ntype pivotPoint\nint x\nfloat y\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivotPoint.copy(pivot1)\npivot2.x := 2000\n// Plots 1000 and 2000.\nplot(pivot1.x)\nplot(pivot2.x)\n\nIt’s important to note that the built-in copy() method produces a\n_shallow copy_ of an object. If an object has fields with _special_\n_types_\n( array,\nmatrix,\nmap,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point),\nthose fields in a shallow copy of the object will point to the same\ninstances as the original.\n\nIn the following example, we have defined an InfoLabel type with a\nlabel as one of its fields. The script instantiates a shallow copy of\nthe parent object, then calls a user-defined set() method to update the\ninfo and lbl fields of each object. Since the lbl field of both\nobjects points to the same label instance, changes to this field in\neither object affect the other:\n\n//@version=6\nindicator(\"Shallow Copy\")\n\ntype InfoLabel\nstring info\nlabel lbl\n\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set\\_x(x)\nif not na(y)\nthis.lbl.set\\_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set\\_text(this.info)\n\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar shallow = parent.copy()\n\nparent.set(bar\\_index, 0, \"Parent\")\nshallow.set(bar\\_index, 1, \"Shallow Copy\")\n\nTo produce a _deep copy_ of an object with all of its special type\nfields pointing to independent instances, we must explicitly copy those\nfields as well.\n\nIn this example, we have defined a deepCopy() method that instantiates\na new InfoLabel object with its lbl field pointing to a copy of the\noriginal’s field. Changes to the deep copy’s lbl field will not\naffect the parent object, as it points to a separate instance:\n\n//@version=6\nindicator(\"Deep Copy\")\n\ntype InfoLabel\nstring info\nlabel lbl\n\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set\\_x(x)\nif not na(y)\nthis.lbl.set\\_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set\\_text(this.info)\n\nmethod deepCopy(InfoLabel this) =>\nInfoLabel.new(this.info, this.lbl.copy())\n\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar deep = parent.deepCopy()\n\nparent.set(bar\\_index, 0, \"Parent\")\ndeep.set(bar\\_index, 1, \"Deep Copy\")\n\nShadowing\n\nTo avoid potential conflicts in the eventuality where namespaces added\nto Pine Script in the future would collide with UDTs or object names in\nexisting scripts; as a rule, UDTs and object names shadow the\nlanguage’s namespaces. For example, a UDT or object can use the name of\nbuilt-in types, such as\nline\nor\ntable.\n\nOnly the language’s five primitive types cannot be used to name UDTs or\nobjects:\nint,\nfloat,\nstring,\nbool,\nand\ncolor.\n\nPrevious\\\\\nUser-defined functions Next\\\\\nEnums",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": []
  },
  "9eef8744": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "Execution model\n\nIntroduction\n\nPine Script® relies on an event-driven, sequential execution model to control how a script’s compiled source code runs in charts, alerts, Deep Backtesting mode, and the Pine Screener.\n\nIn contrast to the traditional execution model of most programming languages, Pine’s runtime system executes a script _repeatedly_ on the sequence of _historical bars_ and _realtime ticks_ in the dataset on which it runs, performing _separate_ calculations for _each bar_ as it progresses. After each execution on a closed bar, the necessary data from that execution becomes part of an internal time series, and the script can use that data in its calculations on subsequent bars.\n\nThis combination of sequential executions and storage enables programmers to use minimal code to write scripts with dynamic calculations that advance across a dataset bar by bar.\n\nThe execution model and time series structure closely connect to the type system — together, they define how a script behaves as it runs on a dataset. Although it’s possible to write simple scripts without understanding these foundational topics, learning about them and their nuances is key to becoming proficient in Pine Script.\n\nThis page explains the execution model in two parts: The basics and The details. The first part provides quick, actionable information about the model for beginners. The second part offers an _advanced_, in-depth breakdown of the model’s workings and unique behaviors. To make the most of the information on this page, we recommend that newcomers to Pine Script start with The basics, learn about other topics in this manual, and then come back to this page for the advanced details.\n\nThe basics\n\nThe following sections outline core principles of the execution model for beginners. If you are new to Pine Script, start here.\n\nBar-by-bar execution\n\nThe dataset for a symbol on a given timeframe, as shown on a chart, consists of a sequence of bars representing a _time series_. Each bar in the sequence represents the price and volume for a specific time period. The first (leftmost) bar on a chart corresponds to the _earliest_ period, and the last (rightmost) bar corresponds to the _most recent_ period.\n\nMuch of the power of Pine Script stems from its ability to process this time series data efficiently. When a user runs a script, its code does _not_ execute just once; it executes from start to end on _each bar_ in the symbol’s dataset individually, progressing from the first available bar to the most recent bar. Each separate script execution performs calculations or generates outputs (e.g., plots) for a _specific bar_ using the data available on that bar.\n\nA script can retrieve price, volume, and other essential data for each bar on which it executes by using the built-in variables that hold bar information, such as open, high, low, close, and volume. These variables automatically _update_ before each new execution to store the values for the _current bar_.\n\nFor example, the simple script below uses the plot() function to display the series of close values (i.e., the closing price of each bar) on the chart:\n\n//@version=6\nindicator(\"Bar-by-bar execution demo\", overlay = true, behind\\_chart = false)\n\n// Plot the \\close\\ series on the chart.\n// This call defines the plotted point for the current bar on each execution.\nplot(close, \"Close price\", chart.fg\\_color, 5)\n\nWhen a user first adds this script to their chart, its code executes _once_ for _every bar_ in the available dataset. As the script runs on the data, two primary steps occur on each bar:\n\n1. The close variable automatically updates to hold the current bar’s latest price.\n2. The plot() function call plots the updated close value at the current bar’s position.\n\nWhen the script finishes its run from the first bar to the most recent bar, the result is a simple _line plot_ showing the progression of closing prices across the chart’s history:\n\nNote that the above script evaluates the plot() function call once for every bar on the chart, not just once in total. On each separate execution, the call defines the plotted point for the current bar: the chart’s first bar during the first execution, the second bar during the next, and so on.\n\nThis pattern illustrates a key principle of Pine’s execution model: on each successive execution, a script _re-evaluates_ function calls and other expressions within its required _scopes_ to perform separate calculations for the current bar.\n\nRepeated code evaluation also applies to variable declarations. By default, a script does not declare a variable only once throughout its runtime; the script _re-declares_ that variable and assigns an initial value based on the current bar’s data during _each_ new evaluation of its scope.\n\nLet’s look at a simple example. The following script declares an x variable of the “int” type with an initial value of 0. Then, it increases the variable’s value by 10 with the addition assignment operator ( +=). The script calls plot() to display the value of x on each bar in a separate pane:\n\n//@version=6\nindicator(\"Repeated declarations demo\")\n\n//@variable A user-defined variable. The script declares this variable and initializes it to 0 on \\every\\ execution.\nint x = 0\n\n// Increase the value of \\x\\ by 10 on every bar.\nx += 10\n\n// Plot the value of \\x\\.\n// Because \\x\\ begins at 0 on every execution, and the script adds 10 to that value, the plotted value is always 10.\nplot(x, \"\\x\\ value\", color.blue, 3)\n\nAs shown above, the script plots a value of 10 on every bar, because the x variable _does not_ carry over from bar to bar; the script declares the variable _repeatedly_. On each bar, the script re-declares x with an initial value of 0, then adds 10 to that value, resulting in a final value of 10 for every plotted point.\n\nProgrammers can change the behavior of a variable, enabling it to _persist_ and preserve updates to its value _across bars_, by including the var keyword in its declaration, as described in the Declaration modes section of the Variable declarations page.\n\nBelow, we modify the previous script by adding var to the x declaration. Now, the script declares and initializes x only _once_ — on the _first bar_ — and that variable persists across _all_ bars that follow. The script now plots a line that _increases_ by 10 on each bar, because x preserves the result from each addition across the chart’s history. The value changes from 0 to 10 on the first bar, then to 20 on the second, and so on:\n\n//@version=6\nindicator(\"Persistent declarations demo\")\n\n//@variable A \\persistent\\ variable. The script initializes this variable only on the \\first execution\\.\n// The variable preserves all changes to its value on each closed bar.\nvar int x = 0\n\n// Increase the value of \\x\\ by 10 on every bar.\nx += 10\n\n// Plot the \\x\\ series on the chart.\n// Because the script declares \\x\\ using \\var\\ and then increments its value, the value never resets to 0.\n// The plotted value is 10 on the first bar, 20 on the next, and so on.\nplot(x, \"\\x\\ series\", color.blue, 3)\n\nStoring and using data from previous bars\n\nAs a script runs on a dataset, the states of its variables, function calls, and other expressions are automatically _committed (saved)_ to an internal _time series_ on each bar, creating historical trails of previous bar values that the script can access during its calculations on the current bar. The script can use these previous values by doing either of the following:\n\n- Using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The number in the square brackets represents how many _bars back_ from the current bar the script looks to retrieve a past value. For instance, close[1] retrieves the close value from _one bar before_ the current bar, and close[100] retrieves the value from _100 bars back_.\n- Calling the built-in functions that calculate on past values internally, such as ta.*() functions. For instance, ta.change(close, 10) calculates the difference between the current value of close and its value from 10 bars back.\n\nThe example below uses both of the above techniques to perform calculations based on data from previous bars. The script calculates a series of bar-by-bar price returns and plots the result as color-coded columns. It declares two global variables on each bar: priceReturn for the calculated returns, and returnColor for the plot’s color. The priceReturn value is the result of dividing the current one-bar change in closing prices ( ta.change(close, 1)) by the previous bar’s closing price ( close[1]). The returnColor value is color.teal if the current value of priceReturn is higher than the value from the previous bar ( priceReturn[1]), and color.maroon otherwise:\n\n//@version=6\nindicator(\"Storing and using data from previous bars demo\")\n\n//@variable The one-bar price return, based on the current and \\previous\\ bars' \\close\\ values.\n// This variable's final value on each bar automatically becomes part of the internal time series.\nfloat priceReturn = ta.change(close, 1) / close\\[1\\]\n\n//@variable Is \\color.teal\\ if the \\priceReturn\\ value is above the value on the previous bar; \\color.maroon\\ otherwise.\ncolor returnColor = priceReturn > priceReturn\\[1\\] ? color.teal : color.maroon\n\n// Plot the current \\priceReturn\\ value as a column, colored using the value of \\returnColor\\.\nplot(priceReturn, \"Price return\", returnColor, 1, plot.style\\_columns)\n\nNote that:\n\n- This script does _not_ plot a column on bar 0 (the _first_ bar). The priceReturn value is na on that bar, because there is _no previous bar_ available for the script to reference at that point.\n\nRealtime bars\n\nWhen a script first runs on a chart, all _closed_ bars in the accessed dataset are _historical bars_. These bars represent data for elapsed time periods where the final price and volume are _confirmed_. All indicators execute once per historical bar.\n\nWhen the rightmost bar on the chart is _open_, it is a _realtime bar_. Unlike a historical bar, whose values are final, a realtime bar _updates_ its values as new price or volume data becomes available. After the bar closes, it becomes an _elapsed realtime bar_, which is then no longer subject to change as the script runs.\n\nBecause the final values for a realtime bar are _unknown_ until the bar closes, an indicator executes differently on that bar than it does on historical bars. The script executes not once, but repeatedly on the realtime bar — once for each new _update (tick)_ — to _recalculate_ its results using the latest data.\n\nBefore each recalculation on the realtime bar, the data for a script’s variables, expressions, and outputs on that bar is _cleared_, or _reset_. We refer to this process as _rollback_. The purpose of rollback is to revert the script to the same confirmed state it had when the realtime bar opened. This process ensures that the script’s calculations for the bar operate only on the latest available data, without relying on _temporary data_ from the bar’s _previous ticks_.\n\nLet’s look at rollback and recalculation in action. The following script uses ta.stoch() to calculate the Stochastic oscillator based on the close, high, and low values over a specified number of bars, then plots the result in a separate pane. It also calls bgcolor() to highlight the background on each realtime bar — where barstate.isrealtime is true — for visual reference:\n\n//@version=6\nindicator(\"Recalculation on realtime bars demo\")\n\n//@variable The number of bars in the Stochastic calculation. Users can change this value in the \"Settings/Inputs\" tab.\nint lengthInput = input.int(10, \"Length\", 1)\n\n//@variable The Stochastic oscillator, based on the \\close\\, \\high\\, and \\low\\ values over \\lengthInput\\ bars.\nfloat stochastic = ta.stoch(close, high, low, lengthInput)\n\n// Plot the \\stochastic\\ value for each bar.\nplot(stochastic, \"Stochastic %K\", color.teal, 3)\n// Highlight the background of each realtime bar.\nbgcolor(barstate.isrealtime ? color.new(color.purple, 80) : na, title = \"Realtime background highlight\")\n\nWhen we add the script to our chart, it executes once per bar in the chart’s history, from the leftmost bar to the rightmost bar. However, the rightmost bar on our chart is still _open_. Therefore, it is a _realtime bar_, not a historical bar. After the script reaches that bar, it begins executing once for _every new update_ to the bar’s data. Each new script execution calculates on the latest available prices and _replaces_ the bar’s previous result.\n\nFor instance, in the initial image below, the oscillator’s value 10 seconds into the open realtime bar (the one with the purple background) is 32.08:\n\nEvery time the bar updates, rollback _resets_ the script’s data for that bar, and the script _recalculates_ its result using the latest high, low, and close values. Here, halfway through the realtime bar’s period, the oscillator’s plot now shows a value of 16.71:\n\nRecalculation continues for each successive update to the bar. Then, the script reaches the bar’s closing tick, where the prices become _confirmed_. On that tick, the script calculates the oscillator’s final value of 19.35. Afterward, another realtime bar opens, and the pattern of rollback and recalculation continues on that bar:\n\nNote that:\n\n- Only the values for a realtime bar’s _final tick_ become part of the internal time series. The values from ticks _before_ the bar’s close are not saved.\n- The input.int() function returns a value of the “input int” _qualified type_. Values qualified as “input” are established _before_ the first script execution, and they remain consistent throughout the script’s runtime. If the user changes the “Length” input to a new value, the script _restarts_ to perform new calculations across the dataset using that value. See the Inputs page and the Qualifiers section of the Type system page to learn more about script inputs and the “input” qualifier.\n- If the script restarts, all the realtime bars from the previous script run become _historical bars_ in the new run. Therefore, after restarting, the script executes only once on each of those bars and does _not_ highlight their background.\n\nThe details\n\nThe following sections provide in-depth details about Pine’s execution model, including the mechanics of executions on historical bars and realtime bars, which events trigger script executions, and how the runtime system maintains data across executions in a time series format.\n\nExecutions on historical bars\n\nWhen a script loads on the chart or in another location after an execution-triggering event, its compiled source code executes on _every_ accessible bar in the current dataset in order, starting with the first bar.\n\nWhile the script loads, the runtime system performs the following steps for _each bar_ that it accesses:\n\n1. It updates the built-in variables that hold bar information. For instance, the system sets the open, high, low, and close variables to hold the OHLC price values of the bar _before_ each execution.\n2. It executes the script’s compiled code from start to end using the data available as of the current bar.\n3. After the execution ends, the system commits (saves) all necessary data for the current bar to the time series. The script can then access that data from historical buffers during its executions on subsequent bars by using the history-referencing operator or the built-in functions that reference past bars internally.\n\nThese steps repeat for every successive bar up to the most recent bar. After the runtime system completes this process across the dataset, the script’s committed _outputs_ — such as plots, drawings, Pine Logs, and Strategy Tester results — become available to the user.\n\nAll the closed bars on which the script executes while loading are _historical_, because they represent data points that were confirmed before the event that triggered the loading process. By default, all scripts execute once for each historical bar.\n\nLet’s examine a simple indicator to understand how script executions work on historical bars.\n\nThe script below calculates the 20-bar moving average of close values and plots the result on the chart. The color of the plot depends on whether the average is above or below the value on the previous bar. The script also increments an executionNum variable to count code executions, then plots the result alongside bar\\_index for comparison. Additionally, it highlights the background of historical bars in orange for visual reference:\n\n//@version=6\nindicator(\"Executions on historical bars demo\")\n\n//@variable The average of the latest 20 \\close\\ values.\nfloat sma = ta.sma(close, 20)\n\n//@variable Is \\color.green\\ if the \\sma\\ value is above the value on the previous bar; \\color.red\\ otherwise.\ncolor plotColor = sma > sma\\[1\\] ? color.green : color.red\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\sma\\ as a line plot on the main chart pane, colored by the \\plotColor\\.\nplot(sma, \"SMA\", plotColor, 3, force\\_overlay = true)\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nThe statements and expressions in this source code might appear static at first glance. However, they have _dynamic_ behavior across bars because the system executes the script _repeatedly_ — once for each successive data point. Below, we inspect the code step by step to explain how the script works during its historical executions.\n\nThe indicator() call at the top of the code is a declaration statement that defines the script’s type and properties once, at _compile time_. This statement does not execute as the script runs on the dataset:\n\nindicator(\"Executions on historical bars demo\")\n\n_Before_ each script execution on a bar, the runtime system updates the built-in bar\\_index and close variables required in the calculations. The bar\\_index value is the bar’s global _time series index_, where 0 represents the first bar, 1 represents the second, and so on. The close variable holds the bar’s _latest price_. For historical bars, its value is the _final price_ at the bar’s closing time.\n\nEach time that the script executes, it declares and initializes a global sma variable of the “float” type. This variable declaration happens on _every_ execution because the code line does not specify a declaration mode. The variable’s assigned value is the result of a ta.sma() function call. The call returns the average of the latest 20 close values as of the current bar, or na if fewer than 20 bars are available. After the execution ends, the system commits the new value of sma to the time series:\n\n//@variable The average of the latest 20 \\close\\ values.\nfloat sma = ta.sma(close, 20)\n\nNote that:\n\n- The //@variable comment above the sma declaration is an annotation that _documents_ the variable in the code. The Pine Editor displays the comment in a pop-up window when the user hovers the mouse pointer over the variable.\n\nDuring each execution, the script also initializes a plotColor variable of the “color” type. The script uses a ternary operation that compares the current sma value to sma[1] — the _last committed value_ for sma as of the _previous bar_ — to determine the plotColor variable’s assigned value. If the current sma value is higher than the last committed value, the plotColor value is color.green. Otherwise, it is color.red:\n\n//@variable Is \\color.green\\ if the \\sma\\ value is above the value on the previous bar; \\color.red\\ otherwise.\ncolor plotColor = sma > sma\\[1\\] ? color.green : color.red\n\nIn contrast to the variables above, the script _does not_ initialize the executionNum variable on every execution. Instead, initialization happens only _once_ — on the _first_ bar — because the variable declaration is in the _global scope_ and uses the varip keyword. Once initialized, the variable _persists_ across all subsequent bars and the ticks within those bars. Only the reassignment or compound assignment operators can change its value:\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n\nThe code following the executionNum declaration uses the addition assignment operator ( +=) to increase the variable’s value by one on each new execution. Starting from -1, the value increases to 0 on the first execution after initialization, then 1 on the second, and so on:\n\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\nThe script evaluates the plot() and bgcolor() calls on every execution. Each plot() call creates a new point on a line plot at the bar’s location on the time axis. The bgcolor() call creates a background color for the bar based on a ternary expression. The background is translucent orange if barstate.ishistory is true. Otherwise, it is na (no color):\n\n// Display the \\sma\\ as a line plot on the main chart pane, colored by the \\plotColor\\.\nplot(sma, \"SMA\", plotColor, 3, force\\_overlay = true)\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- The plot() and bgcolor() calls that include force_overlay = true display their visuals on the main chart pane. The other plot() calls\noutput visuals in a separate pane, because the indicator() call does not include overlay = true.\n\nAfter the system executes the script on all available data points and finishes loading, the script’s outputs then become visible on the chart:\n\nNote that:\n\n- When the script first loads, _all_ bars, including the latest one, have an orange background because they initially represent _historical_ data. However, the latest bar on our chart is still open, meaning it is a _realtime bar_. After a new tick arrives from the realtime data feed, the bar’s values update, and the script executes _again_ on that bar. The orange background for the bar then _disappears_ because the system sets the value of barstate.ishistory to false.\n- The executionNum and bar\\_index values are identical on historical bars because the script executes _once per bar_ on that part of the dataset. However, they begin to differ on the realtime bar. On that bar, the script executes after _every new update_ to recalculate its results, and the executionNum value increases each time. See the Executions on realtime bars section to learn more.\n- An alternative, more robust method to track code executions is to use the Pine Profiler. The profiler analyzes the total runtime and execution count of every significant part of the source code. To learn more about this feature, see the Profiling and optimization page.\n\nIt’s important to note that, unlike indicators, strategies can execute _more than once_ per historical bar, depending on the specified calculation behavior. If the strategy() declaration statement includes calc_on_order_fills = true, or if the user selects the “After order is filled” checkbox in the “Settings/Properties” tab, the runtime system executes the script on _each available tick_ where the broker emulator fills an order, or once per bar when there is no order to fill.\n\nLet’s look at a simple example. The following strategy changes the direction of its simulated position on each execution. If there is an open short position or no position, the strategy places a market order to close all short trades and enter a long trade. If a long position is open, the strategy places a market order to close it and open a short trade.\n\nAs with the previous example, this script increments an executionNum variable declared with varip to count new executions, plots the result alongside bar\\_index for comparison, and highlights the background of historical bars in orange with bgcolor():\n\n//@version=6\nstrategy(\"Default strategy behavior on historical bars demo\")\n\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position\\_size <= 0\nstrategy.entry(\"Long\", strategy.long)\nelse\nstrategy.entry(\"Short\", strategy.short)\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- The strategy.entry() command creates entry orders. By default, a long entry using this command reverses an open short position, and a short entry reverses an open long position. See the Reversing positions section of the Strategies page to learn more.\n\nThe script above uses the default calculation behavior: it places a new order only at the close of each bar. The broker emulator fills the order at the next bar’s opening price, as the trade markers on the chart above indicate. The executionNum and bar\\_index plots show the same values because the script executes only once per bar.\n\nIf we include calc_on_order_fills = true in the strategy() declaration statement, the runtime system _re-executes_ the script on a bar after each new order fill to update the calculations. Our script’s logic generates a new order on _every_ execution, and the broker emulator considers historical bars to have _four ticks_ for filling orders by default (the open, high, low, and close). Therefore, with this change, the script executes four times per historical bar instead of only once. As shown below, the strategy now shows four trade markers on each historical bar, and the executionNum value is four times that of the bar\\_index variable:\n\n//@version=6\nstrategy(\"Calculation after order fill on historical bars demo\", calc\\_on\\_order\\_fills = true)\n\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\nif strategy.position\\_size <= 0\nstrategy.entry(\"Long\", strategy.long)\nelse\nstrategy.entry(\"Short\", strategy.short)\n\n//@variable Tracks the current execution number, where 0 represents the first execution.\nvarip int executionNum = -1\n// Add 1 to the \\executionNum\\ value.\nexecutionNum += 1\n\n// Display the \\executionNum\\ and \\bar\\_index\\ series in a separate pane.\nplot(executionNum, \"Execution number\", color.purple, 5)\nplot(bar\\_index, \"Bar index\", color.aqua, 2)\n\n// Highlight the chart's background in translucent orange when \\barstate.ishistory\\ is \\true\\.\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force\\_overlay = true)\n\nNote that:\n\n- This script can execute _more than four_ times per bar if it uses Bar Magnifier mode, because this mode enables the broker emulator to fill orders on historical bars using intrabar prices from a _lower timeframe_.\n- The script can execute numerous times on a _realtime_ bar, depending on the updates from the data feed, because _each new update_ to the bar is a valid tick for filling the strategy’s orders.\n- An alternative way to confirm the script’s increased execution count is to select and clear the “After order is filled” checkbox in the “Settings/Properties” tab while profiling the code.\n\nExecutions on realtime bars\n\nAfter a script running on the chart or in an alert executes across all historical bars in a dataset, the runtime system continues to execute the script on the current bar, if it is open, and on any new bars that form later. We refer to these bars as _realtime bars_, because they represent incoming data from a separate data feed that the script can access only _after_ it finishes loading.\n\nAs explained in the previous section, historical bars represent confirmed data points. By contrast, a realtime bar represents an initially _unconfirmed_ data point that evolves as new updates (ticks) arrive from the realtime data feed. With each new tick, the bar’s high, low, close, volume, and other values update to represent the latest data while the bar remains open. After the bar closes, it becomes an _elapsed realtime bar_, whose values no longer change. Then, a new realtime bar opens after another tick arrives, and that bar updates as new data becomes available.\n\nAs an indicator or library script runs on an open realtime bar, its compiled code executes once after every new update from the data feed. With each new execution, the script recalculates its results for that bar using the latest data. Consequently, the states of the script’s variables, expressions, and objects can _change_ with each new execution while the bar remains open. The system _commits_ the script’s data for the realtime bar only after the bar closes.\n\nAfter each script execution that occurs _before_ a bar’s closing tick, the runtime engine executes a _rollback_ process. Rollback _resets_ applicable script data to the latest committed states in the time series. This process enables the script to recalculate the bar’s results using only the latest available data — without the influence of _temporary_ data from executions on the bar’s previous ticks.\n\nBelow, we explain how recalculation and rollback affect a script’s data and outputs, along with some notable exceptions to this process:\n\nReinitialize variables\n\nThe runtime system erases the states of any variables that the script initializes during its executions before a bar’s close, excluding those declared using the varip keyword. When the script executes again after rollback, it _reinitializes_ the variables with new values or references based on the latest available data.\n\nLikewise, the system does not preserve the _temporary_ states of built-in variables that hold values for the current bar. Before the new script execution, it sets the variables to use the bar’s most recent data. For instance, the system updates close, high, and low with the latest, highest, and lowest prices reported since the bar’s opening time.\n\nReset changes to var variables\n\nVariables that use the var keyword in their declaration are initialized only _once_ — during the _first_ execution of their scopes on a _closed bar_. Variables that use the var keyword in their declaration remain initialized after the _first_ time that their scopes execute on a bar’s _closing tick_. Their assigned values or references _persist_ across subsequent bars, changing only after reassignment or compound assignment operations.\n\nAlthough these variables preserve data across successive bars, they do not preserve data across executions on the _ticks_ of an open bar. Rollback reverts all variables declared with var before the current bar to the last committed states in the time series as of the previous bar.\n\nFor instance, if a variable declared with var has a value of 20 on the open bar and 19 on the previous bar, the variable’s value reverts to 19 before the script executes on the next tick of the same bar. The temporary value of 20 does not persist.\n\nReplace plotted outputs\n\nThe plot*(), bgcolor(), barcolor(), and fill() functions create visual outputs on _every bar_. These outputs are _temporary_ on the open realtime bar. When the script executes again after rollback, the new outputs for the bar from calls to these functions _replace_ the ones from the previous tick.\n\nFor example, when the expression plot(close) executes on the open bar, it displays the bar’s latest close value as of the current execution. However, the plotted result is temporary until the bar closes. After rollback, the close variable updates, then the script calls plot() again on the next execution to replace the output from the previous tick and display the new value.\n\nRemove and revert objects\n\nUser-defined types (UDTs) and special types such as collections and drawing types are _reference types_. They define structures from which scripts create _objects_ — independent entities that store data elsewhere in memory. Variables of these types hold _references_ that provide access to specific objects and their data; the variables do not store objects directly.\n\nIf a script creates objects on an open bar and does not assign their references to variables declared with the varip keyword, the rollback process _removes_ those objects. During the next execution on the open bar, the script creates _new objects_ if the updated logic allows it.\n\nFor example, if a script calls label.new() to create a label object on the open bar, the system _deletes_ that object during rollback. On the next execution, the script evaluates label.new() again, creating a _new_ label that replaces the output. The label created on the previous tick no longer exists.\n\nSimilarly, for objects of built-in or user-defined types with references assigned to var variables, the rollback process reverts any changes to those objects that occur on the open bar. The only exception is for UDTs with _fields_ that include the varip keyword. See the Objects page for more information.\n\nExceptions\n\nThe runtime system does not revert _all_ the data from script executions on an open bar. The following are notable exceptions to the rollback process:\n\n- Variables or fields declared with the varip keyword do not revert to a previously committed state. They persist across _all_ script executions after initialization, even those on the ticks of an open realtime bar.\n- Logged messages in the Pine Logs pane do not disappear after rollback. The messages from any log.*() calls during executions on the ticks of realtime bars remain in the pane until the script reloads.\n- The data from strategy orders placed or filled on the ticks within a bar is not subject to rollback. If a strategy script creates orders or the broker emulator fills orders on an open bar, the data from those events persists.\n- Rollback does not erase logs for alerts from the “Alerts” menu. All messages from a script alert remain visible until the user restarts the alert.\n- Runtime errors from the system or the runtime.error() function completely _stop_ script executions. If an error occurs at any point while a script executes on an open bar, the system halts the script and does not revert the error after new updates from the data feed.\n\nLet’s inspect the behavior of a simple indicator on realtime bars. The following script calculates an RSI of close values using ta.rsi() and displays the result with a plot() call. To track the number of executions that occur _per bar_, the script increments an executions variable declared with varip and calculates its one-bar change using ta.change(). The script converts each bar’s execution count to a string with str.tostring(), then displays the result in a color-coded label at the bar’s high. The label is purple if the bar is open. Otherwise, it is gray. The script also highlights the background of realtime bars in orange using bgcolor():\n\n//@version=6\nindicator(\"Executions on realtime bars demo\")\n\n//@variable The 14-bar RSI of \\close\\ prices.\nfloat rsi = ta.rsi(close, 14)\n\n//@variable Tracks the number of script executions, where 1 represents the first execution.\nvarip int executions = 0\n// Add 1 to the \\executions\\ value.\nexecutions += 1\n\n//@variable Is \\color.gray\\ if the bar is confirmed (closed); \\color.purple\\ otherwise.\ncolor labelColor = barstate.isconfirmed ? color.gray : color.purple\n\n// Calculate the one-bar change in \\executions\\, then convert the value to a string and display the result in a label.\n// Each call to \\label.new()\\ creates a \\new\\ \\label\\ object.\nlabel.new(\nbar\\_index, high, str.tostring(ta.change(executions)),\ncolor = labelColor, textcolor = color.white, size = 20, force\\_overlay = true\n)\n\n// Plot the \\rsi\\ value with colors based on whether the value is above 50 or not.\nplot(rsi, \"RSI\", rsi > 50 ? color.teal : color.maroon, 3)\n\n// Highlight the chart's background in translucent orange when \\barstate.isrealtime\\ is \\true\\.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\", force\\_overlay = true)\n\nWhen we first add the script to the chart, it does _not_ add an orange background to any bar because it calculates only on data that exists at the script’s loading time. This data is _historical_. Each bar’s label shows a value of 1 because indicators always execute _once_ per historical bar:\n\nNotice the countdown timer and the _purple_ label for the latest bar in the chart above. These both indicate that the bar is _open_ and subject to changes. A new update from the data feed affects the bar’s values, triggering rollback and a new script execution to recalculate the results.\n\nWhen rollback occurs, the runtime system reverts the internal data of the ta.rsi() call to its last committed state, erases the state of the rsi variable, and deletes the latest label object. However, the system does not revert the executions variable because it uses the varip keyword.\n\nAfter rollback, the system updates the built-in close, high, and barstate.* variables using the current bar’s latest data, and the new execution begins. The script evaluates the ta.rsi() call using the new close price and reinitializes the rsi variable with the returned value. Then, it increases the executions value by one, evaluates ta.change() again, and creates a new label at the bar’s current high price to show the updated result. Lastly, it evaluates the plot() and bgcolor() calls to replace the bar’s plotted visuals. The last bar’s label remains purple because the bar is still open, but the background color is now _orange_ because barstate.isrealtime is true:\n\nAs subsequent updates become available from the data feed, the pattern of rollback and re-execution continues, and the script’s outputs for the bar update with each new execution:\n\nThe last time that rollback and another execution occur on this bar is after the _closing tick_, when the bar becomes an _elapsed_ realtime bar. After the final execution, the bar’s label is _gray_ because barstate.isconfirmed is true. The runtime system then _commits_ necessary data from this execution to the time series for calculations on future bars.\n\nThen, a new realtime bar opens after another update from the data feed, and the execution pattern continues:\n\nNote that:\n\n- Although the previous bar is now confirmed, it still has an orange background corresponding to a _realtime_ state because it closed after the script’s loading time. When the script later reloads after an execution-triggering event, that bar becomes _historical_.\n\nIt’s important to note that strategies often execute differently than indicators on realtime bars. By default, they execute only once per bar at each _closing tick_ without undergoing rollback. However, users can modify a strategy’s calculation behavior to allow rollback and re-execution on a bar before its closing tick.\n\nIf the strategy() statement includes calc_on_every_tick = true, or if the user selects the “On every tick” checkbox in the “Settings/Properties” tab, the script executes on a realtime bar after _each new update_ from the data feed, similar to an indicator.\n\nAdditionally, if the strategy() statement includes calc_on_order_fills = true or the user selects “After order is filled” in the “Settings/Properties” tab, the script executes on _each tick_ where the broker emulator fills an order. With this behavior, the system can execute the script multiple times on the open bar, but only on the ticks where an _order fill_ occurs.\n\nTo summarize the general process for script executions on realtime bars:\n\n- An indicator or library script executes on the _first available tick_ in an open realtime bar, then _once per update_ to recalculate the results for the bar using the latest data. A strategy script executes only on the bar’s _closing tick_ by default, but users can modify its calculation behavior to allow executions while the bar is open.\n- Before each new script execution on an open bar, the runtime system executes a _rollback_ process, which _reverts_ all applicable variables, expressions, and objects to their _last committed states_ as of the previous bar’s close.\n- After the script executes on an _elapsed_ realtime bar’s closing tick, the system _commits_ necessary data from that execution to the time series for access on later bars. It does not commit the data from executions on the bar’s _unconfirmed_ values from previous ticks.\n\nEvents that trigger script executions\n\nSeveral events cause a script to load and execute across all the available bars in a dataset. The specific events that trigger the loading process depend on where the script runs.\n\nFor a script on the chart, the following events always cause the script to load and perform _new executions_ on every bar:\n\n- The user adds the script to the chart for the first time from the Pine Editor or the “Indicators, metrics, and strategies” menu.\n- The user saves an update to the script while it is active on the chart.\n- The chart is refreshed while the script is active.\n\nOther events also trigger the loading process for a script on the chart. However, these events do not _always_ cause new script executions on past bars. The results from running a script with a unique combination of settings are often temporarily _cached_. If cached data exists for a selected combination of settings, the system loads the script using that data. See the Caching section for more information.\n\nBelow are the additional events that cause a script to load on the chart, either by performing new executions across the dataset or by using available cached data:\n\n- The user selects new values for the inputs or strategy properties in the script’s “Settings” menu.\n- The script uses the chart.left\\_visible\\_bar\\_time or chart.right\\_visible\\_bar\\_time variable, and the visible chart range changes.\n- The script uses the chart.fg\\_color or chart.bg\\_color variable, and the user changes the chart’s background color.\n- The chart loads a new dataset with a different _timeframe_ or _ticker identifier_. Several user actions affect a chart’s ticker ID, such as selecting a symbol from the “Symbol Search” menu, changing the chart type, toggling data modifications in the chart’s settings, and activating Bar Replay mode.\n- The user opens or closes the Pine Logs pane.\n- The user activates or deactivates the Pine Profiler.\n\nFor scripts used in other locations, the following events trigger the loading process:\n\n- The user creates a new script alert from the “Create Alert” dialog box.\n- The user pauses and restarts an alert instance from the “Alerts” menu.\n- The user clicks the “Generate report” button in the Strategy Tester while Deep Backtesting mode is enabled.\n- The user clicks the “Scan” button in the Pine Screener to run the script on the datasets from a chosen watchlist.\n\n_After_ a script loads, either of the following causes new script executions on an _open bar_:\n\n- One of the events above causes the script to load again and execute across the _entire dataset_ up to the bar.\n- The script runs on the chart or in an alert, and the bar updates after new data becomes available. The system performs _rollback_ and re-executes the script on that bar using the latest data. The only exception is if the script is a strategy that does not allow recalculation on the new tick.\n\nWhen a script completely reloads on the chart or in an alert after an applicable event, all the elapsed realtime bars from the script’s previous run become historical bars in the new run, because they represent _confirmed_ data points that the script accesses from _a different data feed_ as it loads.\n\nThe bars in a symbol’s dataset come from two distinct data feeds: the _historical_ feed and the _realtime_ feed. The historical feed reports only the _final_ values for each bar, whereas the realtime feed includes the _temporary_ values from all available ticks. When a realtime bar becomes historical after a script restarts, the values from the bar’s previous ticks are no longer accessible; only the final price, volume, and other values remain. Therefore, if a script relies on temporary data from realtime bars in its calculations, it might behave differently after reloading.\n\nFor example, the following script calculates the one-bar arithmetic return of the close series and displays the result as a line plot. On each realtime bar, the script updates three variables declared with varip to track the first, highest, and lowest return values calculated during executions across the bar’s ticks, then calls plotcandle() to plot a candle showing the values. Additionally, it uses bgcolor() to highlight the background of realtime bars in orange:\n\n//@version=6\nindicator(\"Reloading a script demo\", precision = 5)\n\n//@variable The one-bar arithmetic return of the \\close\\ series.\nfloat priceReturn = ta.change(close, 1) / close\\[1\\]\n\n// Declare persistent variables to track the first, highest, and lowest \\priceReturn\\ values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\n\nif barstate.isrealtime\n// On the first tick in the realtime bar, reassign \\o\\, \\h\\, and \\l\\ to hold the value of \\priceReturn\\.\nif barstate.isnew\no := priceReturn\nh := priceReturn\nl := priceReturn\n// Otherwise, reassign \\h\\ and \\l\\ to the bar's highest and lowest \\priceReturn\\ value as of the current tick.\nelse\nh := math.max(h, priceReturn)\nl := math.min(l, priceReturn)\n\n// Plot candles to display the \\o\\, \\h\\, \\l\\, and \\priceReturn\\ values for each realtime bar.\n// The candles do not appear on historical bars, because \\o\\, \\h\\, and \\l\\ are \\na\\ on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg\\_color, bordercolor = chart.fg\\_color)\n// Dispaly the \\priceReturn\\ series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter the script loads on the chart and executes on several realtime bars, all the elapsed realtime bars, as well as the open realtime bar, include plotted return candles and an orange background color:\n\nAfter an applicable event, such as a chart refresh, the script _reloads_ and executes across the dataset again. All the closed bars with a realtime state in the previous run become _historical_ bars in the new run. The results thus change because our script relies on realtime data. As shown below, the script does not display candles or background colors for previous bars after we refresh the chart. Those outputs appear only for the latest bar, after new ticks become available, because that bar is now the only one with a realtime state:\n\nNote that:\n\n- The barstate.isnew variable has a value of true when a realtime bar opens, and false on all subsequent updates to the bar. If the script reloads midway through a realtime bar’s progression, only the background color appears on that bar. The script does not show a candle on the first realtime bar in that case, because its o, h, and l variables hold na until the first time that barstate.isnew is true.\n\nCaching\n\nWhen a script runs on a chart for the _first time_ using a _unique configuration_, the data from that run is often temporarily cached for reuse. The cached data is erased after the chart is refreshed or the user updates the script’s source code.\n\nIn this context, the configuration refers to the combined state of all script, chart, and developer tool settings that can affect the script’s executions. This combination includes:\n\n- The values of inputs in the script’s “Settings/Inputs” tab.\n- The values of the strategy properties in the “Settings/Properties” tab.\n- The values of the chart.* variables whose qualifiers are “input” ( chart.left\\_visible\\_bar\\_time, chart.right\\_visible\\_bar\\_time, chart.fg\\_color, and chart.bg\\_color).\n- The chart’s timeframe.\n- The chart’s ticker identifier.\n- Whether the Pine Logs pane is open or closed.\n- Whether the Pine Profiler is active or not.\n\nEach time that a script runs using a unique combination of settings, it executes from start to end on each bar in the dataset to perform new calculations. If possible, the script’s data from the run is then cached. If cached data is available on past bars for a selected combination of settings, the runtime system loads the script using that data.\n\nThis behavior enables users to change a script’s inputs, alter the chart, and toggle developer tools without losing information — including bar states — from previous script runs using different settings. Additionally, caching helps reduce loading times and resource requirements when switching between settings or adding multiple instances of the same script to the chart.\n\nTo understand this behavior, let’s revisit the script from the previous section. The script has different behaviors on historical and realtime bars. In the version below, we’ve added a lengthInput variable that holds the value from an input.int() call. The script uses this variable to define the length of the ta.change() calculation and the offset of the history-referencing operator:\n\n//@version=6\nindicator(\"Caching demo\", precision = 5)\n\n//@variable The bar span of the \\priceReturn\\ calculation.\nint lengthInput = input.int(5, \"Length\", 1)\n\n//@variable The arithmetic return of the \\close\\ series across \\lengthInput\\ bars.\nfloat priceReturn = ta.change(close, lengthInput) / close\\[lengthInput\\]\n\n// Declare persistent variables to track the first, highest, and lowest \\priceReturn\\ values across ticks in\n// each realtime bar.\nvarip float o = na\nvarip float h = na\nvarip float l = na\n\nif barstate.isrealtime\n// On the first tick in the realtime bar, reassign \\o\\, \\h\\, and \\l\\ to hold the value of \\priceReturn\\.\nif barstate.isnew\no := priceReturn\nh := priceReturn\nl := priceReturn\n// Otherwise, reassign \\h\\ and \\l\\ to the bar's highest and lowest \\priceReturn\\ value as of the current tick.\nelse\nh := math.max(h, priceReturn)\nl := math.min(l, priceReturn)\n\n// Plot candles to display the \\o\\, \\h\\, \\l\\, and \\priceReturn\\ values for each realtime bar.\n// The candles do not appear on historical bars, because \\o\\, \\h\\, and \\l\\ are \\na\\ on those bars.\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg\\_color, bordercolor = chart.fg\\_color)\n// Dispaly the \\priceReturn\\ series as a purple line plot.\nplot(priceReturn, \"Return plot\", color.purple, 3)\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nAfter we add the script to our 1m chart and let it run for a few minutes with a “Length” input value of 5, the script plots candles and highlights the background for the latest few bars, because barstate.isrealtime is true on those bars:\n\nLet’s change the “Length” input to a new value, causing the script to reload and execute across the dataset again. Here, we changed the value from 5 to 10 and let the script execute on some new ticks. The script no longer displays candles and background colors for the same bars after restarting, because it now accesses the data for those formerly realtime bars from the _historical_ data feed:\n\nAs shown above, the realtime bar information from the first run is _not available_ when we change the script’s input to a new value. However, the data from that previous run still exists in memory. If we revert the “Length” input’s value to 5, the candle plot and background colors start on the same bar as the first run:\n\nIf we add a second instance of the script to the chart, using the same settings, the runtime system loads the new instance using the cached data instead of executing it entirely from scratch. As such, its outputs are _identical_ to those from the first script instance, even though we added it to the chart a few bars later:\n\nSimilarly, cached data usually remains available even if we remove the script from our chart and add it again.\n\nTime series\n\nA symbol’s dataset is a form of _time series_ — a sequence of collected values indexed by time. Each bar represents a distinct data point, anchored to a specific time, that contains price and volume data for a particular period. This data format thus shows how a symbol’s values progress across time in successive periodic steps.\n\nPine Script’s internal time series structure follows a similar format. After executing a script on a closed bar’s confirmed values, the runtime system _commits (saves)_ the results of the script’s statements and expressions to internal time series for later use. Each bar with committed data has an assigned _index_ in the series, where 0 represents the first bar, 1 represents the second, and so on. Scripts can retrieve this index with the bar\\_index variable.\n\nScripts can access the data committed to the time series on past bars by using the [\\[\\] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/-history-referencing-operator). The value between the operator’s square brackets specifies the position of the referenced bar in the time series as a _relative offset_ behind the current bar. For variables and expressions in the global scope, an offset value of 1 refers to the previous bar at bar_index - 1 (one bar back), a value of 2 refers to the bar at bar_index - 2 (two bars back), and so on. An offset of 0 always refers to the _current bar_.\n\nFor example, consider the open variable, which holds the opening price of the current bar on which the script executes. Before each script execution on a new bar, the runtime system commits the open value from the last execution on the previous bar. Then, it updates the variable to hold the current bar’s opening price. To access the committed open value for the previous bar, we can use the expression open[1]. To access the committed value from 10 bars back, we use open[10].\n\nThe script below performs three history-referencing operations to retrieve the current bar’s open value, the value from one bar back, and the value from a user-specified number of bars back. Then, it plots the retrieved values on the chart for comparison:\n\n//@version=6\nindicator(\"History referencing demo\", overlay = true, behind\\_chart = false)\n\n//@variable The number of bars back from which to retrieve the \\open\\ price for \\pastOpen\\.\nint offsetInput = input.int(10, \"Bar offset\", 0)\n\n//@variable The current bar's opening price. \\open\\[0\\]\\ is equivalent to using \\open\\ without the \\\\[\\]\\ operator.\nfloat currOpen = open\\[0\\]\n//@variable The last committed \\open\\ value. Represents the previous bar's value, or \\na\\ if no previous bar exists.\nfloat prevOpen = open\\[1\\]\n//@variable The \\open\\ value committed \\offsetInput\\ bars back, or \\na\\ if no bar exists at that offset.\nfloat pastOpen = open\\[offsetInput\\]\n\n// Plot \\currOpen\\, \\prevOpen\\, and \\pastOpen\\ for comparison.\nplot(currOpen, \"Current \\open\\\", color.blue, 2)\nplot(prevOpen, \"Previous bar \\open\\\", color.purple, 3)\nplot(pastOpen, \"Past \\open\\ from custom offset\", color.orange, 4)\n\nNote that:\n\n- The expression open[0] is equivalent to using open without the history-referencing operator, because an offset of 0 refers to the current bar.\n- At the beginning of the chart’s dataset, the expressions open[1] and open[offsetInput] return na because they refer to previous bars that are unavailable.\n- Each history-referencing expression also leaves a trail of values in the time series. Therefore, it is possible to retrieve past states of the expression using another history-referencing operation, e.g., (open[offsetInput])[1].\n- Internally, the system maintains a _limited amount_ of time series data for variables and expressions in fixed-length _historical buffers_. These buffers define the _maximum offsets_ allowed for history-referencing operations. See the next section, Historical buffers, to learn more.\n\nAnother way that scripts use committed values from a time series is by calling the built-in functions that reference history internally, such as those in the ta.* namespace. For example, the expression ta.highest(high, 20) calculates the highest value from the high series over a 20-bar window. It compares the series’ current value to the committed values from the previous 19 bars to determine the result. The script below executes this call on each bar and plots the resulting series on the chart. Additionally, the script colors the background of the last 20 bars on the chart to highlight the bars used in the latest execution’s ta.highest() call:\n\n//@version=6\nindicator(\"History referencing in functions demo\", overlay = true, behind\\_chart = false)\n\n//@variable The highest value from the \\high\\ series across the 20 most recent bars.\n// The \\ta.highest()\\ call compares the current \\high\\ to the last 19 committed values.\nfloat highest = ta.highest(high, 20)\n\n// Plot the \\highest\\ series on the chart.\nplot(highest, \"20-bar high\", color.purple, 3)\n\n// Color the background of the last 20 bars, i.e., the bars used by the latest execution's \\ta.highest()\\ call.\nbgcolor(color.new(color.blue, 70), show\\_last = 20, title = \"Last 20 bar highlight\")\n\nNote that:\n\n- The first 19 bars of the chart have a plotted value of na, because the ta.highest() function call requires the high values from the current bar and 19 previous bars to calculate the result.\n- All function calls and expressions that do not return “void” leave historical trails in the time series, just like variables. Therefore, scripts can use an expression such as ta.highest(high, 20)[10] to retrieve the 20-bar high from 10 bars back.\n- The ta.highest() function and other functions that access past values from a time series must execute in the global scope for consistent calculations. Time series storage for variables and expressions in local scopes works _differently_ than that for global values. See the Time series in scopes section for more information.\n\nHistorical buffers\n\nTo promote efficiency and help ensure computing resources remain available for all users, the Pine Script runtime system uses fixed-length _historical buffers_ to maintain a _limited amount_ of time series data for all variables and expressions. These historical buffers define the _maximum_ number of committed data points that a script can access on any bar via the history-referencing operator or the built-in functions that reference past bars internally.\n\nFor most series, the underlying historical buffer can contain data from up to 5000 past bars. The only exception is for some built-in series such as open, close, and time, whose buffers can store data for _more_ than 5000 bars.\n\nAlthough these buffers can contain thousands of data points at their maximum size, a script might not _require_ that much past data for its calculations on any bar. Therefore, the runtime system automatically optimizes the size of each series’ historical buffer based on the historical references that the script performs as it loads on the dataset. Each resulting buffer contains _only_ the amount of past data required by the script’s calculations and _not more_.\n\nFor instance, if the maximum number of bars back for which a script references the value of a variable on historical bars is 500, the system maintains a historical buffer that includes only the latest 500 committed values of that variable. The buffer does not store 5000 committed values, because the script _does not_ require all that extra data. This behavior thus helps to minimize a script’s resource requirements while preserving the integrity of its calculations.\n\nTo determine the sufficient buffer size for each variable and expression in a script, the runtime system performs the following process during the script’s loading time:\n\n1. It analyzes all the historical references that occur while executing the script on the dataset’s first 244 bars, then sets the initial size of each buffer to the minimum size that accommodates those references.\n2. While executing the script on subsequent bars, it checks if the script attempts to access data from previous bars that are beyond the limits of the defined buffers. If the script’s historical references exceed the buffer limits on any bar, the system restarts the loading process and tries a larger buffer size.\n3. In the rare case that a historical buffer’s size remains insufficient after several calculation attempts, the system stops the script and raises a runtime error.\n\nIt’s crucial to emphasize that the runtime system defines the sizes of all historical buffers only while executing a script on _historical bars_. It does not adjust any historical buffers during executions on _new bars_ from the realtime data feed. If a script references past data from beyond a historical buffer’s limits while executing on a realtime bar, it causes a runtime error.\n\nFor example, the script below retrieves a past value from the close series using the history-referencing operator with an offset of 100 bars back on historical bars and 150 bars back on realtime bars. Because the script references data from 100 bars back during all historical executions, the system sets the close buffer’s size to include only 100 past values. Consequently, an error occurs when the script executes on the open realtime bar, because a historical offset of 150 is _beyond_ the buffer’s limit:\n\n//@version=6\nindicator(\"Max bars back error demo\", overlay = true)\n\n// @variable The historical offset for retrieving past values from the \\close\\ series.\n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n\n// @variable The value of \\close\\ from \\offset\\ bars back.\n// This code causes a \\runtime error\\ on a realtime bar. During all code executions on historical bars,\n// the script requires only the latest 100 past values of \\close\\, so the system sets the buffer size to\n// include only the past 100 values. The offset of 150 is thus \\out of bounds\\.\nfloat pastClose = close\\[offset\\]\n\n// Plot the \\pastClose\\ series.\nplot(pastClose, \"Past \\close\\\", chart.fg\\_color, 3)\n\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nFor cases like these, programmers can _manually_ set the size of a historical buffer to ensure it contains a sufficient amount of data by doing any of the following:\n\n- Modify the script to reference the maximum required number of bars back with the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) operator during its execution on the _first bar_.\n- Call the max\\_bars\\_back() function to explicitly set the historical buffer size for a _specific_ series.\n- Include a max_bars_back argument in the indicator() or strategy() declaration statement to set the initial size of _all_ historical buffers.\n\nBelow, we modified the script by including the expression max_bars_back(close, 150), which sets the size of the close buffer to include 150 past values. With the appropriate buffer size manually defined, the script’s history-referencing operation no longer causes an error on realtime bars:\n\n//@version=6\nindicator(\"Manual buffer sizing demo\", overlay = true)\n\n// @variable The historical offset for retrieving past values from the \\close\\ series.\n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.\nint offset = barstate.ishistory ? 100 : 150\n\n// Set the size of the \\close\\ historical buffer to include 150 past values, ensuring the script has exactly\n// the amount of history that it requires on realtime bars.\nmax\\_bars\\_back(close, 150)\n\n// @variable The value of \\close\\ from \\offset\\ bars back.\n// This code no longer causes an error when it executes on a realtime bar, because the historical\n// buffer has an appropriate size defined in advance.\nfloat pastClose = close\\[offset\\]\n\n// Plot the \\pastClose\\ series.\nplot(pastClose, \"Past \\close\\\", chart.fg\\_color, 3)\n\n// Highlight the background of all realtime bars in orange.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\n\nTime series in scopes\n\nThe _scope_ of a variable or expression refers to the part of the script where it is defined and accessible in the code. Every script has one _global_ scope and zero or more _local_ scopes.\n\nAll variables and expressions in a script that are outside user-defined functions or methods, conditional structures, loops, and user-defined type or enum type declarations belong to the _global scope_. The script evaluates variables and expressions from this scope _once_ for _every execution_ across bars and ticks in the dataset.\n\nAll functions, methods, conditional structures, and loops create their own _local scopes_. The variables and expressions defined within a local scope belong exclusively to that scope. In contrast to the global scope, a script does _not_ always evaluate a local scope once per execution; the script might evaluate the scope _zero_, _one_, or _several_ times per execution, depending on its logic.\n\nFor the runtime system to commit data from a variable or expression and queue that data into a historical buffer on any bar, a script must _evaluate_ the scope of that variable or expression once when it executes on the bar’s _closing tick_. If the script does not evaluate the scope, the runtime system _cannot_ update the historical buffer for the variable or expression. Similarly, if the script evaluates the scope repeatedly within a loop, the historical buffer cannot store series data for _each_ separate iteration, because each entry in the time series corresponds to a single bar.\n\nTherefore, time series behave differently in global and local scopes: the historical buffers for global variables and expressions _always_ contain committed data for _consecutive_ past bars, whereas the buffers for local variables often contain an inconsistent history of committed data.\n\nWhen a script references the history of a global variable using an expression such as myVariable[1], the historical offset of 1 always refers to the confirmed myVariable value from the _previous bar_. In contrast, when using such an expression with a local variable, the offset of 1 refers to the most recent bar where the script executed the scope. It does not represent a specific number of bars back. Therefore, referencing the history of a local variable can cause _unintended results_.\n\nThe following example demonstrates how the historical buffers for a user-defined function’s local scope behave when a script does not call the function on _every_ bar. The script below contains a custom upDownColor() function, which compares the current value of its source parameter to the last committed value ( source[1]). The function returns color.blue if the current source value is higher than the previous value. Otherwise, it returns color.orange.\n\nThe script uses this function _conditionally_, inside a ternary operation, to determine the color of a plot that shows the remainder from dividing bar\\_index by a specified value. If the remainder variable’s value is nonzero, the operation calls upDownColor(remainder) to calculate the color (blue or orange). If the value is 0, the operation does _not_ use the call and instead returns color.gray. The remainder value _increases_ on each bar, except for when it returns to 0 — causing the gray color. Therefore, a user might expect the plot’s color to be only blue or gray on every bar. However, the color changes to _orange_ on each bar after the one where the color is gray, even though the remainder value on that bar is _higher_ than the value on the previous bar:\n\n//@version=6\nindicator(\"Local historical references demo\")\n\n//@function Returns \\color.blue\\ if \\source\\ is above its last committed value; \\color.orange\\ otherwise.\n// For consistent results, this function should execute on \\every bar\\, because it uses the\n// history-referencing operator on the \\source\\ series.\n//\n// Even if the argument supplied to \\source\\ comes from a global variable, the \\source\\ parameter remains\n// part of the function's \\local scope\\. The system maintains a \\separate historical buffer\\ for the \\source\\\n// series in each function call instance. The buffer contains only the committed \\source\\ values from the bars\n// where the function call occurs. If the call does not occur on a bar, the buffer for \\source\\ contains\n// \\\\no data\\\\ for that bar.\nupDownColor(float source) =>\nsource > source\\[1\\] ? color.blue : color.orange\n\n//@variable The value by which to divide the \\bar\\_index\\ value.\nint divisorInput = input.int(5, \"Divisor\", 1)\n\n//@variable The remainder of dividing \\bar\\_index\\ by \\divisorInput\\.\nfloat remainder = bar\\_index % divisorInput\n\n//@variable Is \\color.orange\\ if \\remainder\\ equals 0, and the result of \\upDownColor(remainder)\\ otherwise.\n// The \\upDownColor()\\ call does not execute on every bar. Therefore, it does \\not\\ always compare the\n// \\remainder\\ value from one bar back to calculate the color. Instead, the function compares the current\n// \\remainder\\ to the value from the last bar where \\remainder\\ is nonzero.\ncolor plotColor = remainder == 0 ? color.gray : upDownColor(remainder)\n\n// Plot the \\remainder\\ series and color it using \\plotColor\\. The plot is orange after each bar where \\remainder == 0\\,\n// because the \\upDownColor()\\ function call does not have data for that bar to use in its logic.\nplot(remainder, \"Remainder\", plotColor, 5)\n\nThe script behaves this way because upDownColor() uses the history-referencing operator on the source series, which is _local_ to the function’s scope, and the script does not call the function on _every_ execution. When the value of remainder is zero, the _first_ expression in the ternary condition evaluates to true, and therefore the second branch of the ternary expression, which contains the function call, does _not_ execute.\n\nThe compiler issues the following warning about the function directly in the Pine Editor:",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": []
  },
  "df55f437": {
    "title": "PineScript Reference",
    "type": "reference",
    "content": "ADVANCED\n\nArrays\n\nIntroduction\n\nPine Script Arrays are one-dimensional collections that can hold\nmultiple value references. Think of them as a better way to handle cases\nwhere one would otherwise need to explicitly declare a set of similar\nvariables (e.g., price00, price01, price02, …).\n\nAll elements in an array must be of the same built-in type, user-defined type, or enum type.\n\nScripts reference arrays using array IDs similar to the IDs of lines, labels, and other _special types_. Pine Script does not use an indexing operator to reference individual array elements.\nInstead, functions including array.get() and array.set() read and write the values of array elements.\n\nScripts reference the elements of an array using an _index_, which\nstarts at 0 and extends to the number of elements in the array minus\none. Arrays in Pine Script can have a dynamic size that varies across\nbars, as one can change the number of elements in an array on each\niteration of a script. Scripts can contain multiple array instances. The\nsize of arrays is limited to 100,000 elements.\n\nDeclaring arrays\n\nPine Script uses the following syntax to declare arrays:\n\n``\n\n[var/varip ][array<type>/<type[]> ]<identifier> = <expression>\n`\n\nWhere <type> is a\ntype template for the array that declares the type of values it will\ncontain, and the <expression> returns either an array of the specified\ntype or na.\n\nWhen declaring a variable as an array, we can use the\narray\nkeyword followed by a\ntype template. Alternatively, we can use the type name followed by the\n[] modifier (not to be confused with the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) _history-referencing operator_).\n\nSince Pine always uses type-specific functions to create arrays, the\narray<type>/type[] part of the declaration is redundant, except when\ndeclaring an array variable assigned to na. Even when not required,\nexplicitly declaring the array type helps clearly state the intention to\nreaders.\n\nThis line of code declares an array variable named prices that points\nto na. In this case, we must specify the type to declare that the\nvariable can reference arrays containing “float” values:\n\narray<float> prices = na\n\nWe can also write the above example in this form:\n\nfloat\\[\\] prices = na\n\nWhen declaring an array and the <expression> is not na, use one of\nthe following functions: array.new<type>(),\narray.from(),\nor\narray.copy().\nFor array.new<type>() calls, the arguments of\nthe function’s size and initial_value parameters can be “series” to allow\ndynamic sizing and initialization of array elements. The following\nexample creates an array containing zero “float” elements, and this\ntime, the array reference returned by the array.new\\<float\\>()\nfunction call is assigned to the prices variable:\n\nprices = array.new<float>(0)\n\nThe initial_value parameter of the array.new*() functions allows users to\nset all elements in the array to a specified value. If no argument is\nprovided for initial_value, the array is filled with na values.\n\nThis line declares an array ID named prices pointing to an array\ncontaining two elements, each assigned to the bar’s close value:\n\nprices = array.new<float>(2, close)\n\nTo create an array and initialize its elements with different values,\nuse\narray.from().\nThis function infers the array’s size and the type of elements it will\nhold from the arguments in the function call. As with array.new*\nfunctions, it accepts “series” arguments. All values supplied to the\nfunction must be of the same type.\n\nFor example, all three of these lines of code will create identical\n“bool” arrays with the same two elements:\n\nstatesArray = array.from(close > open, high != close)\nbool\\[\\] statesArray = array.from(close > open, high != close)\narray<bool> statesArray = array.from(close > open, high != close)\n\nUsing ​ var ​ and ​ varip ​ keywords\n\nUsers can utilize\nvar and\nvarip\nkeywords to instruct a script to declare an array variable only once on\nthe first execution of the script on the first chart bar. Array\nvariables declared using these keywords point to the same array\ninstances until explicitly reassigned, allowing an array and its element\nreferences to persist across bars.\n\nWhen declaring an array variable using these keywords and pushing a new\nvalue to the end of the referenced array on each bar, the array will\ngrow by one on each bar and be of size bar_index + 1\n( bar\\_index\nstarts at zero) by the time the script executes on the last bar, as this\ncode demonstrates:\n\n//@version=6\nindicator(\"Using \\var\\\")\n//@variable An array that expands its size by 1 on each bar.\nvar a = array.new<float>(0)\narray.push(a, close)\n\nif barstate.islast\n//@variable A string containing the size of \\a\\ and the current \\bar\\_index\\ value.\nstring labelText = \"Array size: \" + str.tostring(a.size()) + \"\\\\nbar\\_index: \" + str.tostring(bar\\_index)\n// Display the \\labelText\\.\nlabel.new(bar\\_index, 0, labelText, size = size.large)\n\nThe same code without the\nvar\nkeyword would re-declare the array on each bar. In this case, after\nexecution of the\narray.push()\ncall, the\narray.size() _method_\ncall ( a.size()) would return a value of 1.\n\nReading and writing array elements\n\nScripts can write values to existing individual array elements using\narray.set(),\nand read using array.get().\nWhen using these functions, it is imperative that the index in the\nfunction call is always less than or equal to the array’s size (because\narray indices start at zero). To get the size of an array, use the\narray.size()\nfunction.\n\nThe following example uses the\nset()\nmethod to populate a fillColors array with instances of one base color\nusing different transparency levels. It then uses\narray.get()\nto retrieve one of the colors from the array based on the location of\nthe bar with the highest price within the last lookbackInput bars:\n\n//@version=6\nindicator(\"Distance from high\", \"\", true)\nlookbackInput = input.int(100)\nFILL\\_COLOR = color.green\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(5)\nif barstate.isfirst\n// Initialize the array elements with progressively lighter shades of the fill color.\nfillColors.set(0, color.new(FILL\\_COLOR, 70))\nfillColors.set(1, color.new(FILL\\_COLOR, 75))\nfillColors.set(2, color.new(FILL\\_COLOR, 80))\nfillColors.set(3, color.new(FILL\\_COLOR, 85))\nfillColors.set(4, color.new(FILL\\_COLOR, 90))\n\n// Find the offset to highest high. Change its sign because the function returns a negative value.\nlastHiBar = - ta.highestbars(high, lookbackInput)\n// Convert the offset to an array index, capping it to 4 to avoid a runtime error.\n// The index used by \\array.get()\\ will be the equivalent of \\floor(fillNo)\\.\nfillNo = math.min(lastHiBar / (lookbackInput / 5), 4)\n// Set background to a progressively lighter fill with increasing distance from location of highest high.\nbgcolor(array.get(fillColors, fillNo))\n// Plot key values to the Data Window for debugging.\nplotchar(lastHiBar, \"lastHiBar\", \"\", location.top, size = size.tiny)\nplotchar(fillNo, \"fillNo\", \"\", location.top, size = size.tiny)\n\nAnother technique for initializing the elements in an array is to create\nan _empty array_ (an array with no elements), then use\narray.push()\nto append new elements to the end of the array, increasing the size\nof the array by one on each call. The following code is functionally\nidentical to the initialization section from the preceding script:\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n// Initialize the array elements with progressively lighter shades of the fill color.\narray.push(fillColors, color.new(FILL\\_COLOR, 70))\narray.push(fillColors, color.new(FILL\\_COLOR, 75))\narray.push(fillColors, color.new(FILL\\_COLOR, 80))\narray.push(fillColors, color.new(FILL\\_COLOR, 85))\narray.push(fillColors, color.new(FILL\\_COLOR, 90))\n\nThis code is equivalent to the one above, but it uses\narray.unshift()\nto insert new elements at the _beginning_ of the fillColors array:\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n// Initialize the array elements with progressively lighter shades of the fill color.\narray.unshift(fillColors, color.new(FILL\\_COLOR, 90))\narray.unshift(fillColors, color.new(FILL\\_COLOR, 85))\narray.unshift(fillColors, color.new(FILL\\_COLOR, 80))\narray.unshift(fillColors, color.new(FILL\\_COLOR, 75))\narray.unshift(fillColors, color.new(FILL\\_COLOR, 70))\n\nWe can also use\narray.from()\nto create the same fillColors array with a single function call:\n\n//@version=6\nindicator(\"Using \\var\\\")\nFILL\\_COLOR = color.green\nvar array<color> fillColors = array.from(\ncolor.new(FILL\\_COLOR, 70),\ncolor.new(FILL\\_COLOR, 75),\ncolor.new(FILL\\_COLOR, 80),\ncolor.new(FILL\\_COLOR, 85),\ncolor.new(FILL\\_COLOR, 90)\n)\n// Cycle background through the array's colors.\nbgcolor(array.get(fillColors, bar\\_index % (fillColors.size())))\n\nThe array.fill()\nfunction points all array elements, or the elements within the index_from to index_to range, to a specified value. Without the\nlast two optional parameters, the function fills the whole array, so:\n\na = array.new<float>(10, close)\n\nand:\n\na = array.new<float>(10)\na.fill(close)\n\nare equivalent, but:\n\na = array.new<float>(10)\na.fill(close, 1, 3)\n\nonly fills the second and third elements (at index 1 and 2) of the array\nwith close. Note how the\narray.fill() function’s\nlast parameter, index_to, must have a value one greater than the last index the\nfunction will fill. The remaining elements will hold na values, as the\narray.new<type>()\nfunction call does not contain an initial_value argument.\n\nLooping through array elements\n\nWhen looping through an array’s element indices and the array’s size\nis unknown, one can use the\narray.size()\nfunction to get the maximum index value. For example:\n\n//@version=6\nindicator(\"Protected \\for\\ loop\", overlay = true)\n//@variable An array of \\close\\ prices from the 1-minute timeframe.\narray<float> a = request.security\\_lower\\_tf(syminfo.tickerid, \"1\", close)\n\n//@variable A string representation of the elements in \\a\\.\nstring labelText = \"\"\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\nlabelText += str.tostring(array.get(a, i)) + \"\\\\n\"\n\nlabel.new(bar\\_index, high, text = labelText)\n\nNote that:\n\n- We use the\nrequest.security\\_lower\\_tf()\nfunction which returns an array of\nclose\nprices at the 1 minute timeframe.\n- This code example will throw an error if you use it on a chart\ntimeframe smaller than 1 minute.\n- for\nloops do not execute if the to expression is\nna.\nNote that the to value is only evaluated once upon entry.\n\nAn alternative method to loop through an array is to use a\nfor…in\nloop. This approach is a variation of the standard for loop that can\niterate over the value references and indices in an array. Here is an\nexample of how we can write the code example from above using a\nfor...in loop:\n\n//@version=6\nindicator(\"\\for...in\\ loop\", overlay = true)\n//@variable An array of \\close\\ prices from the 1-minute timeframe.\narray<float> a = request.security\\_lower\\_tf(syminfo.tickerid, \"1\", close)\n\n//@variable A string representation of the elements in \\a\\.\nstring labelText = \"\"\nfor price in a\nlabelText += str.tostring(price) + \"\\\\n\"\n\nlabel.new(bar\\_index, high, text = labelText)\n\nNote that:\n\n- for…in\nloops can return a tuple containing each index and corresponding\nelement. For example, for [i, price] in a returns the i\nindex and price value for each element in a.\n\nA\nwhile\nloop statement can also be used:\n\n//@version=6\nindicator(\"\\while\\ loop\", overlay = true)\narray<float> a = request.security\\_lower\\_tf(syminfo.tickerid, \"1\", close)\n\nstring labelText = \"\"\nint i = 0\nwhile i < array.size(a)\nlabelText += str.tostring(array.get(a, i)) + \"\\\\n\"\ni += 1\n\nlabel.new(bar\\_index, high, text = labelText)\n\nScope\n\nUsers can declare arrays within the global scope of a script, as well as\nthe local scopes of\nfunctions,\nmethods, and\nconditional structures. Unlike some of the other built-in types, namely\n_fundamental_ types, scripts can modify globally-assigned arrays from\nwithin local scopes, allowing users to implement global variables that\nany function in the script can directly interact with. We use the\nfunctionality here to calculate progressively lower or higher price\nlevels:\n\n//@version=6\nindicator(\"Bands\", \"\", true)\n//@variable The distance ratio between plotted price levels.\nfactorInput = 1 + (input.float(-2., \"Step %\") / 100)\n//@variable A single-value array holding the lowest \\ohlc4\\ value within a 50 bar window from 10 bars back.\nlevel = array.new<float>(1, ta.lowest(ohlc4, 50)\\[10\\])\n\nnextLevel(val) =>\nnewLevel = level.get(0) \\* val\n// Write new level to the global \\level\\ array so we can use it as the base in the next function call.\nlevel.set(0, newLevel)\nnewLevel\n\nplot(nextLevel(1))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\n\nHistory referencing\n\nThe history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) can\naccess the history of array variables, allowing scripts to interact with\npast array instances previously assigned to a variable.\n\nTo illustrate this, let’s create a simple example to show how one can\nfetch the previous bar’s close value in two equivalent ways. This\nscript uses the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator to get the array instance assigned to a on the previous bar,\nthen uses an\narray.get()\nmethod call to retrieve the value of the first element ( previousClose1).\nFor previousClose2, we use the history-referencing operator on the\nclose variable directly to retrieve the value. As we see from the\nplots, previousClose1 and previousClose2 both return the same value:\n\n//@version=6\nindicator(\"History referencing\")\n\n//@variable A single-value array declared on each bar.\na = array.new<float>(1)\n// Set the value of the only element in \\a\\ to \\close\\.\narray.set(a, 0, close)\n\n//@variable The array instance assigned to \\a\\ on the previous bar.\nprevious = a\\[1\\]\n\npreviousClose1 = na(previous) ? na : previous.get(0)\npreviousClose2 = close\\[1\\]\n\nplot(previousClose1, \"previousClose1\", color.gray, 6)\nplot(previousClose2, \"previousClose2\", color.white, 2)\n\nInserting and removing array elements\n\nInserting\n\nThe following three functions can insert new elements into an array.\n\narray.unshift()\ninserts a new element at the beginning of an array (index 0) and\nincreases the index values of any existing elements by one.\n\narray.insert()\ninserts a new element at the specified index and increases the index\nof existing elements at or after the index by one.\n\n//@version=6\nindicator(\"\\array.insert()\\\")\na = array.new<float>(5, 0)\nfor i = 0 to 4\narray.set(a, i, i + 1)\nif barstate.islast\nlabel.new(bar\\_index, 0, \"BEFORE\\\\na: \" + str.tostring(a), size = size.large)\narray.insert(a, 2, 999)\nlabel.new(bar\\_index, 0, \"AFTER\\\\na: \" + str.tostring(a), style = label.style\\_label\\_up, size = size.large)\n\narray.push()\nadds a new element at the end of an array.\n\nRemoving\n\nThese four functions remove elements from an array. The first three also\nreturn the value of the removed element.\n\narray.remove()\nremoves the element at the specified index and returns that element’s\nvalue.\n\narray.shift()\nremoves the first element from an array and returns its value.\n\narray.pop()\nremoves the last element of an array and returns its value.\n\narray.clear()\nremoves all elements from an array. Note that clearing an array won’t\ndelete any objects its elements referenced. See the example below that\nillustrates how this works:\n\n//@version=6\nindicator(\"\\array.clear()\\ example\", overlay = true)\n\n// Create a label array and add a label to the array on each new bar.\nvar a = array.new<label>()\nlabel lbl = label.new(bar\\_index, high, \"Text\", color = color.red)\narray.push(a, lbl)\n\nvar table t = table.new(position.top\\_right, 1, 1)\n// Clear the array on the last bar. This doesn't remove the labels from the chart.\nif barstate.islast\narray.clear(a)\ntable.cell(t, 0, 0, \"Array elements count: \" + str.tostring(array.size(a)), bgcolor = color.yellow)\n\nUsing an array as a stack\n\nStacks are LIFO (last in, first out) constructions. They behave somewhat\nlike a vertical pile of books to which books can only be added or\nremoved one at a time, always from the top. Pine Script arrays can be\nused as a stack, in which case we use the\narray.push()\nand\narray.pop()\nfunctions to add and remove elements at the end of the array.\n\narray.push(prices, close) will add a new element to the end of the\nprices array, increasing the array’s size by one.\n\narray.pop(prices) will remove the end element from the prices array,\nreturn its value and decrease the array’s size by one.\n\nSee how the functions are used here to track successive lows in rallies:\n\n//@version=6\nindicator(\"Lows from new highs\", \"\", true)\nvar lows = array.new<float>(0)\nflushLows = false\n\n//@function Removes the last element from the \\id\\ stack when \\cond\\ is \\true\\.\narray\\_pop(id, cond) => cond and array.size(id) > 0 ? array.pop(id) : float(na)\n\nif ta.rising(high, 1)\n// Rising highs; push a new low on the stack.\nlows.push(low)\n// Force the return type of this \\if\\ block to be the same as that of the next block.\nbool(na)\nelse if lows.size() >= 4 or low < array.min(lows)\n// We have at least 4 lows or price has breached the lowest low;\n// sort lows and set flag indicating we will plot and flush the levels.\narray.sort(lows, order.ascending)\nflushLows := true\n\n// If needed, plot and flush lows.\nlowLevel = array\\_pop(lows, flushLows)\nplot(lowLevel, \"Low 1\", low > lowLevel ? color.silver : color.purple, 2, plot.style\\_linebr)\nlowLevel := array\\_pop(lows, flushLows)\nplot(lowLevel, \"Low 2\", low > lowLevel ? color.silver : color.purple, 3, plot.style\\_linebr)\nlowLevel := array\\_pop(lows, flushLows)\nplot(lowLevel, \"Low 3\", low > lowLevel ? color.silver : color.purple, 4, plot.style\\_linebr)\nlowLevel := array\\_pop(lows, flushLows)\nplot(lowLevel, \"Low 4\", low > lowLevel ? color.silver : color.purple, 5, plot.style\\_linebr)\n\nif flushLows\n// Clear remaining levels after the last 4 have been plotted.\nlows.clear()\n\nUsing an array as a queue\n\nQueues are FIFO (first in, first out) constructions. They behave\nsomewhat like cars arriving at a red light. New cars are queued at the\nend of the line, and the first car to leave will be the first one that\narrived to the red light.\n\nIn the following code example, we let users decide through the script’s\ninputs how many labels they want to have on their chart. We use that\nquantity to determine the size of the array of labels we then create,\ninitializing the array’s elements to na.\n\nWhen a new pivot is detected, we create a label for it, saving the\nlabel’s ID in the pLabel variable. We then queue the ID of that label\nby using\narray.push()\nto append the new label’s ID to the end of the array, making our array\nsize one greater than the maximum number of labels to keep on the chart.\n\nLastly, we de-queue the oldest label by removing the array’s first\nelement using\narray.shift()\nand deleting the label referenced by that array element’s value. As we\nhave now de-queued an element from our queue, the array contains\npivotCountInput elements once again. Note that on the dataset’s first\nbars we will be deleting na label IDs until the maximum number of\nlabels has been created, but this does not cause runtime errors. Let’s\nlook at our code:\n\n//@version=6\nMAX\\_LABELS = 100\nindicator(\"Show Last n High Pivots\", \"\", true, max\\_labels\\_count = MAX\\_LABELS)\n\npivotCountInput = input.int(5, \"How many pivots to show\", minval = 0, maxval = MAX\\_LABELS)\npivotLegsInput = input.int(3, \"Pivot legs\", minval = 1, maxval = 5)\n\n// Create an array containing the user-selected max count of label IDs.\nvar labelIds = array.new<label>(pivotCountInput)\n\npHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nif not na(pHi)\n// New pivot found; plot its label \\pivotLegsInput\\ bars behind the current \\bar\\_index\\.\npLabel = label.new(bar\\_index - pivotLegsInput, pHi, str.tostring(pHi, format.mintick), textcolor = color.white)\n// Queue the new label's ID by appending it to the end of the array.\narray.push(labelIds, pLabel)\n// De-queue the oldest label ID from the queue and delete the corresponding label.\nlabel.delete(array.shift(labelIds))\n\nNegative indexing\n\nThe array.get(), array.set(), array.insert(), and array.remove() functions support _negative indexing_, which references elements starting from the end of the array. An index of -1 refers to the last element in the array, an index of -2 refers to the second to last element, and so on.\n\nWhen using a _positive_ index, functions traverse the array _forwards_ from the beginning of the array ( _first to last_ element). The first element’s index is 0, and the last element’s index is array.size() - 1. When using a _negative_ index, functions traverse the array _backwards_ from the end of the array ( _last to first_ element). The last element’s index is -1, and the first element’s index is –array.size():\n\narray<string> myArray = array.from(\"first\", \"second\", \"third\", \"fourth\", \"last\")\n\n// Positive indexing: Indexes forwards from the beginning of the array.\nmyArray.get(0) // Returns \"first\" element\nmyArray.get(myArray.size() - 1) // Returns \"last\" element\nmyArray.get(4) // Returns \"last\" element\n\n// Negative indexing: Indexes backwards from the end of the array.\nmyArray.get(-1) // Returns \"last\" element\nmyArray.get(-myArray.size()) // Returns \"first\" element\nmyArray.get(-5) // Returns \"first\" element\n\nLike positive indexing, negative indexing is bound by the size of the array. For example, functions operating on an array of 5 elements only accept indices of 0 to 4 (first to last element) or -1 to -5 (last to first element). Any other indices are out of bounds and will raise a runtime error.\n\nWe can use negative indices to retrieve, update, add, and remove array elements. This simple script creates an “int” countingArray and calls the array.get(), array.set(), array.insert(), and array.remove() functions to perform various array operations using negative indices. It displays each array operation and its corresponding result using a table:\n\n//@version=6\nindicator(\"Negative indexing demo\", overlay = false)\n\n//@variable A \\table\\ that displays various array operations and their results.\nvar table displayTable = table.new(\nposition.middle\\_center, 2, 15, bgcolor = color.white,\nframe\\_color = color.black, frame\\_width = 1, border\\_width = 1\n)\n\n//@function Initializes a \\displayTable\\ row to output a \"string\" of an \\arrayOperation\\ and the \\operationResult\\.\ndisplayRow(int rowID, string arrayOperation, operationResult) =>\n//@variable Is white if the \\rowID\\ is even, light blue otherwise. Used to set alternating table row colors.\ncolor rowColor = rowID % 2 == 0 ? color.white : color.rgb(33, 149, 243, 75)\n// Display the \\arrayOperation\\ in the row's first cell.\ndisplayTable.cell(0, rowID, arrayOperation, text\\_color = color.black,\ntext\\_halign = text.align\\_left, bgcolor = rowColor, text\\_font\\_family = font.family\\_monospace\n)\n// Display the \\operationResult\\ in the row's second cell.\ndisplayTable.cell(1, rowID, str.tostring(operationResult), text\\_color = color.black,\ntext\\_halign = text.align\\_right, bgcolor = rowColor\n)\n\nif barstate.islastconfirmedhistory\n//@variable Array of \"int\" numbers. Holds six multiples of 10, counting from 10 to 60.\narray<int> countingArray = array.from(10, 20, 30, 40, 50, 60)\n\n// Initialize the table's header cells.\ndisplayTable.cell(0, 0, \"ARRAY OPERATION\")\ndisplayTable.cell(1, 0, \"RESULT\")\n\n// Display the initial \\countingArray\\ values.\ndisplayTable.cell(0, 1, \"Initial \\countingArray\\\",\ntext\\_color = color.black, text\\_halign = text.align\\_center, bgcolor = color.yellow)\ndisplayTable.cell(1, 1, str.tostring(countingArray),\ntext\\_color = color.black, text\\_halign = text.align\\_right, bgcolor = color.yellow)\n\n// Retrieve array elements using negative indices in \\array.get()\\.\ndisplayRow(2, \"\\countingArray.get(0)\\\", countingArray.get(0))\ndisplayRow(3, \"\\countingArray.get(-1)\\\", countingArray.get(-1))\ndisplayRow(4, \"\\countingArray.get(-countingArray.size())\\\", countingArray.get(-countingArray.size()))\n\n// Update array elements using negative indices in \\array.set()\\ and \\array.insert()\\.\ncountingArray.set(-2, 99)\ndisplayRow(5, \"\\countingArray.set(-2, 99)\\\", countingArray)\n\ncountingArray.insert(-5, 878)\ndisplayRow(6, \"\\countingArray.insert(-5, 878)\\\", countingArray)\n\n// Remove array elements using negative indices in \\array.remove()\\.\ncountingArray.remove(-3)\ndisplayRow(7, \"\\countingArray.remove(-3)\\\", countingArray)\n\nNote that not all array operations can use negative indices. For example, search functions like array.indexof() and array.binary\\_search() return the _positive_ index of an element if it’s found in the array. If the value is not found, the functions return -1. However, this returned value is not a negative index, and using it as one would incorrectly reference the last array element. If a script needs to use a search function’s returned index in subsequent array operations, it must appropriately differentiate between this -1 result and other valid indices.\n\nCalculations on arrays\n\nWhile series variables can be viewed as a horizontal set of values\nstretching back in time, Pine Script’s one-dimensional arrays can be\nviewed as vertical structures residing on each bar. As an array’s set\nof elements is not a\ntime series,\nPine Script’s usual mathematical functions are not allowed on them.\nSpecial-purpose functions must be used to operate on all of an array’s\nvalues. The available functions are:\narray.abs(),\narray.avg(),\narray.covariance(),\narray.min(),\narray.max(),\narray.median(),\narray.mode(),\narray.percentile\\_linear\\_interpolation(),\narray.percentile\\_nearest\\_rank(),\narray.percentrank(),\narray.range(),\narray.standardize(),\narray.stdev(),\narray.sum(),\narray.variance().\n\nNote that contrary to the usual mathematical functions in Pine Script,\nthose used on arrays do not return na when some of the values they\ncalculate on have na values. There are a few exceptions to this rule:\n\n- When all array elements have na value or the array contains no\nelements, na is returned. array.standardize() however, will\nreturn an empty array.\n- array.mode() will return na when no mode is found.\n\nManipulating arrays\n\nConcatenation\n\nTwo arrays can be merged — or concatenated — using\narray.concat().\nWhen arrays are concatenated, the second array is appended to the end of\nthe first, so the first array is modified while the second one remains\nintact. The function returns the array ID of the first array:\n\n//@version=6\nindicator(\"\\array.concat()\\\")\na = array.new<float>(0)\nb = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(b, 2)\narray.push(b, 3)\nif barstate.islast\nlabel.new(bar\\_index, 0, \"BEFORE\\\\na: \" + str.tostring(a) + \"\\\\nb: \" + str.tostring(b), size = size.large)\nc = array.concat(a, b)\narray.push(c, 4)\nlabel.new(bar\\_index, 0, \"AFTER\\\\na: \" + str.tostring(a) + \"\\\\nb: \" + str.tostring(b) + \"\\\\nc: \" + str.tostring(c), style = label.style\\_label\\_up, size = size.large)\n\nCopying\n\nYou can copy an array using\narray.copy().\nHere we copy the array a to a new array named _b:\n\n//@version=6\nindicator(\"\\array.copy()\\\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\nif barstate.islast\nb = array.copy(a)\narray.push(b, 2)\nlabel.new(bar\\_index, 0, \"a: \" + str.tostring(a) + \"\\\\nb: \" + str.tostring(b), size = size.large)\n\nNote that simply using _b = a in the previous example would not have\ncopied the array, but only its ID. From thereon, both variables would\npoint to the same array, so using either one would affect the same\narray.\n\nJoining\n\nThe array.join() function converts an “int”, “float”, or “string” array’s elements into strings, then _joins_ each one to form a single “string” value with a specified separator inserted between each combined value. It provides a convenient alternative to converting values to strings with str.tostring() and performing repeated string concatenation operations.\n\nThe following script demonstrates the array.join() function’s behaviors. It requests tuples of “string”, “int”, and “float” values from three different contexts with request.security() calls, creates separate arrays for each type with array.from(), then creates joined strings with the array.join() function. Lastly, it creates another array from those strings with array.from() and joins them with another array.join() call, using a newline as the separator, and displays the final string in the table:\n\n//@version=6\nindicator(\"Joining demo\")\n\n//@function Returns a tuple containing the ticker ID (\"string\"), bar index (\"int\"), and closing price (\"float\").\ndataRequest() =>\n\\[syminfo.tickerid, bar\\_index, close\\]\n\nif barstate.islast\n//@variable A single-cell table displaying the results of \\array.join()\\ calls.\nvar table displayTable = table.new(position.middle\\_center, 1, 1, color.blue)\n// Request data for three symbols.\n\\[ticker1, index1, price1\\] = request.security(\"SPY\", \"\", dataRequest())\n\\[ticker2, index2, price2\\] = request.security(\"GLD\", \"\", dataRequest())\n\\[ticker3, index3, price3\\] = request.security(\"TLT\", \"\", dataRequest())\n\n// Create separate \"string\", \"int\", and \"float\" arrays to hold the requested data.\narray<string> tickerArray = array.from(ticker1, ticker2, ticker3)\narray<int> indexArray = array.from(index1, index2, index3)\narray<float> priceArray = array.from(price1, price2, price3)\n\n// Convert each array's data to strings and join them with different separators.\nstring joined1 = array.join(tickerArray, \", \")\nstring joined2 = indexArray.join(\"\\|\")\nstring joined3 = priceArray.join(\"\\\\n\")\n\n//@variable A joined \"string\" containing the \\joined1\\, \\joined2\\, and \\joined3\\ values.\nstring displayText = array.from(joined1, joined2, joined3).join(\"\\\\n---\\\\n\")\n// Initialize a cell to show the \\displayText\\.\ndisplayTable.cell(0, 0, displayText, text\\_color = color.white, text\\_size = 36)\n\nNote that:\n\n- Each array.join() call inserts the specified separator only between each element string. It does _not_ include the separator at the start or end of the returned value.\n- The array.join() function uses the same numeric format as the default for str.tostring(). See the String conversion and formatting section of the Strings page to learn more.\n- Calls to array.join() cannot directly convert elements of “bool”, “color”, or other types to strings. Scripts must convert data of these types separately.\n\nSorting\n\nScripts can sort arrays containing “int”, “float”, or “string” elements in ascending or descending order using the array.sort() function. The direction in which the function sorts the array’s elements depends on its order parameter, which accepts the order.ascending or order.descending constants. The default argument is order.ascending, meaning the function sorts the elements in ascending order of value.\n\nThe function sorts arrays of “int” and “float” elements based on their _numeric_ values.\n\nThe example below declares two arrays with references assigned to the a and b variables, and it concatenates those arrays to form a combined c array. The script creates Pine Logs showing formatted text representing the unsorted arrays, and the results of using array.sort() to sort all three arrays in ascending and descending order:\n\n//@version=6\nindicator(\"Sorting numeric arrays demo\")\n\nif barstate.isfirst\n//@variable A formatting string.\nstring formatString = \"\\\\n{0}:\\\\n{1}\\\\n{2}\\\\n{3}\"\n\n// Create two three-element arrays.\narray<float> a = array.from(2.1, 0.5, 1.2)\narray<float> b = array.from(0.1, 1.4, 0.6)\n//@variable A combined array containing the elements from \\a\\ and \\b\\.\narray<float> c = array.copy(a).concat(b)\n\n// Log formatted text showing the unsorted \\a\\, \\b\\, and \\c\\ arrays.\nlog.info(formatString, \"Unsorted\", a, b, c)\n\n// Sort the \\a\\, \\b\\, and \\c\\ arrays in ascending order (default).\narray.sort(a)\narray.sort(b)\nc.sort()\n\n// Log formatted text showing the \\a\\, \\b\\, and \\c\\ arrays sorted in ascending order.\nlog.info(formatString, \"Ascending\", a, b, c)\n\n// Sort the \\a\\, \\b\\, and \\c\\ arrays in descending order.\na.sort(order.descending)\nb.sort(order.descending)\nc.sort(order.descending)\n\n// Log formatted text showing the \\a\\, \\b\\, and \\c\\ arrays sorted in descending order.\nlog.info(formatString, \"Descending\", a, b, c)\n\nNote that:\n\n- Each array.sort() call directly _modifies_ the order of the elements in the original array. To get sorted elements _without_ reorganizing the original array, use the array.sort\\_indices() function. This function returns a new array of “int” values representing the _indices_ of the elements sorted in ascending or descending order.\n\nThe array.sort() function sorts arrays of “string” values based on the _Unicode values_ of their characters. The sorting algorithm starts with each element’s _first_ character position, then successively uses additional characters if multiple elements have matching characters at the same position.\n\nThis example creates an array of arbitrary strings on the first bar, then sorts the array’s contents in ascending order with an array.sort() call. The script logs formatted representations of the array in the Pine Logs pane before and after calling the array.sort() function:\n\n//@version=6\nindicator(\"Sorting string arrays demo\")\n\nif barstate.isfirst\n\n//@variable An array of arbitrary \"string\" values.\narray<string> stringArray = array.from(\"abC\", \"Abc\", \"ABc\", \"ABC\", \"!\", \"123\", \"12.3\", \" \")\n\n// Log the original \\stringArray\\.\nlog.info(\"Unsorted: {0}\", stringArray)\n\n// Sort the array in ascending order (default) and log the result.\nstringArray.sort()\nlog.info(\"Ascending: {0}\", stringArray)\n\nNote that:\n\n- Whitespace and control characters have lower Unicode values than other characters, which is why the \" \" element appears first in the sorted array.\n- Some ASCII punctuation marks and symbols have lower Unicode values than digit or letter characters. The \"!\" element comes before the elements with word characters because its Unicode value is U+0021. However, some other ASCII punctuation and symbol characters, such as the Left Curly Bracket { (U+007B), have higher Unicode values than ASCII digits and letters.\n- ASCII digits have lower Unicode values than letter characters. For example, the 1 character’s value is U+0031, and the A character’s value is U+0041.\n- Uppercase ASCII letters come _before_ lowercase characters in the Unicode Standard. For instance, the a character has the Unicode value U+0061, which is larger than the value for A.\n\nReversing\n\nUse\narray.reverse()\nto reverse an array:\n\n//@version=6\nindicator(\"\\array.reverse()\\\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\nif barstate.islast\narray.reverse(a)\nlabel.new(bar\\_index, 0, \"a: \" + str.tostring(a))\n\nSlicing\n\nSlicing an array using\narray.slice()\ncreates a shallow copy of a subset of the parent array. You determine\nthe size of the subset to slice using the index_from and index_to\nparameters. The index_to argument must be one greater than the end of\nthe subset you want to slice.\n\nThe shallow copy created by the slice acts like a window on the parent\narray’s content. The indices used for the slice define the window’s\nposition and size over the parent array. If, as in the example below, a\nslice is created from the first three elements of an array (indices 0 to\n2), then regardless of changes made to the parent array, and as long as\nit contains at least three elements, the shallow copy will always\ncontain the parent array’s first three elements.\n\nAdditionally, once the shallow copy is created, operations on the copy\nare mirrored on the parent array. Adding an element to the end of the\nshallow copy, as is done in the following example, will widen the window\nby one element and also insert that element in the parent array at index\n3\\. In this example, to slice the subset from index 0 to index 2 of array\na, we must use sliceOfA = array.slice(a, 0, 3):\n\n//@version=6\nindicator(\"\\array.slice()\\\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 3)\nif barstate.islast\n// Create a shadow of elements at index 1 and 2 from array \\a\\.\nsliceOfA = array.slice(a, 0, 3)\nlabel.new(bar\\_index, 0, \"BEFORE\\\\na: \" + str.tostring(a) + \"\\\\nsliceOfA: \" + str.tostring(sliceOfA))\n// Remove first element of parent array \\a\\.\narray.remove(a, 0)\n// Add a new element at the end of the shallow copy, thus also affecting the original array \\a\\.\narray.push(sliceOfA, 4)\nlabel.new(bar\\_index, 0, \"AFTER\\\\na: \" + str.tostring(a) + \"\\\\nsliceOfA: \" + str.tostring(sliceOfA), style = label.style\\_label\\_up)\n\nSearching arrays\n\nWe can test if a value is part of an array with the\narray.includes()\nfunction, which returns true if the element is found. We can find the\nfirst occurrence of a value in an array by using the\narray.indexof()\nfunction. The first occurence is the one with the lowest index. We can\nalso find the last occurrence of a value with\narray.lastindexof():\n\n//@version=6\nindicator(\"Searching in arrays\")\nvalueInput = input.int(1)\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 1)\nif barstate.islast\nvalueFound = array.includes(a, valueInput)\nfirstIndexFound = array.indexof(a, valueInput)\nlastIndexFound = array.lastindexof(a, valueInput)\nlabel.new(bar\\_index, 0, \"a: \" + str.tostring(a) +\n\"\\\\nFirst \" + str.tostring(valueInput) + (firstIndexFound != -1 ? \" value was found at index: \" + str.tostring(firstIndexFound) : \" value was not found.\") +\n\"\\\\nLast \" + str.tostring(valueInput) + (lastIndexFound != -1 ? \" value was found at index: \" + str.tostring(lastIndexFound) : \" value was not found.\"))\n\nWe can also perform a binary search on an array but note that performing\na binary search on an array means that the array will first need to be\nsorted in ascending order only. The\narray.binary\\_search()\nfunction will return the value’s index if it was found or -1 if it\nwasn’t. If we want to always return an existing index from the array\neven if our chosen value wasn’t found, then we can use one of the other\nbinary search functions available. The\narray.binary\\_search\\_leftmost()\nfunction, which returns an index if the value was found or the first\nindex to the left where the value would be found. The\narray.binary\\_search\\_rightmost()\nfunction is almost identical and returns an index if the value was found\nor the first index to the right where the value would be found.\n\nError handling\n\nMalformed array.*() call syntax in Pine scripts will cause the usual\ncompiler error messages to appear in Pine Editor’s console, at the\nbottom of the window, when you save a script. Refer to the Pine Script\nv6 Reference\\\\\nManual when in\ndoubt regarding the exact syntax of function calls.\n\nScripts using arrays can also throw runtime errors, which appear as\nan exclamation mark next to the indicator’s name on the chart. We\ndiscuss those runtime errors in this section.\n\nIndex xx is out of bounds. Array size is yy\n\nThis error is the most frequent one programmers encounter when using arrays. The error occurs when the script references a _nonexistent_ array index. The “xx”\nvalue represents the out-of-bounds index the function tried to use, and “yy” represents the array’s size. Recall that array indices start at zero — not one — and end at the array’s size, minus one. For instance, the last valid index in a three-element array is 2.\n\nTo avoid this error, you must make provisions in your code logic to prevent using an index value outside the array’s boundaries. This code example generates the error because the last i value in the loop’s iterations is beyond the valid index range for the a array:\n\n//@version=6\nindicator(\"Out of bounds index\")\na = array.new<float>(3)\nfor i = 1 to 3\narray.set(a, i, i)\nplot(array.pop(a))\n\nTo resolve the error, last i value in the loop statement should be less than or equal to 2:\n\nfor i = 0 to 2\n\nTo iterate over all elements in an array of _unknown_ size with a for loop, set the loop counter’s final value to one less than the array.size() value:\n\n//@version=6\nindicator(\"Protected \\for\\ loop\")\nsizeInput = input.int(0, \"Array size\", minval = 0, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\narray.set(a, i, i)\nplot(array.pop(a))\n\nWhen sizing arrays dynamically using a field in the script’s\n_Settings/Inputs_ tab, protect the boundaries of that value using\ninput.int()‘s\nminval and maxval parameters:\n\n//@version=6\nindicator(\"Protected array size\")\nsizeInput = input.int(10, \"Array size\", minval = 1, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to sizeInput - 1\narray.set(a, i, i)\nplot(array.size(a))\n\nSee the Looping through array elements\nsection of this page for more information.\n\nCannot call array methods when ID of array is ‘na’\n\nWhen an array ID is initialized to na, operations on it are not\nallowed, since no array exists. All that exists at that point is an\narray variable containing the na value rather than a valid array ID\npointing to an existing array. Note that an array created with no\nelements in it, as you do when you use a = array.new_int(0), has a\nvalid ID nonetheless. This code will throw the error we are discussing:\n\n//@version=6\nindicator(\"Array methods on \\na\\` array\")\narray<int> a = na\narray.push(a, 111)\nlabel.new(bar\\_index, 0, \"a: \" + str.tostring(a))\n\nTo avoid it, create an array with size zero using:\n\narray<int> a = array.new\\_int(0)\n\nor:\n\na = array.new\\_int(0)\n\nArray is too large. Maximum size is 100000\n\nThis error will appear if your code attempts to declare an array with a\nsize greater than 100,000. It will also occur if, while dynamically\nappending elements to an array, a new element would increase the\narray’s size past the maximum.\n\nCannot create an array with a negative size\n\nWe haven’t found any use for arrays of negative size yet, but if you\never do, we may allow them :)\n\nCannot use shift() if array is empty.\n\nThis error will occur if\narray.shift()\nis called to remove the first element of an empty array.\n\nCannot use pop() if array is empty.\n\nThis error will occur if\narray.pop()\nis called to remove the last element of an empty array.\n\nIndex ‘from’ should be less than index ‘to’\n\nWhen two indices are used in functions such as\narray.slice(),\nthe first index must always be smaller than the second one.\n\nSlice is out of bounds of the parent array\n\nThis message occurs whenever the parent array’s size is modified in\nsuch a way that it makes the shallow copy created by a slice point\noutside the boundaries of the parent array. This code will reproduce it\nbecause after creating a slice from index 3 to 4 (the last two elements\nof our five-element parent array), we remove the parent’s first\nelement, making its size four and its last index 3. From that moment on,\nthe shallow copy which is still pointing to the “window” at the parent\narray’s indices 3 to 4, is pointing out of the parent array’s\nboundaries:\n\n//@version=6\nindicator(\"Slice out of bounds\")\na = array.new<float>(5, 0)\nb = array.slice(a, 3, 5)\narray.remove(a, 0)\nc = array.indexof(b, 2)\nplot(c)\n\nPrevious\\\\\nMethods Next\\\\\nMatrices",
    "tags": [
      "reference",
      "functions",
      "api"
    ],
    "examples": [
      "[var/varip ][array<type>/<type[]> ]<identifier> = <expression>"
    ]
  }
}