{
  "overview": {
    "content": "",
    "examples": [],
    "type": "language_concept"
  },
  "operators": {
    "content": "Operators\n\nIntroduction\n\nSome operators are used to build _expressions_ returning a result:\n\n- Arithmetic operators\n- Comparison operators\n- Logical operators\n- The\n?:\nternary operator\n- The\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nhistory-referencing operator\n\nOther operators are used to assign values to variables:\n\n- = is used to assign a value to a variable, but only when you\ndeclare the variable (the first time you use it)\n- := is used to assign a value to a previously declared\nvariable. The following operators can also be used in such a way:\n+=, -=, *=, /=, %=\n\nAs is explained in the Type system page, _qualifiers_ and _types_ play a critical role in\ndetermining the type of results that expressions yield. This, in turn,\nhas an impact on how and with what functions you will be allowed to use\nthose results. Expressions always return a value with the strongest\nqualifier used in the expression, e.g., if you multiply an “input int”\nwith a “series int”, the expression will produce a “series int”\nresult, which you will not be able to use as the argument to length in\nta.ema().\n\nThis script will produce a compilation error:\n\n//@version=6\nindicator(\"\")\nlenInput = input.int(14, \"Length\")\nfactor = year > 2020 ? 3 : 1\nadjustedLength = lenInput \\* factor\nma = ta.ema(close, adjustedLength) // Compilation error!\nplot(ma)\n\nThe compiler will complain: _Cannot call ‘ta.ema’ with argument_\n_‘length’=‘adjustedLength’. An argument of ‘series int’ type was_\n_used but a ‘simple int’ is expected;_. This is happening because\nlenInput is an “input int” but factor is a “series int” (it can\nonly be determined by looking at the value of\nyear\non each bar). The adjustedLength variable is thus assigned a “series\nint” value. Our problem is that the Reference Manual entry for\nta.ema()\ntells us that its length parameter requires a “simple” value, which\nis a weaker qualifier than “series”, so a “series int” value is not\nallowed.\n\nThe solution to our conundrum requires:\n\n- Using another moving average function that supports a “series int”\nlength, such as\nta.sma(),\nor\n- Not using a calculation producing a “series int” value for our\nlength.\n\nArithmetic operators\n\nThere are five arithmetic operators in Pine Script®:\n\n| Operator | Meaning |\n| --- | --- |\n| + | Addition and string concatenation |\n| - | Subtraction |\n| * | Multiplication |\n| / | Division |\n| % | Modulo (remainder after division) |\n\nThe arithmetic operators above are all _binary_, meaning they need two _operands_ — or values — to work on, as in the example operation 1 + 2. The + and - can also be _unary_ operators, which means they work on one operand, as in the example values -1 or +1.\n\nIf both operands are numbers but at least one of these is of\nfloat\ntype, the result will also be a\nfloat.\nIf both operands are of\nint\ntype, the result will also be an\nint.\nIf at least one operand is\nna, the\nresult is also\nna.\n\nNote that when using the division operator with “int” operands, if the two “int” values are not evenly divisible, the result of the division is always a number with a fractional value, e.g., 5/2 = 2.5. To discard the fractional remainder, wrap the division with the int() function, or round the result using math.round(), math.floor(), or math.ceil().\n\nThe + operator also serves as the concatenation operator for strings.\n\"EUR\"+\"USD\" yields the \"EURUSD\" string.\n\nThe % operator calculates the modulo by rounding down the quotient to\nthe lowest possible value. Here is an easy example that helps illustrate\nhow the modulo is calculated behind the scenes:\n\n//@version=6\nindicator(\"Modulo function\")\nmodulo(series int a, series int b) =>\na - b \\* math.floor(nz(a/b))\nplot(modulo(-1, 100))\n\nComparison operators\n\nThere are six comparison operators in Pine Script:\n\n| Operator | Meaning |\n| --- | --- |\n| < | Less Than |\n| <= | Less Than or Equal To |\n| != | Not Equal |\n| == | Equal |\n| > | Greater Than |\n| >= | Greater Than or Equal To |\n\nComparison operations are binary, and return a result of type “bool”, i.e., true or false. The == equal and != not equal operators can work with operands of any fundamental type, such as colors and strings, while the other comparison operators are only applicable to numerical values. Therefore, \"a\" != \"b\" is a valid comparison, but \"a\" > \"b\" is invalid.\n\nExamples:\n\n1 > 2 // false\n1 != 1 // false\nclose >= open // Depends on values of \\close\\ and \\open\\\n\nLogical operators\n\nThere are three logical operators in Pine Script:\n\n| Operator | Meaning |\n| --- | --- |\n| not | Negation |\n| and | Logical Conjunction |\n| or | Logical Disjunction |\n\nThe operator not is unary. When applied to a true, operand the\nresult will be false, and vice versa.\n\nand operator truth table:\n\n| a | b | a and b |\n| --- | --- | --- |\n| true | true | true |\n| true | false | false |\n| false | true | false |\n| false | false | false |\n\nor operator truth table:\n\n| a | b | a or b |\n| --- | --- | --- |\n| true | true | true |\n| true | false | true |\n| false | true | true |\n| false | false | false |\n\n​ ?: ​ ternary operator\n\nThe\n?:\nternary operator is used to create expressions of the form:\n\ncondition ? valueWhenConditionIsTrue : valueWhenConditionIsFalse\n\nThe ternary operator returns a result that depends on the value of condition. If it is true, then it returns valueWhenConditionIsTrue. Otherwise, if condition is false, then it returns valueWhenConditionIsFalse.\n\nA combination of ternary expressions can be used to achieve the same\neffect as a\nswitch\nstructure, e.g.:\n\ntimeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.ismonthly ? color.blue : na\n\nThe example is calculated from left to right:\n\n- If\ntimeframe.isintraday\nis true, then color.red is returned. If it is false, then\ntimeframe.isdaily\nis evaluated.\n- If\ntimeframe.isdaily\nis true, then color.green is returned. If it is false, then\ntimeframe.ismonthly\nis evaluated.\n- If\ntimeframe.ismonthly\nis true, then color.blue is returned, otherwise\nna\nis returned.\n\nNote that the return values on each side of the : are expressions ---\nnot local blocks, so they will not affect the limit of 500 local blocks\nper scope.\n\n[​ [] ​ history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/\\-history-referencing-operator)\n\nIt is possible to refer to past values of\ntime series using the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nhistory-referencing operator. Past values are values a variable had on\nbars preceding the bar where the script is currently executing — the\n_current bar_. See the\nExecution model\npage for more information about the way scripts are executed on bars.\n\nThe\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator is used after a variable, expression or function call. The\nvalue used inside the square brackets of the operator is the offset in\nthe past we want to refer to. To refer to the value of the\nvolume\nbuilt-in variable two bars away from the current bar, one would use\nvolume[2].\n\nBecause series grow dynamically, as the script calculates on successive bars, a constant historical offset refers to different bars. Let’s see how the value returned by the same offset is dynamic, and why series are very different from arrays. In Pine Script, the\nclose\nvariable, or close[0] which is equivalent, holds the value of the\ncurrent bar’s “close”. If your code is now executing on the third\nbar of the _dataset_ (the set of all bars on your chart), close will\ncontain the price at the close of that bar, close[1] will contain the\nprice at the close of the preceding bar (the dataset’s second bar), and\nclose[2], the first bar. close[3] will return\nna\nbecause no bar exists in that position, and thus its value is _not_\n_available_.\n\nWhen the same code is executed on the next bar, the fourth in the\ndataset, close will now contain the closing price of that bar, and the\nsame close[1] used in your code will now refer to the “close” of the\nthird bar in the dataset. The close of the first bar in the dataset will\nnow be close[3], and this time close[4] will return\nna.\n\nIn the Pine Script runtime environment, as your code is executed once\nfor each historical bar in the dataset, starting from the left of the\nchart, Pine Script is adding a new element in the series at index 0 and\npushing the pre-existing elements in the series one index further away.\nArrays, in comparison, can have constant or variable sizes, and their\ncontent or indexing structure is not modified by the runtime\nenvironment. Pine Script series are thus very different from arrays and\nonly share familiarity with them through their indexing syntax.\n\nWhen the market for the chart’s symbol is open and the script is\nexecuting on the chart’s last bar, the _realtime bar_,\nclose\nreturns the value of the current price. It will only contain the actual\nclosing price of the realtime bar the last time the script is executed\non that bar, when it closes.\n\nPine Script has a variable that contains the number of the bar the\nscript is executing on:\nbar\\_index.\nOn the first bar,\nbar\\_index\nis equal to 0 and it increases by 1 on each successive bar the script\nexecutes on. On the last bar,\nbar\\_index\nis equal to the number of bars in the dataset minus one.\n\nThere is another important consideration to keep in mind when using the\n[] operator in Pine Script. We have seen cases when a history\nreference may return the\nna\nvalue.\nna\nrepresents a value which is not a number and using it in any expression\nwill produce a result that is also\nna\n(similar to NaN). Such cases often\nhappen during the script’s calculations in the early bars of the\ndataset, but can also occur in later bars under certain conditions.\nIf your code does not explicitly handle these special cases using the na() and nz() functions, na values can introduce invalid results in your script’s calculations that can affect calculations all the way to the realtime bar.\n\nThese are all valid uses of the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator:\n\nhigh\\[10\\]\nta.sma(close, 10)\\[1\\]\nta.highest(high, 10)\\[20\\]\nclose > nz(close\\[1\\], open)\n\nNote that the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator can only be used once on the same value. This is not allowed:\n\nclose\\[1\\]\\[2\\] // Error: incorrect use of \\[\\] operator\n\nOperator precedence\n\nThe order of calculations is determined by the operators’ precedence.\nOperators with greater precedence are calculated first. Below is a list\nof operators sorted by decreasing precedence:\n\n| Precedence | Operator |\n| --- | --- |\n| 9 | [] |\n| 8 | unary +, unary -, not |\n| 7 | *, /, % |\n| 6 | +, - |\n| 5 | >, <, >=, <= |\n| 4 | ==, != |\n| 3 | and |\n| 2 | or |\n| 1 | ?: |\n\nIf in one expression there are several operators with the same\nprecedence, then they are calculated left to right.\n\nIf the expression must be calculated in a different order than\nprecedence would dictate, then parts of the expression can be grouped\ntogether with parentheses.\n\n​ = ​ assignment operator\n\nThe = operator assigns an initial value or reference to a declared variable. It means _this is a new variable, and it starts with this value_.\n\nThese are all valid variable declarations:\n\ni = 1\nMS\\_IN\\_ONE\\_MINUTE = 1000 \\* 60\nshowPlotInput = input.bool(true, \"Show plots\")\npHi = ta.pivothigh(5, 5)\nplotColor = color.green\n\nSee the\nVariable declarations page for more information on how to declare variables.\n\n​ := ​ reassignment operator\n\nThe := is used to _reassign_ a value to an existing variable. It says\n_use this variable that was declared earlier in my script, and give it a_\n_new value_.\n\nVariables which have been first declared, then reassigned using :=,\nare called _mutable_ variables. All the following examples are valid\nvariable reassignments. You will find more information on how\nvar\nworks in the section on the\n\\var\\ declaration mode:\n\n//@version=6\nindicator(\"\", \"\", true)\n// Declare \\pHi\\ and initilize it on the first bar only.\nvar float pHi = na\n// Reassign a value to \\pHi\\\npHi := nz(ta.pivothigh(5, 5), pHi)\nplot(pHi)\n\nNote that:\n\n- We declare pHi with this code: var float pHi = na. The\nvar\nkeyword tells Pine Script that we only want that variable\ninitialized with\nna\non the dataset’s first bar. The float keyword tells the compiler\nwe are declaring a variable of type “float”. This is necessary\nbecause, contrary to most cases, the compiler cannot automatically\ndetermine the type of the value on the right side of the = sign.\n- While the variable declaration will only be executed on the first\nbar because it uses\nvar,\nthe pHi := nz(ta.pivothigh(5, 5), pHi) line will be executed on\nall the chart’s bars. On each bar, it evaluates if the\nta.pivothigh()\ncall returns\nna\nbecause that is what the function does when it hasn’t found a new\npivot. The\nnz()\nfunction is the one doing the “checking for\nna”\npart. When its first argument ( ta.pivothigh(5, 5)) is\nna,\nit returns the second argument ( pHi) instead of the first. When\nta.pivothigh()\nreturns the price point of a newly found pivot, that value is\nassigned to pHi. When it returns\nna\nbecause no new pivot was found, we assign the previous value of\npHi to itself, in effect preserving its previous value.\n\nThe output of our script looks like this:\n\nNote that:\n\n- The line preserves its previous value until a new pivot is found.\n- Pivots are detected five bars after the pivot actually occurs\nbecause our ta.pivothigh(5, 5) call says that we require five\nlower highs on both sides of a high point for it to be detected as a\npivot.\n\nSee the\nVariable reassignment section for more information on how to reassign values to\nvariables.\n\nPrevious\\\\\nVariable declarations Next\\\\\nConditional structures",
    "examples": [],
    "type": "language_concept"
  },
  "variable-declarations": {
    "content": "Variable declarations\n\nIntroduction\n\nVariables are identifiers that hold values. They must be _declared_ in your code\nbefore you use them. The syntax of variable declarations is:\n\n``\n\n[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n`\n\nor\n\n`\n\n<tuple_declaration> = <function_call> | <structure>\n`\n\nwhere:\n\n- | means OR, and parts enclosed in square brackets ( []) can\nappear zero or one time.\n- <declaration\\_mode> is the variable’s\ndeclaration mode. It can be\nvar\nor\nvarip,\nor nothing.\n- <type> is a valid _type keyword_ with an optional _qualifier prefix_. Specifying a variable’s type is optional in most cases. See the Type system page to learn more.\n- <identifier> is the variable’s\nname.\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <structure> can be an\nif,\nfor,\nwhile\nor\nswitch _structure_.\n- <tuple\\_declaration> is a comma-separated list of variable names\nenclosed in square brackets ( []), e.g.,\n[ma, upperBand, lowerBand].\n\nThese are all valid variable declarations. Note that the last declaration requires four\nlines of code because it uses the returned value from an if statement:\n\nBULL\\_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round\\_to\\_mintick(close)\nsma = ta.sma(close, 14)\nvar barRange = float(na)\nvar firstBarOpen = open\nvarip float lastClose = na\n\\[macdLine, signalLine, histLine\\] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\nelse\ncolor.red\n\nThe formal syntax of a variable declaration is:\n\n`\n\n<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum\n`\n\nInitialization with ​ na ​\n\nIn most cases, an explicit type declaration is redundant because type is\nautomatically inferred from the value on the right of the = at compile\ntime, so the decision to use them is often a matter of preference. For\nexample:\n\nbaseLine0 = na // compile time error!\nfloat baseLine1 = na // OK\nbaseLine2 = float(na) // OK\n\nIn the first line of the example, the compiler cannot determine the type\nof the baseLine0 variable because\nna is a\ngeneric value of no particular type. The declaration of the baseLine1\nvariable is correct because its\nfloat\ntype is declared explicitly. The declaration of the baseLine2 variable\nis also correct because its type can be derived from the expression\nfloat(na), which is an explicit cast of the\nna value\nto the\nfloat\ntype. The declarations of baseLine1 and baseLine2 are equivalent.\n\nTuple declarations\n\nFunction calls or structures are allowed to return multiple values. When\nwe call them and want to store the values they return, a _tuple_\n_declaration_ must be used, which is a comma-separated set of one or more\nvalues enclosed in brackets. This allows us to declare multiple\nvariables simultaneously. As an example, the\nta.bb()\nbuilt-in function for Bollinger bands returns three values:\n\n\\[bbMiddle, bbUpper, bbLower\\] = ta.bb(close, 5, 4)\n\nUsing an underscore (​ _ ​) as an identifier\n\nWhen declaring a variable, it is possible to use a single underscore ( _) as its identifier. A value assigned to such a variable cannot be accessed. You can assign any number of values to a _ identifier anywhere in the script, even if the current scope already has such an assignment.\n\nThis is particularly useful when a tuple returns unneeded values. Let’s write another Bollinger Bands script. Here, we only need the bands themselves, without the center line:\n\n//@version=6\nindicator(\"Underscore demo\")\n\n// We do not need the middle Bollinger Bands value, and do not use it.\n// To make this clear, we assign it to the \\\\_\\ identifier.\n\\[\\_, bbUpper, bbLower\\] = ta.bb(close, 5, 4)\n\n// We can continue to use \\\\_\\ in the same code without causing compilation errors:\n\\[bbMiddleLong, \\_, \\_\\] = ta.bb(close, 20, 2)\n\nplot(bbUpper)\n\nVariable reassignment\n\nA variable reassignment is done using the\n:=\nreassignment operator. It can only be done after a variable has been\nfirst declared and given an initial value. Reassigning a new value to a\nvariable is often necessary in calculations, and it is always necessary\nwhen a variable from the global scope must be assigned a new value from\nwithin a structure’s local block, e.g.:\n\n//@version=6\nindicator(\"\", \"\", true)\nsensitivityInput = input.int(2, \"Sensitivity\", minval = 1, tooltip = \"Higher values make color changes less sensitive.\")\nma = ta.sma(close, 20)\nmaUp = ta.rising(ma, sensitivityInput)\nmaDn = ta.falling(ma, sensitivityInput)\n\n// On first bar only, initialize color to gray\nvar maColor = color.gray\nif maUp\n// MA has risen for two bars in a row; make it lime.\nmaColor := color.lime\nelse if maDn\n// MA has fallen for two bars in a row; make it fuchsia.\nmaColor := color.fuchsia\n\nplot(ma, \"MA\", maColor, 2)\n\nNote that:\n\n- We initialize maColor on the first bar only, so it preserves its\nvalue across bars.\n- On every bar, the\nif\nstatement checks if the MA has been rising or falling for the\nuser-specified number of bars (the default is 2). When that happens,\nthe value of maColor must be reassigned a new value from within\nthe\nif\nlocal blocks. To do this, we use the\n:= reassignment operator.\n- If we did not use the\n:= reassignment operator, the effect would be to initialize\na new maColor local variable which would have the same name as\nthat of the global scope, but actually be a very confusing\nindependent entity that would persist only for the length of the\nlocal block, and then disappear without a trace.\n\nAll user-defined variables in Pine Script are _mutable_, which means\ntheir value can be changed using the\n:=\nreassignment operator. Assigning a new value to a variable may change\nits _type qualifier_ (see the page on Pine Script’s\ntype system for more\ninformation). A variable can be assigned a new value as many times as\nneeded during the script’s execution on one bar, so a script can\ncontain any number of reassignments of one variable. A variable’s\ndeclaration mode determines how new values assigned to a variable will be\nsaved.\n\nDeclaration modes\n\nUnderstanding the impact that declaration modes have on the behavior of\nvariables requires prior knowledge of Pine Script’s\nexecution model.\n\nWhen you declare a variable, if a declaration mode is specified, it must\ncome first. Three modes can be used:\n\n- “On each bar”, when none is specified\n- var\n- varip\n\nOn each bar\n\nWhen no explicit declaration mode is specified, i.e. no\nvar or\nvarip\nkeyword is used, the variable is declared and initialized on each bar,\ne.g., the following declarations from our first set of examples in this\npage’s introduction:\n\nBULL\\_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round\\_to\\_mintick(close)\nst = ta.supertrend(4, 14)\n\\[macdLine, signalLine, histLine\\] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\nelse\ncolor.red\n\n​ var ​\n\nWhen the\nvar\nkeyword is used, the variable is only initialized once, on the first bar\nif the declaration is in the global scope, or the first time the local\nblock is executed if the declaration is inside a local block. After\nthat, it will preserve its last value on successive bars, until we\nreassign a new value to it. This behavior is very useful in many cases\nwhere a variable’s value must persist through the iterations of a\nscript across successive bars. For example, suppose we’d like to count\nthe number of green bars on the chart:\n\n//@version=6\nindicator(\"Green Bars Count\")\nvar count = 0\nisGreen = close >= open\nif isGreen\ncount := count + 1\nplot(count)\n\nWithout the var modifier, variable count would be reset to zero\n(thus losing its value) every time a new bar update triggered a script\nrecalculation.\n\nDeclaring variables on the first bar only is often useful to manage\ndrawings more efficiently. Suppose we want to extend the last bar’s\nclose\nline to the right of the right chart. We could write:\n\n//@version=6\nindicator(\"Inefficient version\", \"\", true)\ncloseLine = line.new(bar\\_index - 1, close, bar\\_index, close, extend = extend.right, width = 3)\nline.delete(closeLine\\[1\\])\n\nbut this is inefficient because we are creating and deleting the line on\neach historical bar and on each update in the realtime bar. It is more\nefficient to use:\n\n//@version=6\nindicator(\"Efficient version\", \"\", true)\nvar closeLine = line.new(bar\\_index - 1, close, bar\\_index, close, extend = extend.right, width = 3)\nif barstate.islast\nline.set\\_xy1(closeLine, bar\\_index - 1, close)\nline.set\\_xy2(closeLine, bar\\_index, close)\n\nNote that:\n\n- We initialize closeLine on the first bar only, using the\nvar\ndeclaration mode\n- We restrict the execution of the rest of our code to the chart’s\nlast bar by enclosing our code that updates the line in an\nif barstate.islast\nstructure.\n\nThere is a very slight penalty performance for using the\nvar\ndeclaration mode. For that reason, when declaring constants, it is\npreferable not to use\nvar if\nperformance is a concern, unless the initialization involves\ncalculations that take longer than the maintenance penalty, e.g.,\nfunctions with complex code or string manipulations.\n\n​ varip ​\n\nUnderstanding the behavior of variables using the\nvarip\ndeclaration mode requires prior knowledge of Pine Script’s\nexecution model and\nbar states.\n\nThe\nvarip\nkeyword can be used to declare variables that escape the _rollback_\n_process_, which is explained in the page on Pine Script’s\nexecution model.\n\nWhereas scripts only execute once at the close of historical bars, when\na script is running in realtime, it executes every time the chart’s\nfeed detects a price or volume update. At every realtime update, Pine\nScript’s runtime normally resets the values of a script’s variables\nto their last committed value, i.e., the value they held when the\nprevious bar closed. This is generally handy, as each realtime script\nexecution starts from a known state, which simplifies script logic.\n\nSometimes, however, script logic requires code to be able to save\nvariable values between different executions in the realtime bar.\nDeclaring variables with\nvarip\nmakes that possible. The “ip” in\nvarip\nstands for _intrabar persist_.\n\nLet’s look at the following code, which does not use\nvarip:\n\n//@version=6\nindicator(\"\")\nint updateNo = na\nif barstate.isnew\nupdateNo := 1\nelse\nupdateNo := updateNo + 1\n\nplot(updateNo, style = plot.style\\_circles)\n\nOn historical bars,\nbarstate.isnew\nis always true, so the plot shows a value of “1” because the else\npart of the\nif\nstructure is never executed. On realtime bars,\nbarstate.isnew\nis only\ntrue\nwhen the script first executes on the bar’s “open”. The plot will\nthen briefly display “1” until subsequent executions occur. On the\nnext executions during the realtime bar, the second branch of the\nif\nstatement is executed because\nbarstate.isnew\nis no longer true. Since updateNo is initialized to\nna at\neach execution, the updateNo + 1 expression yields\nna, so\nnothing is plotted on further realtime executions of the script.\n\nIf we now use\nvarip\nto declare the updateNo variable, the script behaves very differently:\n\n//@version=6\nindicator(\"\")\nvarip int updateNo = na\nif barstate.isnew\nupdateNo := 1\nelse\nupdateNo := updateNo + 1\n\nplot(updateNo, style = plot.style\\_circles)\n\nThe difference now is that updateNo tracks the number of realtime\nupdates that occur on each realtime bar. This can happen because the\nvarip\ndeclaration allows the value of updateNo` to be preserved between\nrealtime updates; it is no longer rolled back at each realtime execution\nof the script. The test on\nbarstate.isnew\nallows us to reset the update count when a new realtime bar comes in.\n\nBecause\nvarip\nonly affects the behavior of your code in the realtime bar, it follows\nthat backtest results on strategies designed using logic based on\nvarip\nvariables will not be able to reproduce that behavior on historical\nbars, which will invalidate test results on them. This also entails that\nplots on historical bars will not be able to reproduce the script’s\nbehavior in realtime.\n\nPrevious\\\\\nIdentifiers Next\\\\\nOperators",
    "examples": [
      "[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>",
      "<tuple_declaration> = <function_call> | <structure>",
      "<variable_declaration>\n\n    [<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n\n    |\n\n    <tuple_declaration> = <function_call> | <structure>\n\n<declaration_mode>\n\n    var | varip\n\n<type>\n\n    int | float | bool | color | string | line | linefill | label | box | table | polyline | chart.point | array<type> | matrix<type> | map<keyType, valueType> | UDT | Enum"
    ],
    "type": "language_concept"
  },
  "conditional-structures": {
    "content": "Conditional structures\n\nIntroduction\n\nThe conditional structures in Pine Script® are\nif and\nswitch.\nThey can be used:\n\n- For their side effects, i.e., when they don’t return a value but do\nthings, like reassign values to variables or call functions.\n- To return a value or a tuple which can then be assigned to one (or\nmore, in the case of tuples) variable.\n\nConditional structures, like the\nfor and\nwhile\nstructures, can be embedded; you can use an\nif or\nswitch\ninside another structure.\n\nSome Pine Script built-in functions are not callable from within the\nlocal blocks of conditional structures, including barcolor(), bgcolor(), plot(), plotshape(), plotchar(), plotarrow(), plotcandle(), plotbar(), hline(), fill(), alertcondition(), indicator(), strategy(), and library().\n\nThis restriction does not entail their functionality cannot be controlled by\nconditions evaluated by your script — only that it cannot be done by\nincluding them in conditional structures. Note that while input*.()\nfunction calls are allowed in local blocks, their functionality is the\nsame as if they were in the script’s _global scope_.\n\nThe local blocks in conditional structures must be indented by four\nspaces or a tab.\n\n​ if ​ structure\n\n​ if ​ used for its side effects\n\nAn if\nstructure used for its side effects has the following syntax:\n\n``\n\nif <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <expression> must be of “bool” type or be auto-castable to that\ntype, which is only possible for “int” or “float” values (see\nthe Type system page).\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- There can be zero or more else if clauses.\n- There can be zero or one else clause.\n\nWhen the <expression> following the\nif\nevaluates to\ntrue,\nthe first local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen the <expression> following the\nif\nevaluates to\nfalse,\nthe successive else if clauses are evaluated, if there are any. When\nthe <expression> of one evaluates to\ntrue,\nits local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to\ntrue\nand an else clause exists, its local block is executed, the\nif\nstructure’s execution ends, and the value(s) evaluated at the end of\nthe local block are returned.\n\nWhen no <expression> has evaluated to true and no else clause exists, na is returned. The only exception to this is if the structure returns “bool” values — in that case, false is returned instead.\n\nUsing if\nstructures for their side effects can be useful to manage the order flow\nin strategies, for example. While the same functionality can often be\nachieved using the when parameter in strategy.*() calls, code using\nif\nstructures is easier to read:\n\nif (ta.crossover(source, lower))\nstrategy.entry(\"BBandLE\", strategy.long, stop=lower,\noca\\_name=\"BollingerBands\",\noca\\_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\nstrategy.cancel(id=\"BBandLE\")\n\nRestricting the execution of your code to specific bars ican be done\nusing if\nstructures, as we do here to restrict updates to our label to the\nchart’s last bar:\n\n//@version=6\nindicator(\"\", \"\", true)\nvar ourLabel = label.new(bar\\_index, na, na, color = color(na), textcolor = color.orange)\nif barstate.islast\nlabel.set\\_xy(ourLabel, bar\\_index + 2, hl2\\[1\\])\nlabel.set\\_text(ourLabel, str.tostring(bar\\_index + 1, \"bars in chart\"))\n\nNote that:\n\n- We initialize the ourLabel variable on the script’s first bar\nonly, as we use the\nvar\ndeclaration mode. The value used to initialize the variable is\nprovided by the\nlabel.new()\nfunction call, which returns a label ID pointing to the label it\ncreates. We use that call to set the label’s properties because\nonce set, they will persist until we change them.\n- What happens next is that on each successive bar the Pine Script\nruntime will skip the initialization of ourLabel, and the\nif\nstructure’s condition\n( barstate.islast)\nis evaluated. It returns false on all bars until the last one, so\nthe script does nothing on most historical bars after bar zero.\n- On the last bar,\nbarstate.islast\nbecomes true and the structure’s local block executes, modifying on\neach chart update the properties of our label, which displays the\nnumber of bars in the dataset.\n- We want to display the label’s text without a background, so we\nmake the label’s background\nna\nin the\nlabel.new()\nfunction call, and we use hl2[1] for the label’s _y_ position\nbecause we don’t want it to move all the time. By using the average\nof the previous bar’s\nhigh\nand\nlow\nvalues, the label doesn’t move until the moment when the next\nrealtime bar opens.\n- We use bar_index + 2 in our\nlabel.set\\_xy()\ncall to offset the label to the right by two bars.\n\n​ if ​ used to return a value\n\nAn if\nstructure used to return one or more values has the following syntax:\n\n`\n\n[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed. If other local blocks return “bool” values, false will be returned instead.\n\nThis is an example:\n\n//@version=6\nindicator(\"\", \"\", true)\nstring barState = if barstate.islastconfirmedhistory\n\"islastconfirmedhistory\"\nelse if barstate.isnew\n\"isnew\"\nelse if barstate.isrealtime\n\"isrealtime\"\nelse\n\"other\"\n\nf\\_print(\\_text) =>\nvar table \\_t = table.new(position.middle\\_right, 1, 1)\ntable.cell(\\_t, 0, 0, \\_text, bgcolor = color.yellow)\nf\\_print(barState)\n\nIt is possible to omit the _else_ block. In this case, if the\ncondition is false, an _empty_ value ( na, false, or \"\") will be\nassigned to the var_declarationX variable.\n\nThis is an example showing how\nna is\nreturned when no local block is executed. If close > open is false\nin here,\nna is\nreturned:\n\nx = if close > open\nclose\n\nScripts can contain if structures with nested if and other\nconditional structures. For example:\n\nif condition1\nif condition2\nif condition3\nexpression\n\nHowever, nesting these structures is not recommended from a performance\nperspective. When possible, it is typically more optimal to compose a\nsingle if statement with multiple logical operators rather than\nseveral nested if blocks:\n\nif condition1 and condition2 and condition3\nexpression\n\n​ switch ​ structure\n\nThe\nswitch\nstructure exists in two forms. One switches on the different values of a\nkey expression:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nThe other form does not use an expression as a key; it switches on the\nevaluation of different expressions:\n\n`\n\n[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>\n`\n\nwhere:\n\n- Parts enclosed in square brackets ( []) can appear zero or one\ntime, and those enclosed in curly braces ( {}) can appear zero or\nmore times.\n- <declaration\\_mode> is the variable’s\ndeclaration mode\n- <type> is optional, as in almost all Pine Script variable\ndeclarations (see types)\n- <identifier> is the variable’s\nname\n- <expression> can be a literal, a variable, an expression or a\nfunction call.\n- <local\\_block> consists of zero or more statements followed by a\nreturn value, which can be a tuple of values. It must be indented by\nfour spaces or a tab.\n- The value assigned to the variable is the return value of the\n<local\\_block>, or\nna\nif no local block is executed.\n- The => <local_block> at the end allows you to specify a return\nvalue which acts as a default to be used when no other case in the\nstructure is executed.\n\nOnly one local block of a\nswitch\nstructure is executed. It is thus a _structured switch_ that doesn’t\n_fall through_ cases. Consequently, break statements are unnecessary.\n\nBoth forms are allowed as the value used to initialize a variable.\n\nAs with the\nif\nstructure, if no local block is exectuted,\nthe expression returns either false (when other local blocks return a “bool” value) or na (in all other cases).\n\n​ switch ​ with an expression\n\nLet’s look at an example of a\nswitch\nusing an expression:\n\n//@version=6\nindicator(\"Switch using an expression\", \"\", true)\n\nstring maType = input.string(\"EMA\", \"MA type\", options = \\[\"EMA\", \"SMA\", \"RMA\", \"WMA\"\\])\nint maLength = input.int(10, \"MA length\", minval = 2)\n\nfloat ma = switch maType\n\"EMA\" => ta.ema(close, maLength)\n\"SMA\" => ta.sma(close, maLength)\n\"RMA\" => ta.rma(close, maLength)\n\"WMA\" => ta.wma(close, maLength)\n=\\>\nruntime.error(\"No matching MA type found.\")\nfloat(na)\n\nplot(ma)\n\nNote that:\n\n- The expression we are switching on is the variable maType, which\nis of “input int” type (see here for an explanation of what the\n“ input” qualifier is). Since it cannot change during the\nexecution of the script, this guarantees that whichever MA type the\nuser selects will be executing on each bar, which is a requirement\nfor functions like\nta.ema()\nwhich require a “simple int” argument for their length\nparameter.\n- If no matching value is found for maType, the\nswitch\nexecutes the last local block introduced by =>, which acts as a\ncatch-all. We generate a runtime error in that block. We also end it\nwith float(na) so the local block returns a value whose type is\ncompatible with that of the other local blocks in the structure, to\navoid a compilation error.\n\n​ switch ​ without an expression\n\nThis is an example of a\nswitch\nstructure which does not use an expression:\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\n\nbool longCondition = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\nlongCondition => strategy.entry(\"Long ID\", strategy.long)\nshortCondition => strategy.entry(\"Short ID\", strategy.short)\n\nNote that:\n\n- We are using the\nswitch\nto select the appropriate strategy order to emit, depending on\nwhether the longCondition or shortCondition “bool” variables\nare true.\n- The building conditions of longCondition and shortCondition are\nexclusive. While they can both be false simultaneously, they\ncannot be true at the same time. The fact that only one local\nblock of the\nswitch\nstructure is ever executed is thus not an issue for us.\n- We evaluate the calls to\nta.crossover()\nand\nta.crossunder() prior to entry in the\nswitch\nstructure. Not doing so, as in the following example, would prevent\nthe functions to be executed on each bar, which would result in a\ncompiler warning and erratic behavior:\n\n//@version=6\nstrategy(\"Switch without an expression\", \"\", true)\n\nswitch\n// Compiler warning! Will not calculate correctly!\nta.crossover( ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Long ID\", strategy.long)\nta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Short ID\", strategy.short)\n\nMatching local block type requirement\n\nWhen multiple local blocks are used in structures, the type of the\nreturn value of all its local blocks must match. This applies only if\nthe structure is used to assign a value to a variable in a declaration,\nbecause a variable can only have one type, and if the statement returns\ntwo incompatible types in its branches, the variable type cannot be\nproperly determined. If the structure is not assigned anywhere, its\nbranches can return different values.\n\nThis code compiles fine because\nclose\nand\nopen\nare both of the float type:\n\nx = if close > open\nclose\nelse\nopen\n\nThis code does not compile because the first local block returns a\nfloat value, while the second one returns a string, and the result\nof the if-statement is assigned to the x` variable:\n\n// Compilation error!\nx = if close > open\nclose\nelse\n\"open\"\n\nPrevious\\\\\nOperators Next\\\\\nLoops",
    "examples": [
      "if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[<declaration_mode>] [<type>] <identifier> = if <expression>\n\n    <local_block>\n\n{else if <expression>\n\n    <local_block>}\n\n[else\\\n\\\n    <local_block>]",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n\n    {<expression> => <local_block>}\n\n    => <local_block>",
      "[[<declaration_mode>] [<type>] <identifier> = ]switch\n\n    {<expression> => <local_block>}\n\n    => <local_block>"
    ],
    "type": "language_concept"
  },
  "loops": {
    "content": "Loops\n\nIntroduction\n\nLoops are structures that repeatedly execute a block of statements based on specified criteria. They allow scripts to perform repetitive tasks without requiring duplicated lines of code. Pine Script® features three distinct loop types: for, while, and for…in.\n\nEvery loop structure in Pine Script consists of two main parts: a _loop header_ and a _loop body_. The loop header determines the criteria under which the loop executes. The loop body is the indented block of code ( local block) that the script executes on each loop cycle ( _iteration_) as long as the header’s conditions remain valid. See the Common characteristics section to learn more.\n\nUnderstanding when and how to use loops is essential for making the most of the power of Pine Script. Inefficient or unnecessary usage of loops can lead to suboptimal runtime performance. However, effectively using loops when necessary enables scripts to perform a wide range of calculations that would otherwise be impractical or impossible without them.\n\nWhen loops are unnecessary\n\nPine’s execution model and time series structure make loops _unnecessary_ in many situations.\n\nWhen a user adds a Pine script to a chart, it runs within the equivalent of a _large loop_, executing its code once on _every_ historical bar and realtime tick in the available data. Scripts can access the values from the executions on previous bars with the history-referencing operator, and calculated values can _persist_ across executions when assigned to variables declared with the var or varip keywords. These capabilities enable scripts to utilize bar-by-bar calculations to accomplish various tasks instead of relying on explicit loops.\n\nIn addition, several built-ins, such as those in the ta.* namespace, are internally optimized to eliminate the need to use loops for various calculations.\n\nLet’s consider a simple example demonstrating unnecessary loop usage in Pine Script. To calculate the average close over a specified number of bars, newcomers to Pine may write a code like the following, which uses a for loop to calculate the sum of historical values over lengthInput bars and divides the result by the lengthInput:\n\n//@version=6\nindicator(\"Unnecessary loops demo\", overlay = true)\n\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n\n//@variable The sum of \\close\\ values over \\lengthInput\\ bars.\nfloat closeSum = 0\n\n// Loop over the most recent \\lengthInput\\ bars, adding each bar's \\close\\ to the \\closeSum\\.\nfor i = 0 to lengthInput - 1\ncloseSum += close\\[i\\]\n\n//@variable The average \\close\\ value over \\lengthInput\\ bars.\nfloat avgClose = closeSum / lengthInput\n\n// Plot the \\avgClose\\.\nplot(avgClose, \"Average close\", color.orange, 2)\n\nUsing a for loop is an unnecessary, inefficient way to accomplish tasks like this in Pine. There are several ways to utilize the execution model and the available built-ins to eliminate this loop. Below, we replaced these calculations with a simple call to the ta.sma() function. This code is shorter, and it achieves the same result much more efficiently:\n\n//@version=6\nindicator(\"Unnecessary loops corrected demo\", overlay = true)\n\n//@variable The number of bars in the calculation window.\nint lengthInput = input.int(defval = 20, title = \"Length\")\n\n//@variable The average \\close\\ value over \\lengthInput\\ bars.\nfloat avgClose = ta.sma(close, lengthInput)\n\n// Plot the \\avgClose\\.\nplot(avgClose, \"Average close\", color.blue, 2)\n\nNote that:\n\n- Users can see the substantial difference in efficiency between these two example scripts by analyzing their performance with the Pine Profiler.\n\nWhen loops are necessary\n\nAlthough Pine’s execution model, time series, and available built-ins often eliminate the need for loops in many cases, not all iterative tasks have loop-free alternatives. Loops _are necessary_ for several types of tasks, including:\n\n- Iterating through or manipulating collections ( arrays, matrices, and maps)\n- Performing calculations that one cannot accomplish with loop-free expressions or the available built-ins\n- Looking back through history to analyze past bars with a reference value only available on the _current bar_\n\nFor example, a loop is _necessary_ to identify which past bars’ high values are above the current bar’s high because the current value is not obtainable during a script’s executions on previous bars. The script can only access the current bar’s value while it executes on that bar, and it must _look back_ through the historical series during that execution to compare the previous values.\n\nThe script below uses a for loop to compare the high values of lengthInput previous bars with the last historical bar’s high. Within the loop, it calls label.new() to draw a circular label above each past bar that has a high value exceeding that of the last historical bar:\n\n//@version=6\nindicator(\"Necessary loop demo\", overlay = true, max\\_labels\\_count = 500)\n\n//@variable The number of previous \\high\\ values to compare to the last historical bar's \\high\\.\nint lengthInput = input.int(20, \"Length\", 1, 500)\n\nif barstate.islastconfirmedhistory\n// Draw a horizontal line segment at the last historical bar's \\high\\ to visualize the level.\nline.new(bar\\_index - lengthInput, high, bar\\_index, high, color = color.gray, style = line.style\\_dashed, width = 2)\n// Create a \\for\\ loop that counts from 1 to \\lengthInput\\.\nfor i = 1 to lengthInput\n// Draw a circular \\label\\ above the bar from \\i\\ bars ago if that bar's \\high\\ is above the current \\high\\.\nif high\\[i\\] > high\nlabel.new(\nbar\\_index - i, na, \"\", yloc = yloc.abovebar, color = color.purple,\nstyle = label.style\\_circle, size = size.tiny\n)\n\n// Highlight the last historical bar.\nbarcolor(barstate.islastconfirmedhistory ? color.orange : na, title = \"Last historical bar highlight\")\n\nNote that:\n\n- Each _iteration_ of the for loop retrieves a previous bar’s high with the history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D), using the loop’s _counter_ ( i) as the historical offset. The label.new() call also uses the counter to determine each label’s x-coordinate.\n- The indicator declaration statement includes max_labels_count = 500, meaning the script can show up to 500 labels on the chart.\n- The script calls barcolor() to highlight the last historical chart bar, and it draws a horizontal line at that bar’s high for visual reference.\n\nCommon characteristics\n\nThe for, while, and for…in loop statements all have similarities in their structure, syntax, and general behavior. Before we explore each specific loop type, let’s familiarize ourselves with these characteristics.\n\nStructure and syntax\n\nIn any loop statement, programmers define the criteria under which a script remains in a loop and performs _iterations_, where an iteration refers to _one execution_ of the code within the loop’s local block ( _body_). These criteria are part of the _loop header_. A script evaluates the header’s criteria _before_ each iteration, only allowing new iterations to occur while they remain valid. When the header’s criteria are no longer valid, the script _exits_ the loop and skips over its body.\n\nThe specific header syntax varies with each loop statement ( for, while, or for…in) because each uses _distinct_ criteria to control its iterations. Effective use of loops entails choosing the structure with control criteria best suited for a script’s required tasks. See the \\for\\ loops, \\while\\ loops, and \\for…in\\ loops sections below for more information on each loop statement and its control criteria.\n\nAll loop statements in Pine Script follow the same general syntax:\n\n``\n\n[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere:\n\n- loop_header represents the loop structure’s header statement, which defines the criteria that control the loop’s iterations.\n- statements represents the code statements and expressions within the loop’s body, i.e., the _indented_ block of code beneath the loop header. All code within the body belongs to the loop’s local scope.\n- continue and break are loop-specific _keywords_ that control the flow of a loop’s iterations. The continue keyword instructs the script to _skip_ the remainder of the current loop iteration and _continue_ to the next iteration. The break keyword prompts the script to _stop_ the current iteration and _exit_ the loop entirely. See this section below for more information.\n- return_expression refers to the _last_ code line or block within the loop’s body. The loop returns the results from this code after the final iteration. If the loop skips parts of some iterations or stops prematurely due to a continue or break statement, the returned values or references are those of the latest iteration that evaluated this code. To use the loop’s returned results, assign them to a variable or tuple.\n- variables represents an optional variable or tuple to hold the values or references from the last evaluation of the return_expression. The script can assign the loop’s returned results to variables only if the results are not void. If the loop’s conditions prevent iteration, or if no iterations evaluate the return_expression, the variables’ assigned values and references are na.\n\nScope\n\nAll code lines that a script executes within a loop must have an indentation of _four spaces_ or a _tab_ relative to the loop’s header. The indented lines following the header define the loop’s _body_. This code represents a _local block_, meaning that all the definitions within the body are accessible only during the loop’s execution. In other words, the code within the loop’s body is part of its _local scope_.\n\nScripts can modify and reassign most variables from _outer_ scopes inside a loop. However, any variables declared within the loop’s body strictly belong to that loop’s local scope. A script cannot access a loop’s declared variables _outside_ its local block.\n\nNote that:\n\n- Variables declared within a loop’s _header_ are also part of the local scope. For instance, a script cannot use the _counter variable_ in a for loop anywhere but within the loop’s local block.\n\nThe body of any Pine loop statement can include conditional structures and _nested_ loop statements. When a loop includes nested structures, each structure within the body maintains a _distinct_ local scope. For example, variables declared within an _outer_ loop’s scope are accessible to an _inner_ loop. However, any variables declared within the inner loop’s scope are not accessible to the outer loop.\n\nThe simple example below demonstrates how a loop’s local scope works. This script calls label.new() within a for loop on the last historical bar to draw labels above lengthInput past bars. The color of each label depends on the labelColor variable declared _within_ the loop’s local block, and each label’s location depends on the loop counter ( i):\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\n\nif barstate.islastconfirmedhistory\nfor i = 1 to lengthInput\n//@variable Has a value of \\color.blue\\ if \\close\\[i\\]\\ is above the current \\close\\, \\color.orange\\ otherwise.\n// This variable is LOCAL to the \\for\\ loop's scope.\ncolor labelColor = close\\[i\\] > close ? color.blue : color.orange\n// Display a colored \\label\\ on the historical \\high\\ from \\i\\ bars back, using \\labelColor\\ to set the color.\nlabel.new(bar\\_index - i, high\\[i\\], \"\", color = labelColor, size = size.normal)\n\nIn the above code, the i and labelColor variables are only accessible to the for loop’s local scope. They are not usable within any outer scopes. Here, we added a label.new() call _after_ the loop with bar_index - i as the x argument and labelColor as the color argument. This code causes a _compilation error_ because neither i nor labelColor are valid variables in the outer scope:\n\n//@version=6\nindicator(\"Loop scope demo\", overlay = true)\n\n//@variable The number of bars in the calculation.\nint lengthInput = input.int(20, \"Lookback length\", 1)\n\nif barstate.islastconfirmedhistory\nfor i = 1 to lengthInput\n//@variable Has a value of \\color.blue\\ if \\close\\[i\\]\\ is above the current \\close\\, \\color.orange\\ otherwise.\n// This variable is LOCAL to the \\for\\ loop's scope.\ncolor labelColor = close\\[i\\] > close ? color.blue : color.orange\n// Display a colored \\label\\ on the historical \\high\\ from \\i\\ bars back, using \\labelColor\\ to set the color.\nlabel.new(bar\\_index - i, high\\[i\\], \"\", color = labelColor, size = size.normal)\n\n// Call \\label.new()\\ to using the \\i\\ and \\labelColor\\ variables outside the loop's local scope.\n// This code causes a compilation error because these variables are not accessible in this location.\nlabel.new(\nbar\\_index - i, low, \"Scope test\", textcolor = color.white, color = labelColor, style = label.style\\_label\\_up\n)\n\nKeywords and return expressions\n\nEvery loop in Pine Script implicitly _returns_ values, references, or void. A loop’s returned results come from the _latest_ execution of the _last_ expression or nested structure within its body as of the final iteration. The results are usable only if they are not of the void type. Loops return na results for values or references when no iterations occur. Scripts can add a variable or tuple assignment to a loop statement to hold the returned results for use in additional calculations outside the loop’s local scope.\n\nThe values or references that a loop returns usually come from evaluating the last written expression or nested code block on the _final_ iteration. However, a loop’s body can include continue and break keywords to control the flow of iterations beyond the criteria the loop header specifies, which can also affect the returned results. Programmers often include these keywords within conditional structures to control how iterations behave when certain conditions occur.\n\nThe continue keyword instructs a script to _skip_ the remaining statements and expressions in the current loop iteration, re-evaluate the loop header’s criteria, and proceed to the _next_ iteration. The script _exits_ the loop if the header’s criteria do not allow another iteration.\n\nThe break keyword instructs a script to _stop_ the loop entirely and immediately _exit_ at that point without allowing any subsequent iterations. After breaking the loop, the script skips any remaining code within the loop’s body and _does not_ re-evaluate the header’s criteria.\n\nIf a loop skips parts of iterations or stops prematurely due to a continue or break statement, it returns the values and references from the _last iteration_ where the script _evaluated_ the return expression. If the script did not evaluate the return expression across _any_ of the loop’s iterations, the loop returns na results for all non-void types.\n\nThe example below selectively displays numbers from an array within a label on the last historical bar. It uses a for…in loop to iterate through the array’s elements and build a “string” to use as the displayed text. The loop’s body contains an if statement that controls the flow of specific iterations. If the number in the current iteration is 8, the script immediately _exits_ the loop using the break keyword. Otherwise, if the number is even, it _skips_ the rest of the current iteration and moves to the next one using the continue keyword.\n\nIf neither of the if statement’s conditions occur, the script evaluates the _last expression_ within the loop’s body (i.e., the return expression), which converts the current number to a “string” and concatenates the result with the tempString value. The loop returns the _last evaluated result_ from this expression after termination. The script assigns the returned value to the finalLabelText variable and uses that variable as the text argument in the label.new() call:\n\n//@version=6\nindicator(\"Loop keywords and variable assignment demo\")\n\n//@variable An \\array\\ of arbitrary \"int\" values to selectively convert to \"string\" and display in a \\label\\.\nvar array<int> randomArray = array.from(1, 5, 2, -3, 14, 7, 9, 8, 15, 12)\n\n// Label creation logic.\nif barstate.islastconfirmedhistory\n//@variable A \"string\" containing representations of selected values from the \\randomArray\\.\nstring tempString = \"\"\n//@variable The final text to display in the \\label\\. The \\for..in\\ loop returns the result after it terminates.\nstring finalLabelText = for number in randomArray\n// Stop the current iteration and exit the loop if the \\number\\ from the \\randomArray\\ is 8.\nif number == 8\nbreak\n// Skip the rest of the current iteration and proceed to the next iteration if the \\number\\ is even.\nelse if number % 2 == 0\ncontinue\n// Convert the \\number\\ to a \"string\", append \", \", and concatenate the result with the current \\tempString\\.\n// This code represents the loop's return expression.\ntempString += str.tostring(number) + \", \"\n\n// Display the value of the \\finalLabelText\\ within a \\label\\ on the current bar.\nlabel.new(bar\\_index, 0, finalLabelText, color = color.blue, textcolor = color.white, size = size.huge)\n\nNote that:\n\n- The label displays only _odd_ numbers from the array because the script does not reassign the tempString when the loop iteration’s number is even. However, it does not include the _last_ odd number from the array (15) because the loop stops when number == 8, preventing iteration over the remaining randomArray elements.\n- When the script exits the loop due to the break keyword, the loop’s return value becomes the last evaluated result from the tempString reassignment expression. In this case, the last time that code executes is on the iteration where number == 9.\n\n​ for ​ loops\n\nThe for loop statement creates a _count-controlled_ loop, which uses a _counter_ variable to manage the iterative executions of its local code block. The counter starts at a predefined initial value, and the loop increments or decrements the counter by a fixed amount after each iteration. The loop stops its iterations after the counter reaches a specified final value.\n\nPine Script uses the following syntax to define a for loop:\n\n`\n\n[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the following parts define the _loop header_:\n\n- counter represents the counter variable, which can be any valid identifier. The loop increments or decrements this variable’s value from the initial value ( from_num) to the final value ( to_num) by a fixed amount ( step_num) after each iteration. The last possible iteration occurs when the variable’s value reaches the to_num value.\n- from_num is the counter variable’s initial value on the first iteration.\n- to_num is the _final_ counter value for which the loop’s header allows a new iteration. The loop adjusts the counter value by the step_num amount until it reaches or passes this value. If the script modifies the to_num during a loop iteration, the loop header uses the new value to control the allowed subsequent iterations.\n- step_num is a positive value representing the amount by which the counter value increases or decreases until it reaches or passes the to_num value. If the from_num value is greater than the _initial_ to_num value, the loop _subtracts_ this amount from the counter value after each iteration. Otherwise, the loop _adds_ this amount after each iteration. The default is 1.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThis simple script demonstrates a for loop that draws several labels at future bar indices during its execution on the last historical chart bar. The loop’s counter starts at 0, then increases by 1 until it reaches a value of 10, at which point the final iteration occurs:\n\n//@version=6\nindicator(\"Simple \\for\\ loop demo\")\n\nif barstate.islastconfirmedhistory\n// Define a \\for\\ loop that iterates from \\i == 0\\ to \\i == 10\\ by 1 (11 total iterations).\nfor i = 0 to 10\n// Draw a new label \\i\\ bars ahead of the current bar.\nlabel.new(bar\\_index + i, 0, str.tostring(i), textcolor = color.white, size = size.large)\n\nNote that:\n\n- The i variable represents the loop’s _counter_. This variable is local to the loop’s scope, meaning no _outer scopes_ can access it. The code uses the variable within the loop’s body to determine the location and text of each label drawing.\n- Programmers often use i, j, and k as loop counter identifiers. However, _any_ valid variable name is allowed. For example, this code behaves the same if we name the counter offset instead of i.\n- The for loop structure _automatically_ manages the counter variable. We do not need to define code in the loop’s body to increment its value.\n\nThe direction in which a for loop adjusts its counter depends on the _initial_ from_num and to_num values in the loop’s header, and the direction does not change across iterations. The loop counts _upward_ after each iteration when the to_num value is _above_ the from_num value, as shown in the previous example. If the to_num value is _below_ the from_num value, the loop counts _downward_ instead.\n\nThe script below calculates and plots the volume-weighted moving average (VWMA) of open prices across a specified number of bars. Then, it uses a downward-counting for loop to compare the last historical bar’s value to the values from previous bars, starting with the oldest bar in the specified lookback window. On each loop iteration, the script retrieves a previous bar’s vwmaOpen value, calculates the difference from the current bar’s value, and displays the result in a label at the past bar’s opening price:\n\n//@version=6\nindicator(\"\\for\\ loop demo\", \"VWMA differences\", true, max\\_labels\\_count = 500)\n\n//@variable Display color for indicator visuals.\nconst color DISPLAY\\_COLOR = color.rgb(17, 127, 218)\n\n//@variable The number of bars in the \\vwmaOpen\\ calculation.\nint maLengthInput = input.int(20, \"VWMA length\", 1)\n//@variable The number of past bars to look back through and compare to the current bar.\nint lookbackInput = input.int(15, \"Lookback length\", 1, 500)\n\n//@variable The volume-weighted moving average of \\open\\ values over \\maLengthInput\\ bars.\nfloat vwmaOpen = ta.vwma(open, maLengthInput)\n\nif barstate.islastconfirmedhistory\n// Define a \\for\\ loop that counts \\downward\\ from \\i == lookbackInput\\ to \\i == 1\\.\nfor i = lookbackInput to 1\n//@variable The difference between the \\vwmaOpen\\ from \\i\\ bars ago and the current \\vwmaOpen\\.\nfloat vwmaDifference = vwmaOpen\\[i\\] - vwmaOpen\n//@variable A \"string\" representation of \\vwmaDifference\\, rounded to two fractional digits.\nstring displayText = (vwmaDifference > 0 ? \"+\" : \"\") + str.tostring(vwmaDifference, \"0.00\")\n// Draw a label showing the \\displayText\\ at the \\open\\ of the bar from \\i\\ bars back.\nlabel.new(\nbar\\_index - i, open\\[i\\], displayText, textcolor = color.white, color = DISPLAY\\_COLOR,\nstyle = label.style\\_label\\_lower\\_right, size = size.normal\n)\n\n// Plot the \\vwmaOpen\\ value.\nplot(vwmaOpen, \"VWMA\", color = DISPLAY\\_COLOR, linewidth = 2)\n\nNote that:\n\n- The script uses the loop’s counter ( i) to within the history-referencing operator to retrieve past values of the vwmaOpen series. It also uses the counter to determine the location of each label drawing.\n- The loop in this example _decreases_ the counter by one on each iteration because the final counter value in the loop’s header ( 1) is less than the starting value ( lookbackInput).\n\nProgrammers can use for loops to iterate through collections, such as arrays and matrices. The loop’s counter can serve as an _index_ for retrieving or modifying a collection’s contents. For example, this code block uses array.get() inside a for loop to successively retrieve elements from an array:\n\nint lastIndex = array.size(myArray) - 1\nfor i = 0 to lastIndex\nelement = array.get(i)\n\nNote that:\n\n- Array _indexing_ starts from 0, but the array.size() function _counts_ array elements starting from 1. Therefore, we must subtract 1 from the array’s size to get the maximum index value. This way, the loop counter avoids representing an out-of-bounds index on the last loop iteration.\n- The for…in loop statement is often the _preferred_ way to loop through collections. However, programmers may prefer a for loop for some tasks, such as looping through stepped index values, iterating over a collection’s contents in reverse or a nonlinear order, and more. See the Looping through arrays and Looping through matrices sections to learn more about the best practices for looping through these collection types.\n\nThe script below executes ta.rsi() and ta.mom() calls to calculate the RSI and momentum of close prices over three different lengths (10, 20, and 50), then displays the results using a table on the last chart bar. It stores “string” values for the header title within arrays and the “float” values of the calculated indicators within a 2x3 matrix. The script uses a for loop to access the elements in the arrays and initialize the displayTable header cells. It then uses _nested_ for loops to iterate over the _row_ and _column_ indices in the taMatrix, access elements, convert their values to strings, and populate the remaining table cells:\n\n//@version=6\nindicator(\"\\for\\ loop with collections demo\", \"Table of TA Indexes\", overlay = true)\n\n// Calculate the RSI and momentum of \\close\\ values with constant lengths of 10, 20, and 50.\nfloat rsi10 = ta.rsi(close, 10)\nfloat rsi20 = ta.rsi(close, 20)\nfloat rsi50 = ta.rsi(close, 50)\nfloat mom10 = ta.mom(close, 10)\nfloat mom20 = ta.mom(close, 20)\nfloat mom50 = ta.mom(close, 50)\n\nif barstate.islast\n//@variable A \\table\\ that displays indicator values in the top-right corner of the chart.\nvar table displayTable = table.new(\nposition.top\\_right, columns = 5, rows = 4, border\\_color = color.black, border\\_width = 1\n)\n//@variable An array containing the \"string\" titles to display within the side header of each table row.\narray<string> sideHeaderTitles = array.from(\"TA Index\", \"RSI\", \"Momentum\")\n//@variable An array containing the \"string\" titles to representing the length of each displayed indicator.\narray<string> topHeaderTitles = array.from(\"10\", \"20\", \"50\")\n//@variable A matrix containing the values to display within the table.\nmatrix<float> taMatrix = matrix.new<float>()\n// Populate the \\taMatrix\\ with indicator values. The first row contains RSI data and the second contains momentum.\ntaMatrix.add\\_row(0, array.from(rsi10, rsi20, rsi50, mom10, mom20, mom50))\ntaMatrix.reshape(2, 3)\n\n// Initialize top header cells.\ndisplayTable.cell(1, 0, \"Bars Length\", text\\_color = color.white, bgcolor = color.blue)\ndisplayTable.merge\\_cells(1, 0, 3, 0)\n\n// Initialize additional header cells within a \\for\\ loop.\nfor i = 0 to 2\ndisplayTable.cell(0, i + 1, sideHeaderTitles.get(i), text\\_color = color.white, bgcolor = color.blue)\ndisplayTable.cell(i + 1, 1, topHeaderTitles.get(i), text\\_color = color.white, bgcolor = color.purple)\n\n// Use nested \\for\\ loops to iterate through the row and column indices of the \\taMatrix\\.\nfor i = 0 to taMatrix.rows() - 1\nfor j = 0 to taMatrix.columns() - 1\n//@variable The value stored in the \\taMatrix\\ at the \\i\\ row and \\j\\ column.\nfloat elementValue = taMatrix.get(i, j)\n// Initialize a cell in the \\displayTable\\ at the \\i + 2\\ row and \\j + 1\\ column showing a \"string\"\n// representation of the \\elementValue\\.\ndisplayTable.cell(\ncolumn = j + 1, row = i + 2, text = str.tostring(elementValue, \".\"), text\\_color = chart.fg\\_color\n)\n\nNote that:\n\n- Both arrays of header names ( sideHeaderTitles and topHeaderTitles) contain the same number of elements, enabling the script to iterate through their contents simultaneously using a single for loop.\n- The nested for loops iterate over _all_ the index values in the taMatrix. The _outer_ loop iterates over each _row_ index, and the _inner_ loop iterates over every _column_ index on each outer loop iteration.\n- The script creates and displays the table only on the last historical bar and all realtime bars because the historical states of tables are _never_ visible. See the Reducing drawing updates of the Profiling and optimization page for more information.\n\nIt’s important to note that a for loop’s header _dynamically_ evaluates the to_num value at the start of _every iteration_. If the to_num argument is a variable and the script changes its value during an iteration, the loop uses the _new value_ to update its stopping condition. Likewise, the stopping condition can change across iterations when the to_num argument is an expression or function call that depends on data modified in the loop’s scope, such as a call to array.size() on a locally resized array or str.length() on an adjusted string. Therefore, scripts can use for loops to perform iterative tasks where the exact number of required iterations is _not predictable_ in advance, similar to while loops.\n\nFor example, the following script uses a dynamic for loop to determine the historical offset of the most recent bar whose close differs from the current bar’s close by at least one standard deviation. The script declares a barOffset variable with an initial value of zero and uses that variable to define the loop counter’s to_num boundary. Within the loop’s scope, the script increments the barOffset by one if the referenced bar’s close is not far enough from the current bar’s value. Each time the barOffset value increases, the loop increases its final counter value, allowing an _extra iteration_. The script plots the barOffset and the corresponding bar’s close for visual reference:\n\n//@version=6\nindicator(\"\\for\\ loop with dynamic \\to\\_num\\ demo\")\n\n//@variable The length of the standard deviation.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n\n//@variable The standard deviation of \\close\\ prices over \\lengthInput\\ bars.\nfloat stdev = ta.stdev(close, lengthInput)\n\n//@variable The minimum bars back where the past bar's \\close\\ differs from the current \\close\\ by at least \\stdev\\.\n// Used as the weight value in the weighted average.\nint barOffset = 0\n\n// Define a \\for\\ loop that iterates from 0 to \\barsBack\\.\nfor i = 0 to barOffset\n// Add 1 for each bar where the distance from that bar's \\close\\ to the current bar's \\close\\ is less than \\stdev\\.\n// Each time \\barsBack\\ increases, it changes the loop's \\to\\_num\\ boundary, allowing another iteration.\nbarOffset += math.abs(close - close\\[i\\]) < stdev ? 1 : 0\n\n//@variable A gradient color for the \\barOffset\\ plot.\ncolor offsetColor = color.from\\_gradient(barOffset, 0, lengthInput, color.blue, color.orange)\n\n// Plot the \\barOffset\\ in a separate pane.\nplot(barOffset, \"Bar offset\", offsetColor, 1, plot.style\\_columns)\n// Plot the historical \\close\\ price from \\barOffset\\ bars back in the main chart pane.\nplot(close\\[barOffset\\], \"Historical bar's price\", color.blue, 3, force\\_overlay = true)\n\nNote that:\n\n- Changing the to_num value on an iteration does not affect the established _direction_ in which the loop adjusts its counter variable. For instance, if the loop in this example changed barOffset to -1 on any iteration, it would stop immediately after that iteration ends without reducing the i value.\n- The script uses force_overlay = true in the second plot() call to display the historical closing price on the main chart pane.\n\n​ while ​ loops\n\nThe while loop statement creates a _condition-controlled_ loop, which uses a _conditional expression_ to control the executions of its local block. The loop continues its iterations as long as the specified condition remains true.\n\nPine Script uses the following syntax to define a while loop:\n\n`\n\n[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere the condition in the loop’s _header_ can be a literal, variable, expression, or function call that returns a “bool” value.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nA while loop’s header evaluates its condition before each iteration. Consequently, when the script modifies the condition within an iteration, the loop’s header reflects those changes on the _next_ iteration.\n\nDepending on the specified condition in the loop header, a while loop can behave similarly to a for loop, continuing iteration until a _counter_ variable reaches a specified limit. For example, the following script uses a for loop and while loop to perform the same task. Both loops draw a label displaying their respective counter value on each iteration:\n\n//@version=6\nindicator(\"\\while\\ loop with a counter condition demo\")\n\nif barstate.islastconfirmedhistory\n// A \\for\\ loop that creates blue labels displaying each \\i\\ value.\nfor i = 0 to 10\nlabel.new(\nbar\\_index + i, 0, str.tostring(i), color = color.blue, textcolor = color.white,\nsize = size.large, style = label.style\\_label\\_down\n)\n\n//@variable An \"int\" to use as a counter within a \\while\\ loop.\nint j = 0\n// A \\while\\ loop that creates orange labels displaying each \\j\\ value.\nwhile j <= 10\nlabel.new(\nbar\\_index + j, 0, str.tostring(j), color = color.orange, textcolor = color.white,\nsize = size.large, style = label.style\\_label\\_up\n)\n// Update the \\j\\ counter within the local block.\nj += 1\n\nNote that:\n\n- When a while loop uses count-based logic, it must explicitly manage the user-specified counter within the local block. In contrast, a for loop increments its counter automatically.\n- The script declares the variable the while loop uses as a counter _outside_ the loop’s scope, meaning its value is usable in additional calculations after the loop terminates.\n- If this code did not increment the j variable within the while loop’s body, the value would _never_ reach 10, meaning the loop would run _indefinitely_ until causing a runtime error.\n\nBecause a while loop’s execution depends on its condition remaining true, and the condition might not change on a specific iteration, the _precise_ number of expected iterations might not be knowable _before_ the loop begins. Therefore, while loops are often helpful in scenarios where the exact loop boundaries are _unknown_.\n\nThe script below tracks when the chart’s close crosses outside Keltner Channels with a user-specified length and channel width. When the price crosses outside the current bar’s channel, the script draws a box highlighting all the previous _consecutive_ bars with close values within that price window. The script uses a while loop to analyze past bars’ prices and incrementally adjust the left side of each new box until the drawing covers all the latest consecutive bars in the current range:\n\n//@version=6\nindicator(\"\\while\\ loop demo\", \"Price window boxes\", true)\n\n//@variable The length of the channel.\nint lengthInput = input.int(20, \"Channel length\", 1, 4999)\n//@variable The width multiplier of the channel.\nfloat widthInput = input.float(2.0, \"Width multiplier\", 0)\n\n//@variable The \\lengthInput\\-bar EMA of \\close\\ prices.\nfloat ma = ta.ema(close, lengthInput)\n//@variable The \\lengthInput\\-bar ATR, multiplied by the \\widthInput\\.\nfloat atr = ta.atr(lengthInput) \\* widthInput\n//@variable The lower bound of the channel.\nfloat channelLow = ma - atr\n//@variable The upper bound of the channel.\nfloat channelHigh = ma + atr\n\n//@variable Is \\true\\ when the \\close\\ price is outside the current channel range, \\false\\ otherwise.\nbool priceOutsideChannel = close < channelLow or close > channelHigh\n\n// Check if the \\close\\ crossed outside the channel range, then analyze the past bars within the current range.\nif priceOutsideChannel and not priceOutsideChannel\\[1\\]\n//@variable A box that highlights consecutive past bars within the current channel's price window.\nbox windowBox = box.new(\nbar\\_index, channelHigh, bar\\_index, channelLow, border\\_width = 2, bgcolor = color.new(color.gray, 85)\n)\n//@variable The lookback index for box adjustment. The \\while\\ loop increments this value on each iteration.\nint i = 1\n// Use a \\while\\ loop to look backward through close\\ prices. The loop iterates as long as the past \\close\\\n// from \\i\\ bars ago is between the current bar's \\channelLow\\ and \\channelHigh\\.\nwhile close\\[i\\] >= channelLow and close\\[i\\] <= channelHigh\n// Adjust the left side of the box.\nwindowBox.set\\_left(bar\\_index - i)\n// Add 1 to the \\i\\ value to check the \\close\\ from the next bar back on the next iteration.\ni += 1\n\n// Plot the \\channelLow\\ and \\channelHigh\\ for visual reference.\nplot(channelLow, \"Channel low\")\nplot(channelHigh, \"Channel high\")\n\nNote that:\n\n- The left and right edges of boxes sit within the horizontal _center_ of their respective bars, meaning that each drawing spans from the middle of the first consecutive bar to the middle of the last bar within each window.\n- This script uses the i variable as a history-referencing index within the _conditional expression_ the while loop checks on each iteration. The variable does not behave as a loop counter, as the iteration boundaries are unknown. The loop executes its local block repeatedly until the condition becomes false.\n\n​ for...in ​ loops\n\nThe for…in loop statement creates a _collection-controlled_ loop, which uses the _contents_ of a collection to control its iterations. This loop structure is often the preferred approach for looping through arrays, matrices, and maps.\n\nA for…in loop traverses a collection _in order_, retrieving one of its stored items on each iteration. Therefore, the loop’s boundaries depend directly on the number of _items_ ( array _elements_, matrix _rows_, or map _key-value pairs_).\n\nPine Script features _two_ general forms of the for…in loop statement. The _first form_ uses the following syntax:\n\n``\n\n[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere item is a _variable_ that holds sequential values or references from the specified collection_id. The variable starts with the collection’s _first item_ and takes on successive items in order after each iteration. This form is convenient when a script must access values from an array or matrix iteratively but does not require the item’s _index_ in its calculations.\n\nThe _second form_ has a slightly different syntax that includes a tuple in its _header_:\n\n`\n\n[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression\n`\n\nWhere index is a variable that contains the _index_ or _key_ of the retrieved item. This form is convenient when a task requires using a collection’s items _and_ their indices in iterative calculations. This form of the for…in loop is _required_ when directly iterating through the contents of a map. See this section below for more information.\n\nRefer to the Common characteristics section above for detailed information about the variables, statements, continue, break, and return_expression parts of the loop’s syntax.\n\nThe iterative behavior of a for…in loop depends on the _type_ of collection the header specifies as the collection_id:\n\n- When using an array in the header, the loop performs _element-wise_ iteration, meaning the retrieved item on each iteration is one of the array’s _elements_.\n- When using a matrix in the header, the loop performs _row-wise_ iteration, which means that each item represents a _row array_.\n- When using a map in the header, the loop performs _pair-wise_ iteration, which retrieves a _key_ and corresponding _value_ on each iteration.\n\nLooping through arrays\n\nPine scripts can iterate over the elements of arrays using any loop structure. However, the for…in loop is typically the most convenient because it automatically verifies the size of an array when controlling iterations. With other loop structures, programmers must carefully set the header’s boundaries or conditions to _prevent_ the loop from attempting to access an element at a _nonexistent_ index.\n\nFor example, a for loop can access an array’s elements using the counter variable as the lookup index in functions such as array.get(). However, programmers must ensure the counter always represents a _valid index_ to prevent out-of-bounds errors. Additionally, if an array might be _empty_, programmers must set conditions to prevent the loop’s execution entirely.\n\nThe code below shows a for loop whose counter boundaries depend on the number of elements in an array. If the array is empty, containing zero elements, the header’s final counter value is na, which _prevents_ iteration. Otherwise, the final value is _one less_ than the array’s size (i.e., the index of the last element):\n\nfor index = 0 to (array.size(myArray) == 0 ? na : array.size(myArray) - 1)\nelement = array.get(myArray, index)\n\nIn contrast, a for…in loop automatically validates an array’s size and _directly_ accesses its elements, providing a more convenient solution than a traditional for loop. The line below achieves the _same effect_ as the code above without requiring the programmer to define boundaries explicitly or use the array.get() function to access each element:\n\nfor element in myArray\n\nThe following example examines bars on a lower timeframe to gauge the strength of _intrabar_ trends within each chart bar. The script uses a request.security\\_lower\\_tf() call to retrieve an array of intrabar hl2 prices from a calculated lowerTimeframe. Then, it uses a for…in loop to access each price within the intrabarPrices array and compare the value to the current close to calculate the bar’s strength. The script plots the strength as columns in a separate pane:\n\n//@version=6\nindicator(\"\\for element in array\\ demo\", \"Intrabar strength\")\n\n//@variable A valid timeframe closest to one-tenth of the current chart's timeframe, \"1\" if the timeframe is too small.\nvar string lowerTimeframe = timeframe.from\\_seconds(math.max(int(timeframe.in\\_seconds() / 10), 60))\n//@variable An array of intrabar \\hl2\\ prices calculated from the \\lowerTimeframe\\.\narray<float> intrabarPrices = request.security\\_lower\\_tf(\"\", lowerTimeframe, hl2)\n\n//@variable The excess trend strength of \\intrabarPrices\\.\nfloat strength = 0.0\n\n// Loop directly through the \\intrabarPrices\\ array. Each iteration's \\price\\ represents an array element.\nfor price in intrabarPrices\n// Subtract 1 from the \\strength\\ if the retrieved \\price\\ is above the current bar's \\close\\ price.\nif price > close\nstrength -= 1\n// Add 1 to the \\strength\\ if the retrieved \\price\\ is below the current bar's \\close\\ price.\nelse if price < close\nstrength += 1\n\n//@variable Is \\color.teal\\ when the \\strength\\ is positive, \\color.maroon\\ otherwise.\ncolor strengthColor = strength > 0 ? color.teal : color.maroon\n\n// Plot the \\strength\\ as columns colored by the \\strengthColor\\.\nplot(strength, \"Intrabar strength\", strengthColor, 1, plot.style\\_columns)\n\nThe second form of the for…in loop is a convenient solution when a script’s calculations require accessing each element _and_ corresponding index within an array:\n\nfor \\[index, element\\] in myArray\n\nFor example, suppose we want to display a _numerated_ list of array elements within a label while excluding values at specific indices. We can use the second form of the for…in loop structure to accomplish this task. The simple script below declares a stringArray variable that references an array of predefined “string” values. On the last historical bar, the script uses a for…in loop to access each index and element in the stringArray to construct the labelText, which it uses in a label.new() call after the loop ends:\n\n//@version=6\nindicator(\"\\for \\[index, item\\] in array\\ demo\", \"Array numerated output\")\n\n//@variable An array of \"string\" values to display as a numerated list.\nvar array<string> stringArray = array.from(\"First\", \"Second\", \"Third\", \"Before Last\", \"Last\")\n\nif barstate.islastconfirmedhistory\n//@variable A \"string\" modified within a loop to display within the \\label\\.\nstring labelText = \"Array values: \\\\n\"\n// Loop through the \\stringArray\\, accessing each \\index\\ and corresponding \\element\\.\nfor \\[index, element\\] in stringArray\n// Skip the third \\element\\ (at \\index == 2\\) in the \\labelText\\. Include an \"ELEMENT SKIPPED\" message instead.\nif index == 2\nlabelText += \"-- ELEMENT SKIPPED -- \\\\n\"\ncontinue\nlabelText += str.tostring(index + 1) + \": \" + element + \"\\\\n\"\n// Display the \\labelText\\ within a \\label\\.\nlabel.new(\nbar\\_index, 0, labelText, textcolor = color.white, size = size.huge,\nstyle = label.style\\_label\\_center, textalign = text.align\\_left\n)\n\nNote that:\n\n- This example adds 1 to the index in the str.tostring() call to start the numerated list with a value of \"1\", because array indices always begins at 0.\n- On the _third_ loop iteration, when index == 2, the script adds an \"-- ELEMENT SKIPPED --\" message to the labelText instead of the retrieved element and uses the continue keyword to skip the remainder of the iteration. See this section above to learn more about loop keywords.\n\nLet’s explore an advanced example demonstrating the utility of for…in loops. The following indicator draws a fixed number of horizontal lines at pivot high values calculated from a ta.pivothigh() call, and it analyzes the lines within a loop to determine which ones represent active ( _uncrossed_) pivots.\n\nEach time the script detects a new pivot high point, it creates a new line, _inserts_ that line at the beginning of the pivotLines array, then removes the oldest element and deletes its ID. The script accesses each line within the array using a for…in loop, analyzing and modifying the properties of the line referenced on each iteration. When the current high crosses above the pivotLine, the script changes its style to signify that it is no longer an active level. Otherwise, it extends the line’s x2 coordinate and uses its price to calculate the average _active_ pivot value. The script also plots each pivot high value and the average active pivot value on the chart:\n\n//@version=6\nindicator(\"\\for...in\\ loop with arrays demo\", \"Active high pivots\", true, max\\_lines\\_count = 500)\n\n//@variable The number of bars required on the left and right to confirm a pivot point.\nint pivotBarsInput = input.int(5, \"Pivot leg length\", 1)\n//@variable The number of recent pivot lines to analyze. Controls the size of the \\pivotLines\\ array.\nint maxRecentLines = input.int(20, \"Maximum recent lines\", 1, 500)\n\n//@variable An array that acts as a queue holding the most recent pivot high lines.\nvar array<line> pivotLines = array.new<line>(maxRecentLines)\n//@variable The pivot high price, or \\na\\ if no pivot is found.\nfloat highPivotPrice = ta.pivothigh(pivotBarsInput, pivotBarsInput)\n\nif not na(highPivotPrice)\n//@variable The \\chart.point\\ for the start of the line. Does not contain \\time\\ information.\nfirstPoint = chart.point.from\\_index(bar\\_index - pivotBarsInput, highPivotPrice)\n//@variable The \\chart.point\\ for the end of each line. Does not contain \\time\\ information.\nsecondPoint = chart.point.from\\_index(bar\\_index, highPivotPrice)\n//@variable A horizontal line at the new pivot level.\nline hiPivotLine = line.new(firstPoint, secondPoint, width = 2, color = color.green)\n// Insert the \\hiPivotLine\\ at the beginning of the \\pivotLines\\ array.\npivotLines.unshift(hiPivotLine)\n// Remove the oldest line from the array and delete its ID.\nline.delete(pivotLines.pop())\n\n//@variable The sum of active pivot prices.\nfloat activePivotSum = 0.0\n//@variable The number of active pivot high levels.\nint numActivePivots = 0\n\n// Loop through the \\pivotLines\\ array, directly accessing each \\pivotLine\\ element.\nfor pivotLine in pivotLines\n//@variable The \\x2\\ coordinate of the \\pivotline\\.\nint lineEnd = pivotLine.get\\_x2()\n// Move to the next \\pivotline\\ in the array if the current line is inactive.\nif pivotLine.get\\_x2() < bar\\_index - 1\ncontinue\n//@variable The price value of the \\pivotLine\\.\nfloat pivotPrice = pivotLine.get\\_price(bar\\_index)\n// Change the style of the \\pivotLine\\ and stop extending its display if the \\high\\ is above the \\pivotPrice\\.\nif high > pivotPrice\npivotLine.set\\_color(color.maroon)\npivotLine.set\\_style(line.style\\_dotted)\npivotLine.set\\_width(1)\ncontinue\n// Extend the \\pivotLine\\ and add the \\pivotPrice\\ to the \\activePivotSum\\ when the loop allows a full iteration.\npivotLine.set\\_x2(bar\\_index)\nactivePivotSum += pivotPrice\nnumActivePivots += 1\n\n//@variable The average active pivot high value.\nfloat avgActivePivot = activePivotSum / numActivePivots\n\n// Plot crosses at the \\highPivotPrice\\, offset backward by the \\pivotBarsInput\\.\nplot(highPivotPrice, \"High pivot marker\", color.green, 3, plot.style\\_cross, offset = -pivotBarsInput)\n// Plot the \\avgActivePivot\\ as a line with breaks.\nplot(avgActivePivot, \"Avg. active pivot\", color.orange, 3, plot.style\\_linebr)\n\nNote that:\n\n- The loop in this example executes on _every bar_ because it has to compare active pivot line prices with the current high value, then use the remaining active prices to calculate the bar’s avgActivePivot value.\n- Pine Script features several ways to calculate averages, many of which _do not_ require a loop. However, a loop is necessary in this example because the script uses information only available on the current bar to determine which prices contribute toward the average.\n- The _first_ form of the for…in loop is the most convenient option in this example because we need direct access to the lines referenced within the pivotLines array, but we do not need the corresponding _index_ values.\n\nLooping through matrices\n\nPine scripts can iterate over the contents of a matrix in several different ways. Unlike arrays, matrices use _two_ indices to reference their elements because they store data in a _rectangular_ format. The first index refers to _rows_, and the second refers to _columns_. If a programmer opts to use for or while loops to iterate through matrices instead of using for…in, they must carefully define the loop boundaries or conditions to avoid out-of-bounds errors.\n\nThis code block shows a for loop that performs _row-wise_ iteration, looping through each _row index_ in a matrix and using the value in a matrix.row() call to retrieve a row array. If the matrix is empty, the loop statement uses a final loop counter value of na to _prevent_ iteration. Otherwise, the final counter is the last row index, which is _one less_ than the value returned by matrix.rows():\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\nrowArray = myMatrix.row(rowIndex)\n\nNote that:\n\n- If we replace the matrix.rows() and matrix.row() calls with matrix.columns() and matrix.col(), the loop performs _column-wise_ iteration instead.\n\nThe for…in loop statement is the more convenient approach to loop over and access the rows of a matrix in order, as it automatically validates the number of rows and retrieves an array of the current row’s elements on each iteration:\n\nfor rowArray in myMatrix\n\nWhen a script’s calculations require access to each row from a matrix and its corresponding _index_, programmers can use the second form of the for…in loop:\n\nfor \\[rowIndex, rowArray\\] in myMatrix\n\nNote that:\n\n- The for…in loop only performs row-wise iteration on matrices. To _emulate_ column-wise iteration, programmers can use a for…in loop on a transposed copy.\n\nThe following example creates a custom string representing the rows of a matrix with extra information. When the script executes on the last historical bar, it creates a 3x3 matrix populated with values from math.random() calls. Using the first form of the for…in loop, the script iterates through each row in the matrix to create a “string” value representing the row’s contents, its average, and whether the average is above 0.5. Before the end of each iteration, the script concatenates the constructed string with the labelText value. After the loop ends, the script creates a label to display the labelText variable’s final value:\n\n//@version=6\nindicator(\"\\for row in matrix\\ demo\", \"Custom matrix label\")\n\n//@variable Generates a random value between 0 and 1, rounded to 4 decimal places.\nrand() =>\nmath.round(math.random(), 4)\n\nif barstate.islastconfirmedhistory\n//@variable A matrix of randomized values to format and display in a \\label\\.\nmatrix<float> randomMatrix = matrix.new<float>()\n// Add a row of 9 randomized values and reshape the matrix to 3x3.\nrandomMatrix.add\\_row(\n0, array.from(rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand())\n)\nrandomMatrix.reshape(3, 3)\n\n//@variable A custom \"string\" representation of \\randomMatrix\\ information. Modified within a loop.\nstring labelText = \"Matrix rows: \\\\n\"\n\n// Loop through the rows in the \\randomMatrix\\.\nfor row in randomMatrix\n//@variable The average element value within the \\row\\.\nfloat rowAvg = row.avg()\n//@variable An upward arrow when the \\rowAvg\\ is above 0.5, a downward arrow otherwise.\nstring directionChar = rowAvg > 0.5 ? \"⬆\" : \"⬇\"\n// Add a \"string\" representing the \\row\\ array, its average, and the \\directionChar\\ to the \\labelText\\.\nlabelText += str.format(\"Row: {0} Avg: {1} {2}\\\\n\", row, rowAvg, directionChar)\n\n// Draw a \\label\\ displaying the \\labelText\\ on the current bar.\nlabel.new(\nbar\\_index, 0, labelText, color = color.purple, textcolor = color.white, size = size.huge,\nstyle = label.style\\_label\\_center, textalign = text.align\\_left\n)\n\nWorking with matrices often entails iteratively accessing their _elements_, not just their rows and columns, typically using _nested loops_. For example, this code block uses an outer for loop to iterate over row indices. The inner for loop iterates over column indices on _each_ outer loop iteration and calls matrix.get() to access an element:\n\nfor rowIndex = 0 to (myMatrix.rows() == 0 ? na : myMatrix.rows() - 1)\nfor columnIndex = 0 to myMatrix.columns() - 1\nelement = myMatrix.get(rowIndex, columnIndex)\n\nAlternatively, a more convenient approach for this type of task is to use nested for…in loops. The outer for…in loop in this code block retrieves each row array in a matrix, and the inner for…in statement loops through that array:\n\nfor rowArray in myMatrix\nfor element in rowArray\n\nThe script below creates a 3x2 matrix, then accesses and modifies its elements within nested for…in loops. Both loops use the second form of the for…in statement to retrieve index values and corresponding items. The outer loop accesses a row index and row array from the matrix. The inner loop accesses each index and respective element from that array.\n\nWithin the nested loop’s iterations, the script converts each element to a “string” and initializes a table cell at the rowIndex row and colIndex column. Then, it uses the loop header variables within matrix.set() to update the matrix element. After the outer loop terminates, the script displays a “string” representation of the _updated_ matrix within a label:\n\n//@version=6\nindicator(\"Nested \\for...in\\ loops on matrices demo\")\n\nif barstate.islastconfirmedhistory\n//@variable A matrix containing numbers to display.\nmatrix<float> displayNumbers = matrix.new<float>()\n// Populate the \\displayNumbers\\ matrix and reshape to 3x2.\ndisplayNumbers.add\\_row(0, array.from(1, 2, 3, 4, 5, 6))\ndisplayNumbers.reshape(3, 2)\n\n//@variable A table that displays the elements of the \\displayNumbers\\ before modification.\ntable displayTable = table.new(\nposition = position.middle\\_center, columns = displayNumbers.columns(), rows = displayNumbers.rows(),\nbgcolor = color.purple, border\\_color = color.white, border\\_width = 2\n)\n\n// Loop through the \\displayNumbers\\, retrieving the \\rowIndex\\ and the current \\row\\.\nfor \\[rowIndex, row\\] in displayNumbers\n// Loop through the current \\row\\ on each outer loop iteration to retrieve the \\colIndex\\ and \\element\\.\nfor \\[colIndex, element\\] in row\n// Initialize a table cell at the \\rowIndex\\ row and \\colIndex\\ column displaying the current \\element\\.\ndisplayTable.cell(column = colIndex, row = rowIndex, text = str.tostring(element),\ntext\\_color = color.white, text\\_size = size.huge\n)\n// Update the \\displayNumbers\\ value at the \\rowIndex\\ and \\colIndex\\.\ndisplayNumbers.set(rowIndex, colIndex, math.round(math.exp(element), 3))\n\n// Draw a \\label\\ to display a \"string\" representation of the updated \\displayNumbers\\ matrix.\nlabel.new(\nx = bar\\_index, y = 0, text = \"Matrix now modified: \\\\n\" + str.tostring(displayNumbers), color = color.orange,\ntextcolor = color.white, size = size.huge, style = label.style\\_label\\_up\n)\n\nLooping through maps\n\nThe for…in loop statement is the primary, most convenient approach for iterating over the data within Pine Script maps.\n\nUnlike arrays and matrices, maps are _unordered collections_ that store data in _key-value pairs_. Rather than traversing an internal lookup index, a script references the _keys_ from the pairs within a map to access its _values_. Therefore, when looping through a map, scripts must perform _pair-wise_ iteration, which entails retrieving key-value pairs across iterations rather than indexed elements or rows.\n\nNote that:\n\n- Although maps are unordered collections, Pine Script internally tracks the _insertion order_ of their key-value pairs.\n\nOne way to access the data from a map is to use the map.keys() function, which returns an array containing all the _keys_ from the map, sorted in their insertion order. A script can use the for…in structure to loop through the array of keys and call map.get() to retrieve corresponding values:\n\nfor key in myMap.keys()\nvalue = myMap.get(key)\n\nHowever, the more convenient, _recommended_ approach is to loop through a map directly _without_ creating new arrays. To loop through a map directly, use the second form of the for…in loop statement. Using this loop with a map creates a tuple containing a _key_ and respective _value_ on each iteration. As when looping through a map.keys() array, this _direct_ for…in loop iterates through a map’s contents in their insertion order:\n\nfor \\[key, value\\] in myMap\n\nNote that:\n\n- The second form of the for…in loop is the only way to iterate _directly_ through a map. A script cannot directly loop through this collection type without retrieving a key and value on each iteration.\n\nLet’s consider a simple example demonstrating how a for…in loop works on a map. When the script below executes on the last historical bar, it declares a simpleMap variable to reference a map of “string” keys and “float” values. The script uses map.put() to insert the keys from the newKeys array into the collection with corresponding values from math.random() calls. Then, it uses a for…in loop to iterate through the key-value pairs from the map and construct the displayText string. After the loop ends, the script uses a label to visualize the string:\n\n//@version=6\nindicator(\"Looping through map demo\")\n\nif barstate.islastconfirmedhistory\n//@variable A map of \"string\" keys and \"float\" values to render within a \\label\\.\nmap<string, float> simpleMap = map.new<string, float>()\n\n//@variable An array of \"string\" values representing the keys to put into the map.\narray<string> newKeys = array.from(\"A\", \"B\", \"C\", \"D\", \"E\")\n// Put key-value pairs into the \\simpleMap\\.\nfor key in newKeys\nsimpleMap.put(key, math.random(1, 20))\n\n//@variable A \"string\" representation of the \\simpleMap\\ contents. Modified within a loop.\nstring displayText = \"simpleMap content: \\\\n \"\n\n// Loop through each key-value pair within the \\simpleMap\\.\nfor \\[key, value\\] in simpleMap\n// Add a \"string\" representation of the pair to the \\displayText\\.\ndisplayText += key + \": \" + str.tostring(value, \".\") + \"\\\\n \"\n\n// Draw a \\label\\ showing the \\displayText\\ on the current bar.\nlabel.new(\nx = bar\\_index, y = 0, text = displayText, color = color.green, textcolor = color.white,\nsize = size.huge, textalign = text.align\\_left, style = label.style\\_label\\_center\n)\n\nNote that:\n\n- This script uses both forms of the for…in loop statement. The first loop iterates through the “string” elements of the newKeys array to put key-value pairs into the map referenced by simpleMap`, and the second iterates directly through the map’s key-value pairs to construct the custom string.\n\nPrevious\\\\\nConditional structures Next\\\\\nBuilt-ins",
    "examples": [
      "[variables = | :=] loop_header\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for counter = from_num to to_num [by step_num]\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] while condition\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for item in collection_id\n\n    statements | continue | break\n\n    return_expression",
      "[variables = | :=] for [index, item] in collection_id\n\n    statements | continue | break\n\n    return_expression"
    ],
    "type": "language_concept"
  },
  "functions": {
    "content": "404 Not Found\n\n- Code: NoSuchKey\n- Message: The specified key does not exist.\n- Key: pine-script-docs/language/functions\n- RequestId: XVWZ4QEWGFFD0PX6\n- HostId: rU3F5xc06uDm5MW27CAdZP8F9gggN5S1x1Fe76hasf7+cG7BVFq1p42FHbyiQMmS4aMO/8qA5BA=\n\n  *",
    "examples": [],
    "type": "language_concept"
  },
  "methods": {
    "content": "ADVANCED\n\nMethods\n\nIntroduction\n\nPine Script methods are specialized functions associated with values of specific built-in types,\nuser-defined types, or enum types.\nThey behave the same as regular functions in most regards while offering a shorter, more convenient syntax.\nUsers can access methods using _dot notation_ syntax on variables of the associated type, similar to accessing the fields\nof a Pine Script object.\n\nBuilt-in methods\n\nPine Script includes built-in methods for all _special types_,\nincluding\narray,\nmatrix,\nmap,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\nand\ntable.\nThese methods provide users with a more concise way to call specialized\nroutines for these types within their scripts.\n\nWhen using these special types, the expressions:\n\n``\n\n<namespace>.<functionName>([paramName =] <objectName>, …)\n`\n\nand:\n\n`\n\n<objectName>.<functionName>(…)\n`\n\nare equivalent. For example, rather than using:\n\nPine Script®\nCopied\n\narray.get(id, index)\n\nto get the value from an array id at the specified index, we can\nsimply use:\n\nPine Script®\nCopied\n\nid.get(index)\n\nto achieve the same effect. This notation eliminates the need for users\nto reference the function’s namespace, as\nget()\nis a method of id in this context.\n\nWritten below is a practical example to demonstrate the usage of\nbuilt-in methods in place of functions.\n\nThe following script computes Bollinger Bands over a specified number of\nprices sampled once every n bars. It calls\narray.push()\nand\narray.shift()\nto queue sourceInput values through the sourceArray, then\narray.avg()\nand\narray.stdev()\nto compute the sampleMean and sampleDev. The script then uses these\nvalues to calculate the highBand and lowBand, which it plots on the\nchart along with the sampleMean:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float        sampleMean  = na\nvar float        sampleDev   = na\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    array.push(sourceArray, sourceInput)\n    array.shift(sourceArray)\n    // Update the mean and standard deviaiton values.\n    sampleMean := array.avg(sourceArray)\n    sampleDev  := array.stdev(sourceArray) * multiplier\n// Calculate bands.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nLet’s rewrite this code to utilize methods rather than built-in\nfunctions. In this version, we have replaced all built-in\narray.*() function calls in the script with equivalent method calls:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float        sampleMean  = na\nvar float        sampleDev   = na\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.push(sourceInput)\n    sourceArray.shift()\n    // Update the mean and standard deviaiton values.\n    sampleMean := sourceArray.avg()\n    sampleDev  := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nNote that:\n\n- We call the array methods using sourceArray.* rather than\nreferencing the\narray\nnamespace.\n- We do not include sourceArray as a parameter when we call the\nmethods since they already reference the object.\n\nUser-defined methods\n\nPine Script allows users to define custom methods for use with objects\nof any built-in or user-defined type. Defining a method is essentially\nthe same as defining a function, but with two key differences:\n\n- The\nmethod\nkeyword must be included before the function name.\n- The type of the first parameter in the signature must be explicitly\ndeclared, as it represents the type of object that the method will\nbe associated with.\n\n`\n\n[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>\n`\n\nLet’s apply user-defined methods to our previous Bollinger Bands\nexample to encapsulate operations from the global scope, which will\nsimplify the code and promote reusability. See this portion from the\nexample:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.push(sourceInput)\n    sourceArray.shift()\n    // Update the mean and standard deviaiton values.\n    sampleMean := sourceArray.avg()\n    sampleDev  := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\n\nWe will start by defining a simple method to queue values through an\narray in a single call.\n\nThis maintainQueue() method invokes the\npush()\nand\nshift()\nmethods on a srcArray when takeSample is true and returns the\nobject:\n\nPine Script®\nCopied\n\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n\nNote that:\n\n- Just as with user-defined functions, we use the @function compiler annotation to document method descriptions.\n\nNow we can replace sourceArray.push() and sourceArray.shift() with\nsourceArray.maintainQueue() in our example:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.maintainQueue(sourceInput)\n    // Update the mean and standard deviaiton values.\n    sampleMean  := sourceArray.avg()\n    sampleDev   := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand  = sampleMean + sampleDev\nfloat lowBand   = sampleMean - sampleDev\n\nFrom here, we will further simplify our code by defining a method that\nhandles all Bollinger Band calculations within its scope.\n\nThis calcBB() method invokes the\navg()\nand\nstdev()\nmethods on a srcArray to update mean and dev values when\ncalculate is true. The method uses these values to return a tuple\ncontaining the basis, upper band, and lower band values respectively:\n\nPine Script®\nCopied\n\n// @function         Computes Bollinger Band values from an array of data.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate   (bool) The method will only calculate new values when this is true.\n// @returns          A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        // Compute the mean and standard deviation of the array.\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]\n\nWith this method, we can now remove Bollinger Band calculations from the\nglobal scope and improve code readability:\n\nPine Script®\nCopied\n\n// Identify if n bars have passed.\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\n\nNote that:\n\n- Rather than using an if block in the global scope, we have\ndefined a newSample variable that is only true once every n\nbars. The maintainQueue() and calcBB() methods use this\nvalue for their respective takeSample and calculate\nparameters.\n- Since the maintainQueue() method returns the object that it\nreferences, we’re able to call calcBB() from the same line of\ncode, as both methods apply to array<float> instances.\n\nHere is how the full script example looks now that we’ve applied our\nuser-defined methods:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n// @function         Computes Bollinger Band values from an array of data.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate   (bool) The method will only calculate new values when this is true.\n// @returns          A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        // Compute the mean and standard deviation of the array.\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]\n// Identify if n bars have passed.\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\n\nMethod overloading\n\nUser-defined methods can override and overload existing built-in and\nuser-defined methods with the same identifier. This capability allows\nusers to define multiple routines associated with different parameter\nsignatures under the same method name.\n\nAs a simple example, suppose we want to define a method to identify a\nvariable’s type. Since we must explicitly specify the type of object\nassociated with a user-defined method, we will need to define overloads\nfor each type that we want it to recognize.\n\nBelow, we have defined a getType() method that returns a string\nrepresentation of a variable’s type with overloads for the five\nprimitive types:\n\nPine Script®\nCopied\n\n// @function   Identifies an object's type.\n// @param this Object to inspect.\n// @returns    (string) A string representation of the type.\nmethod getType(int this) =>\n    na(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\n    na(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\n    // \"bool\" values only have two states, true and false, but never na.\n    \"bool\"\nmethod getType(color this) =>\n    na(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\n    na(this) ? \"string(na)\" : \"string\"\n\nNow we can use these overloads to inspect some variables. This script\nuses\nstr.format()\nto format the results from calling the getType() method on five\ndifferent variables into a single results string, then displays the\nstring in the lbl label using the built-in\nset\\_text()\nmethod:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Type Inspection\")\n// @function   Identifies an object's type.\n// @param this Object to inspect.\n// @returns    (string) A string representation of the type.\nmethod getType(int this) =>\n    na(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\n    na(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\n    na(this) ? \"bool(na)\" : \"bool\"\nmethod getType(color this) =>\n    na(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\n    na(this) ? \"string(na)\" : \"string\"\na = 1\nb = 1.0\nc = true\nd = color.white\ne = \"1\"\n// Inspect variables and format results.\nresults = str.format(\n\"a: {0}\\nb: {1}\\nc: {2}\\nd: {3}\\ne: {4}\",\na.getType(), b.getType(), c.getType(), d.getType(), e.getType()\n)\nvar label lbl = label.new(0, 0)\nlbl.set_x(bar_index)\nlbl.set_text(results)\n\nNote that:\n\n- The underlying type of each variable determines which overload\nof getType() the compiler will use.\n- The method will append “(na)” to the output string when a\nvariable is na to demarcate that it is empty.\n\nAdvanced example\n\nLet’s apply what we’ve learned to construct a script that estimates\nthe cumulative distribution of elements in an array, meaning the\nfraction of elements in the array that are less than or equal to any\ngiven value.\n\nThere are many ways in which we could choose to tackle this objective.\nFor this example, we will start by defining a method to replace elements\nof an array, which will help us count the occurrences of elements within\na range of values.\n\nWritten below is an overload of the built-in\nfill()\nmethod for array<float> instances. This overload replaces elements in\na srcArray within the range between the lowerBound and upperBound\nwith an innerValue, and replaces all elements outside the range with\nan outerValue:\n\nPine Script®\nCopied\n\n// @function          Replaces elements in a srcArray between lowerBound and upperBound with an innerValue,\n//                    and replaces elements outside the range with an outerValue.\n// @param srcArray    (array<float>) Array to modify.\n// @param innerValue  (float) Value to replace elements within the range with.\n// @param outerValue  (float) Value to replace elements outside the range with.\n// @param lowerBound  (float) Lowest value to replace with innerValue.\n// @param upperBound  (float) Highest value to replace with innerValue.\n// @returns           (array<float>) srcArray object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\n    for [i, element] in srcArray\n        if (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\n            srcArray.set(i, innerValue)\n        else\n            srcArray.set(i, outerValue)\n    srcArray\n\nWith this method, we can filter an array by value ranges to produce an\narray of occurrences. For example, the expression:\n\nPine Script®\nCopied\n\nsrcArray.copy().fill(1.0, 0.0, min, val)\n\ncopies the srcArray object, replaces all elements between min and\nval with 1.0, then replaces all elements above val with 0.0. From\nhere, it’s easy to estimate the output of the cumulative distribution\nfunction at the val, as it’s simply the average of the resulting\narray:\n\nPine Script®\nCopied\n\nsrcArray.copy().fill(1.0, 0.0, min, val).avg()\n\nNote that:\n\n- The compiler will only use this fill() overload instead of the\nbuilt-in when the user provides innerValue, outerValue,\nlowerBound, and upperBound arguments in the call.\n- If either lowerBound or upperBound is na, its value is\nignored while filtering the fill range.\n- We are able to call copy(), fill(), and avg() successively\non the same line of code because the first two methods return an\narray<float> instance.\n\nWe can now use this to define a method that will calculate our empirical\ndistribution values. The following eCDF() method estimates a number of\nevenly spaced ascending steps from the cumulative distribution\nfunction of a srcArray and pushes the results into a cdfArray:\n\nPine Script®\nCopied\n\n// @function       Estimates the empirical CDF of a srcArray.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps    (int) Number of steps in the estimation.\n// @returns        (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\n    float min = srcArray.min()\n    float rng = srcArray.range() / steps\n    array<float> cdfArray = array.new<float>()\n    // Add averages of srcArray filtered by value region to the cdfArray.\n    float val = min\n    for i = 1 to steps\n        val += rng\n        cdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\n    cdfArray\n\nLastly, to ensure that our eCDF() method functions properly for arrays\ncontaining small and large values, we will define a method to normalize\nour arrays.\n\nThis featureScale() method uses array\nmin()\nand\nrange()\nmethods to produce a rescaled copy of a srcArray. We will use this to\nnormalize our arrays prior to invoking the eCDF() method:\n\nPine Script®\nCopied\n\n// @function        Rescales the elements within a srcArray to the interval [0, 1].\n// @param srcArray  (array<float>) Array to normalize.\n// @returns         (array<float>) Normalized copy of the srcArray.\nmethod featureScale(array<float> srcArray) =>\n    float min = srcArray.min()\n    float rng = srcArray.range()\n    array<float> scaledArray = array.new<float>()\n    // Push normalized element values into the scaledArray.\n    for element in srcArray\n        scaledArray.push((element - min) / rng)\n    scaledArray\n\nNote that:\n\n- This method does not include special handling for divide by zero\nconditions. If rng is 0, the value of the array element will\nbe na.\n\nThe full example below queues a sourceArray of size length with\nsourceInput values using our previous maintainQueue() method,\nnormalizes the array’s elements using the featureScale() method, then\ncalls the eCDF() method to get an array of estimates for n evenly\nspaced steps on the distribution. The script then calls a user-defined\nmakeLabel() function to display the estimates and prices in a label on\nthe right side of the chart:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Empirical Distribution\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint length        = input.int(20, \"Length\")\nint n             = input.int(20, \"Steps\")\n// @function         Maintains a queue of the size of srcArray.\n//                   It appends a value to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new value is only pushed into the queue if this is true.\n// @returns          (array<float>) srcArray object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n// @function          Replaces elements in a srcArray between lowerBound and upperBound with an innerValue,\n//                    and replaces elements outside the range with an outerValue.\n// @param srcArray    (array<float>) Array to modify.\n// @param innerValue  (float) Value to replace elements within the range with.\n// @param outerValue  (float) Value to replace elements outside the range with.\n// @param lowerBound  (float) Lowest value to replace with innerValue.\n// @param upperBound  (float) Highest value to replace with innerValue.\n// @returns           (array<float>) srcArray object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\n    for [i, element] in srcArray\n        if (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\n            srcArray.set(i, innerValue)\n        else\n            srcArray.set(i, outerValue)\n    srcArray\n// @function       Estimates the empirical CDF of a srcArray.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps    (int) Number of steps in the estimation.\n// @returns        (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\n    float min = srcArray.min()\n    float rng = srcArray.range() / steps\n    array<float> cdfArray = array.new<float>()\n    // Add averages of srcArray filtered by value region to the cdfArray.\n    float val = min\n    for i = 1 to steps\n        val += rng\n        cdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\n    cdfArray\n// @function        Rescales the elements within a srcArray to the interval [0, 1].\n// @param srcArray  (array<float>) Array to normalize.\n// @returns         (array<float>) Normalized copy of the srcArray.\nmethod featureScale(array<float> srcArray) =>\n    float min = srcArray.min()\n    float rng = srcArray.range()\n    array<float> scaledArray = array.new<float>()\n    // Push normalized element values into the scaledArray.\n    for element in srcArray\n        scaledArray.push((element - min) / rng)\n    scaledArray\n// @function        Draws a label containing eCDF estimates in the format \"{price}: {percent}%\"\n// @param srcArray  (array<float>) Array of source values.\n// @param cdfArray  (array<float>) Array of CDF estimates.\n// @returns         (void)\nmakeLabel(array<float> srcArray, array<float> cdfArray) =>\n    float max      = srcArray.max()\n    float rng      = srcArray.range() / cdfArray.size()\n    string results = \"\"\n    var label lbl  = label.new(0, 0, \"\", style = label.style_label_left, text_font_family = font.family_monospace)\n    // Add percentage strings to results starting from the max.\n    cdfArray.reverse()\n    for [i, element] in cdfArray\n        results += str.format(\"{0}: {1}%\\n\", max - i  rng, element  100)\n    // Update lbl attributes.\n    lbl.set_xy(bar_index + 1, srcArray.avg())\n    lbl.set_text(results)\nvar array<float> sourceArray = array.new<float>(length)\n// Add background color for the last length bars.\nbgcolor(bar_index > last_bar_index - length ? color.new(color.orange, 80) : na)\n// Queue sourceArray, feature scale, then estimate the distribution over n steps.\narray<float> distArray = sourceArray.maintainQueue(sourceInput).featureScale().eCDF(n)\n// Draw label.\nmakeLabel(sourceArray, distArray)\n`\n\nPrevious\\\\\nEnums Next\\\\\nArrays",
    "examples": [
      "<namespace>.<functionName>([paramName =] <objectName>, …)",
      "<objectName>.<functionName>(…)",
      "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n\n    <functionBlock>"
    ],
    "type": "language_concept"
  },
  "objects": {
    "content": "ADVANCED\n\nObjects\n\nIntroduction\n\nPine Script objects are instances of _user-defined types_ (UDTs). They\nare the equivalent of variables containing parts called _fields_, each\nable to hold independent values that can be of various types.\n\nExperienced programmers can think of UDTs as methodless classes. They\nallow users to create custom types that organize different values under\none logical entity.\n\nCreating objects\n\nBefore an object can be created, its type must be defined. The\nUser-defined types section of the\nType system page\nexplains how to do so.\n\nLet’s define a pivotPoint type to hold pivot information:\n\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar\\_time\n\nNote that:\n\n- We use the\ntype\nkeyword to declare the creation of a UDT.\n- We name our new UDT pivotPoint.\n- After the first line, we create a local block containing the type\nand name of each field.\n- The x field will hold the x-coordinate of the pivot. It is\ndeclared as an “int” because it will hold either a timestamp or a\nbar index of “int” type.\n- y is a “float” because it will hold the pivot’s price.\n- xloc is a field that will specify the units of x:\nxloc.bar\\_index\nor\nxloc.bar\\_time.\nWe set its default value to\nxloc.bar\\_time\nby using the = operator. When an object is created from that UDT,\nits xloc field will thus be set to that value.\n\nNow that our pivotPoint UDT is defined, we can proceed to create\nobjects from it. We create objects using the UDT’s new() built-in\nmethod. To create a new foundPoint object from our pivotPoint UDT,\nwe use:\n\nfoundPoint = pivotPoint.new()\n\nWe can also specify field values for the created object using the\nfollowing:\n\nfoundPoint = pivotPoint.new(time, high)\n\nOr the equivalent:\n\nfoundPoint = pivotPoint.new(x = time, y = high)\n\nAt this point, the foundPoint object’s x field will contain the\nvalue of the\ntime\nbuilt-in when it is created, y will contain the value of\nhigh\nand the xloc field will contain its default value of\nxloc.bar\\_time\nbecause no value was defined for it when creating the object.\n\nObject placeholders can also be created by declaring\nna\nobject names using the following:\n\npivotPoint foundPoint = na\n\nThis example displays a label where high pivots are detected. The pivots\nare detected legsInput bars after they occur, so we must plot the\nlabel in the past for it to appear on the pivot:\n\n//@version=6\nindicator(\"Pivot labels\", overlay = true)\nint legsInput = input(10)\n\n// Define the \\pivotPoint\\ UDT.\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar\\_time\n\n// Detect high pivots.\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\nif not na(pivotHighPrice)\n// A new high pivot was found; display a label where it occurred \\legsInput\\ bars back.\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\nlabel.new(\nfoundPoint.x,\nfoundPoint.y,\nstr.tostring(foundPoint.y, format.mintick),\nfoundPoint.xloc,\ntextcolor = color.white)\n\nTake note of this line from the above example:\n\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nThis could also be written using the following:\n\npivotPoint foundPoint = na\nfoundPoint := pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nWhen using the\nvar\nkeyword while declaring a variable assigned to an object of a\nuser-defined type, the keyword automatically applies to all the object’s\nfields:\n\n//@version=6\nindicator(\"Objects using \\var\\ demo\")\n\n//@type A custom type to hold index, price, and volume information.\ntype BarInfo\nint index = bar\\_index\nfloat price = close\nfloat vol = volume\n\n//@variable A \\BarInfo\\ instance whose fields persist through all iterations, starting from the first bar.\nvar BarInfo firstBar = BarInfo.new()\n//@variable A \\BarInfo\\ instance declared on every bar.\nBarInfo currentBar = BarInfo.new()\n\n// Plot the \\index\\ fields of both instances to compare the difference.\nplot(firstBar.index)\nplot(currentBar.index)\n\nIt’s important to note that assigning an object to a variable that uses\nthe\nvarip\nkeyword does _not_ automatically allow the object’s fields to persist\nwithout rolling back on each _intrabar_ update. One must apply the\nkeyword to each desired field in the type declaration to achieve this\nbehavior. For example:\n\n//@version=6\nindicator(\"Objects using \\varip\\ fields demo\")\n\n//@type A custom type that counts the bars and ticks in the script's execution.\ntype Counter\nint bars = 0\nvarip int ticks = 0\n\n//@variable A \\Counter\\ object whose reference persists throughout all bars.\nvar Counter counter = Counter.new()\n\n// Add 1 to the \\bars\\ and \\ticks\\ fields. The \\ticks\\ field is not subject to rollback on unconfirmed bars.\ncounter.bars += 1\ncounter.ticks += 1\n\n// Plot both fields for comparison.\nplot(counter.bars, \"Bar counter\", color.blue, 3)\nplot(counter.ticks, \"Tick counter\", color.purple, 3)\n\nNote that:\n\n- We used the\nvar\nkeyword to specify that the Counter object assigned to the\ncounter variable persists throughout the script’s execution.\n- The bars field rolls back on realtime bars, whereas the\nticks field does not since we included\nvarip\nin its declaration.\n\nChanging field values\n\nThe value of an object’s fields can be changed using the\n:=\nreassignment operator.\n\nThis line of our previous example:\n\nfoundPoint = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n\nCould be written using the following:\n\nfoundPoint = pivotPoint.new()\nfoundPoint.x := time\\[legsInput\\]\nfoundPoint.y := pivotHighPrice\n\nCollecting objects\n\nPine Script collections ( arrays, matrices, and maps) can contain\nobjects, allowing users to add virtual dimensions to their data\nstructures. To declare a collection of objects, pass a UDT name into its\ntype template.\n\nThis example declares an empty\narray\nthat will hold objects of a pivotPoint user-defined type:\n\npivotHighArray = array.new<pivotPoint>()\n\nTo explicitly declare the type of a variable as an\narray,\nmatrix,\nor map\nof a\nuser-defined type, use the collection’s type keyword followed by its\ntype template. For example:\n\nvar array<pivotPoint> pivotHighArray = na\npivotHighArray := array.new<pivotPoint>()\n\nLet’s use what we have learned to create a script that detects high\npivot points. The script first collects historical pivot information in\nan\narray.\nIt then loops through the array on the last historical bar, creating a\nlabel for each pivot and connecting the pivots with lines:\n\n//@version=6\nindicator(\"Pivot Points High\", overlay = true)\n\nint legsInput = input(10)\n\n// Define the \\pivotPoint\\ UDT containing the time and price of pivots.\ntype pivotPoint\nint openTime\nfloat level\n\n// Create an empty \\pivotPoint\\ array.\nvar pivotHighArray = array.new<pivotPoint>()\n\n// Detect new pivots (\\na\\ is returned when no pivot is found).\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\n\n// Add a new \\pivotPoint\\ object to the end of the array for each detected pivot.\nif not na(pivotHighPrice)\n// A new pivot is found; create a new object of \\pivotPoint\\ type, setting its \\openTime\\ and \\level\\ fields.\nnewPivot = pivotPoint.new(time\\[legsInput\\], pivotHighPrice)\n// Add the new pivot object to the array.\narray.push(pivotHighArray, newPivot)\n\n// On the last historical bar, draw pivot labels and connecting lines.\nif barstate.islastconfirmedhistory\nvar pivotPoint previousPoint = na\nfor eachPivot in pivotHighArray\n// Display a label at the pivot point.\nlabel.new(eachPivot.openTime, eachPivot.level, str.tostring(eachPivot.level, format.mintick), xloc.bar\\_time, textcolor = color.white)\n// Create a line between pivots.\nif not na(previousPoint)\n// Only create a line starting at the loop's second iteration because lines connect two pivots.\nline.new(previousPoint.openTime, previousPoint.level, eachPivot.openTime, eachPivot.level, xloc = xloc.bar\\_time)\n// Save the pivot for use in the next iteration.\npreviousPoint := eachPivot\n\nCopying objects\n\nIn Pine, objects are assigned by reference. When an existing object is\nassigned to a new variable, both point to the same object.\n\nIn the example below, we create a pivot1 object and set its x field\nto 1000. Then, we declare a pivot2 variable containing the reference\nto the pivot1 object, so both point to the same instance. Changing\npivot2.x will thus also change pivot1.x, as both refer to the x\nfield of the same object:\n\n//@version=6\nindicator(\"\")\ntype pivotPoint\nint x\nfloat y\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivot1\npivot2.x := 2000\n// Both plot the value 2000.\nplot(pivot1.x)\nplot(pivot2.x)\n\nTo create a copy of an object that is independent of the original, we\ncan use the built-in copy() method in this case.\n\nIn this example, we declare the pivot2 variable referring to a copied\ninstance of the pivot1 object. Now, changing pivot2.x will not\nchange pivot1.x, as it refers to the x field of a separate object:\n\n//@version=6\nindicator(\"\")\ntype pivotPoint\nint x\nfloat y\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivotPoint.copy(pivot1)\npivot2.x := 2000\n// Plots 1000 and 2000.\nplot(pivot1.x)\nplot(pivot2.x)\n\nIt’s important to note that the built-in copy() method produces a\n_shallow copy_ of an object. If an object has fields with _special_\n_types_\n( array,\nmatrix,\nmap,\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point),\nthose fields in a shallow copy of the object will point to the same\ninstances as the original.\n\nIn the following example, we have defined an InfoLabel type with a\nlabel as one of its fields. The script instantiates a shallow copy of\nthe parent object, then calls a user-defined set() method to update the\ninfo and lbl fields of each object. Since the lbl field of both\nobjects points to the same label instance, changes to this field in\neither object affect the other:\n\n//@version=6\nindicator(\"Shallow Copy\")\n\ntype InfoLabel\nstring info\nlabel lbl\n\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set\\_x(x)\nif not na(y)\nthis.lbl.set\\_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set\\_text(this.info)\n\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar shallow = parent.copy()\n\nparent.set(bar\\_index, 0, \"Parent\")\nshallow.set(bar\\_index, 1, \"Shallow Copy\")\n\nTo produce a _deep copy_ of an object with all of its special type\nfields pointing to independent instances, we must explicitly copy those\nfields as well.\n\nIn this example, we have defined a deepCopy() method that instantiates\na new InfoLabel object with its lbl field pointing to a copy of the\noriginal’s field. Changes to the deep copy’s lbl field will not\naffect the parent object, as it points to a separate instance:\n\n//@version=6\nindicator(\"Deep Copy\")\n\ntype InfoLabel\nstring info\nlabel lbl\n\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set\\_x(x)\nif not na(y)\nthis.lbl.set\\_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set\\_text(this.info)\n\nmethod deepCopy(InfoLabel this) =>\nInfoLabel.new(this.info, this.lbl.copy())\n\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar deep = parent.deepCopy()\n\nparent.set(bar\\_index, 0, \"Parent\")\ndeep.set(bar\\_index, 1, \"Deep Copy\")\n\nShadowing\n\nTo avoid potential conflicts in the eventuality where namespaces added\nto Pine Script in the future would collide with UDTs or object names in\nexisting scripts; as a rule, UDTs and object names shadow the\nlanguage’s namespaces. For example, a UDT or object can use the name of\nbuilt-in types, such as\nline\nor\ntable.\n\nOnly the language’s five primitive types cannot be used to name UDTs or\nobjects:\nint,\nfloat,\nstring,\nbool,\nand\ncolor.\n\nPrevious\\\\\nUser-defined functions Next\\\\\nEnums",
    "examples": [],
    "type": "language_concept"
  },
  "arrays": {
    "content": "ADVANCED\n\nArrays\n\nIntroduction\n\nPine Script Arrays are one-dimensional collections that can hold\nmultiple value references. Think of them as a better way to handle cases\nwhere one would otherwise need to explicitly declare a set of similar\nvariables (e.g., price00, price01, price02, …).\n\nAll elements in an array must be of the same built-in type, user-defined type, or enum type.\n\nScripts reference arrays using array IDs similar to the IDs of lines, labels, and other _special types_. Pine Script does not use an indexing operator to reference individual array elements.\nInstead, functions including array.get() and array.set() read and write the values of array elements.\n\nScripts reference the elements of an array using an _index_, which\nstarts at 0 and extends to the number of elements in the array minus\none. Arrays in Pine Script can have a dynamic size that varies across\nbars, as one can change the number of elements in an array on each\niteration of a script. Scripts can contain multiple array instances. The\nsize of arrays is limited to 100,000 elements.\n\nDeclaring arrays\n\nPine Script uses the following syntax to declare arrays:\n\n``\n\n[var/varip ][array<type>/<type[]> ]<identifier> = <expression>\n`\n\nWhere <type> is a\ntype template for the array that declares the type of values it will\ncontain, and the <expression> returns either an array of the specified\ntype or na.\n\nWhen declaring a variable as an array, we can use the\narray\nkeyword followed by a\ntype template. Alternatively, we can use the type name followed by the\n[] modifier (not to be confused with the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) _history-referencing operator_).\n\nSince Pine always uses type-specific functions to create arrays, the\narray<type>/type[] part of the declaration is redundant, except when\ndeclaring an array variable assigned to na. Even when not required,\nexplicitly declaring the array type helps clearly state the intention to\nreaders.\n\nThis line of code declares an array variable named prices that points\nto na. In this case, we must specify the type to declare that the\nvariable can reference arrays containing “float” values:\n\nPine Script®\nCopied\n\narray<float> prices = na\n\nWe can also write the above example in this form:\n\nPine Script®\nCopied\n\nfloat[] prices = na\n\nWhen declaring an array and the <expression> is not na, use one of\nthe following functions: array.new<type>(),\narray.from(),\nor\narray.copy().\nFor array.new<type>() calls, the arguments of\nthe function’s size and initial_value parameters can be “series” to allow\ndynamic sizing and initialization of array elements. The following\nexample creates an array containing zero “float” elements, and this\ntime, the array reference returned by the array.new\\<float\\>()\nfunction call is assigned to the prices variable:\n\nPine Script®\nCopied\n\nprices = array.new<float>(0)\n\nThe initial_value parameter of the array.new*() functions allows users to\nset all elements in the array to a specified value. If no argument is\nprovided for initial_value, the array is filled with na values.\n\nThis line declares an array ID named prices pointing to an array\ncontaining two elements, each assigned to the bar’s close value:\n\nPine Script®\nCopied\n\nprices = array.new<float>(2, close)\n\nTo create an array and initialize its elements with different values,\nuse\narray.from().\nThis function infers the array’s size and the type of elements it will\nhold from the arguments in the function call. As with array.new*\nfunctions, it accepts “series” arguments. All values supplied to the\nfunction must be of the same type.\n\nFor example, all three of these lines of code will create identical\n“bool” arrays with the same two elements:\n\nPine Script®\nCopied\n\nstatesArray = array.from(close > open, high != close)\nbool[] statesArray = array.from(close > open, high != close)\narray<bool> statesArray = array.from(close > open, high != close)\n\nUsing ​ var ​ and ​ varip ​ keywords\n\nUsers can utilize\nvar and\nvarip\nkeywords to instruct a script to declare an array variable only once on\nthe first execution of the script on the first chart bar. Array\nvariables declared using these keywords point to the same array\ninstances until explicitly reassigned, allowing an array and its element\nreferences to persist across bars.\n\nWhen declaring an array variable using these keywords and pushing a new\nvalue to the end of the referenced array on each bar, the array will\ngrow by one on each bar and be of size bar_index + 1\n( bar\\_index\nstarts at zero) by the time the script executes on the last bar, as this\ncode demonstrates:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Using var\")\n//@variable An array that expands its size by 1 on each bar.\nvar a = array.new<float>(0)\narray.push(a, close)\nif barstate.islast\n    //@variable A string containing the size of a and the current bar_index value.\n    string labelText = \"Array size: \" + str.tostring(a.size()) + \"\\nbar_index: \" + str.tostring(bar_index)\n    // Display the labelText.\n    label.new(bar_index, 0, labelText, size = size.large)\n\nThe same code without the\nvar\nkeyword would re-declare the array on each bar. In this case, after\nexecution of the\narray.push()\ncall, the\narray.size() _method_\ncall ( a.size()) would return a value of 1.\n\nReading and writing array elements\n\nScripts can write values to existing individual array elements using\narray.set(),\nand read using array.get().\nWhen using these functions, it is imperative that the index in the\nfunction call is always less than or equal to the array’s size (because\narray indices start at zero). To get the size of an array, use the\narray.size()\nfunction.\n\nThe following example uses the\nset()\nmethod to populate a fillColors array with instances of one base color\nusing different transparency levels. It then uses\narray.get()\nto retrieve one of the colors from the array based on the location of\nthe bar with the highest price within the last lookbackInput bars:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Distance from high\", \"\", true)\nlookbackInput = input.int(100)\nFILL_COLOR = color.green\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(5)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    fillColors.set(0, color.new(FILL_COLOR, 70))\n    fillColors.set(1, color.new(FILL_COLOR, 75))\n    fillColors.set(2, color.new(FILL_COLOR, 80))\n    fillColors.set(3, color.new(FILL_COLOR, 85))\n    fillColors.set(4, color.new(FILL_COLOR, 90))\n// Find the offset to highest high. Change its sign because the function returns a negative value.\nlastHiBar = - ta.highestbars(high, lookbackInput)\n// Convert the offset to an array index, capping it to 4 to avoid a runtime error.\n// The index used by array.get() will be the equivalent of floor(fillNo).\nfillNo = math.min(lastHiBar / (lookbackInput / 5), 4)\n// Set background to a progressively lighter fill with increasing distance from location of highest high.\nbgcolor(array.get(fillColors, fillNo))\n// Plot key values to the Data Window for debugging.\nplotchar(lastHiBar, \"lastHiBar\", \"\", location.top, size = size.tiny)\nplotchar(fillNo, \"fillNo\", \"\", location.top, size = size.tiny)\n\nAnother technique for initializing the elements in an array is to create\nan _empty array_ (an array with no elements), then use\narray.push()\nto append new elements to the end of the array, increasing the size\nof the array by one on each call. The following code is functionally\nidentical to the initialization section from the preceding script:\n\nPine Script®\nCopied\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    array.push(fillColors, color.new(FILL_COLOR, 70))\n    array.push(fillColors, color.new(FILL_COLOR, 75))\n    array.push(fillColors, color.new(FILL_COLOR, 80))\n    array.push(fillColors, color.new(FILL_COLOR, 85))\n    array.push(fillColors, color.new(FILL_COLOR, 90))\n\nThis code is equivalent to the one above, but it uses\narray.unshift()\nto insert new elements at the _beginning_ of the fillColors array:\n\nPine Script®\nCopied\n\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    array.unshift(fillColors, color.new(FILL_COLOR, 90))\n    array.unshift(fillColors, color.new(FILL_COLOR, 85))\n    array.unshift(fillColors, color.new(FILL_COLOR, 80))\n    array.unshift(fillColors, color.new(FILL_COLOR, 75))\n    array.unshift(fillColors, color.new(FILL_COLOR, 70))\n\nWe can also use\narray.from()\nto create the same fillColors array with a single function call:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Using var\")\nFILL_COLOR = color.green\nvar array<color> fillColors = array.from(\n     color.new(FILL_COLOR, 70),\n     color.new(FILL_COLOR, 75),\n     color.new(FILL_COLOR, 80),\n     color.new(FILL_COLOR, 85),\n     color.new(FILL_COLOR, 90)\n)\n// Cycle background through the array's colors.\nbgcolor(array.get(fillColors, bar_index % (fillColors.size())))\n\nThe array.fill()\nfunction points all array elements, or the elements within the index_from to index_to range, to a specified value. Without the\nlast two optional parameters, the function fills the whole array, so:\n\nPine Script®\nCopied\n\na = array.new<float>(10, close)\n\nand:\n\nPine Script®\nCopied\n\na = array.new<float>(10)\na.fill(close)\n\nare equivalent, but:\n\nPine Script®\nCopied\n\na = array.new<float>(10)\na.fill(close, 1, 3)\n\nonly fills the second and third elements (at index 1 and 2) of the array\nwith close. Note how the\narray.fill() function’s\nlast parameter, index_to, must have a value one greater than the last index the\nfunction will fill. The remaining elements will hold na values, as the\narray.new<type>()\nfunction call does not contain an initial_value argument.\n\nLooping through array elements\n\nWhen looping through an array’s element indices and the array’s size\nis unknown, one can use the\narray.size()\nfunction to get the maximum index value. For example:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected for loop\", overlay = true)\n//@variable An array of close prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in a.\nstring labelText = \"\"\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\n    labelText += str.tostring(array.get(a, i)) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\n\nNote that:\n\n- We use the\nrequest.security\\_lower\\_tf()\nfunction which returns an array of\nclose\nprices at the 1 minute timeframe.\n- This code example will throw an error if you use it on a chart\ntimeframe smaller than 1 minute.\n- for\nloops do not execute if the to expression is\nna.\nNote that the to value is only evaluated once upon entry.\n\nAn alternative method to loop through an array is to use a\nfor…in\nloop. This approach is a variation of the standard for loop that can\niterate over the value references and indices in an array. Here is an\nexample of how we can write the code example from above using a\nfor...in loop:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"for...in loop\", overlay = true)\n//@variable An array of close prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in a.\nstring labelText = \"\"\nfor price in a\n    labelText += str.tostring(price) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\n\nNote that:\n\n- for…in\nloops can return a tuple containing each index and corresponding\nelement. For example, for [i, price] in a returns the i\nindex and price value for each element in a.\n\nA\nwhile\nloop statement can also be used:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"while loop\", overlay = true)\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\nstring labelText = \"\"\nint i = 0\nwhile i < array.size(a)\n    labelText += str.tostring(array.get(a, i)) + \"\\n\"\n    i += 1\nlabel.new(bar_index, high, text = labelText)\n\nScope\n\nUsers can declare arrays within the global scope of a script, as well as\nthe local scopes of\nfunctions,\nmethods, and\nconditional structures. Unlike some of the other built-in types, namely\n_fundamental_ types, scripts can modify globally-assigned arrays from\nwithin local scopes, allowing users to implement global variables that\nany function in the script can directly interact with. We use the\nfunctionality here to calculate progressively lower or higher price\nlevels:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Bands\", \"\", true)\n//@variable The distance ratio between plotted price levels.\nfactorInput = 1 + (input.float(-2., \"Step %\") / 100)\n//@variable A single-value array holding the lowest ohlc4 value within a 50 bar window from 10 bars back.\nlevel = array.new<float>(1, ta.lowest(ohlc4, 50)[10])\nnextLevel(val) =>\n    newLevel = level.get(0) * val\n    // Write new level to the global level array so we can use it as the base in the next function call.\n    level.set(0, newLevel)\n    newLevel\nplot(nextLevel(1))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\n\nHistory referencing\n\nThe history-referencing operator [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D) can\naccess the history of array variables, allowing scripts to interact with\npast array instances previously assigned to a variable.\n\nTo illustrate this, let’s create a simple example to show how one can\nfetch the previous bar’s close value in two equivalent ways. This\nscript uses the [\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator to get the array instance assigned to a on the previous bar,\nthen uses an\narray.get()\nmethod call to retrieve the value of the first element ( previousClose1).\nFor previousClose2, we use the history-referencing operator on the\nclose variable directly to retrieve the value. As we see from the\nplots, previousClose1 and previousClose2 both return the same value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"History referencing\")\n//@variable A single-value array declared on each bar.\na = array.new<float>(1)\n// Set the value of the only element in a to close.\narray.set(a, 0, close)\n//@variable The array instance assigned to a on the previous bar.\nprevious = a[1]\npreviousClose1 = na(previous) ? na : previous.get(0)\npreviousClose2 = close[1]\nplot(previousClose1, \"previousClose1\", color.gray, 6)\nplot(previousClose2, \"previousClose2\", color.white, 2)\n\nInserting and removing array elements\n\nInserting\n\nThe following three functions can insert new elements into an array.\n\narray.unshift()\ninserts a new element at the beginning of an array (index 0) and\nincreases the index values of any existing elements by one.\n\narray.insert()\ninserts a new element at the specified index and increases the index\nof existing elements at or after the index by one.\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.insert()\")\na = array.new<float>(5, 0)\nfor i = 0 to 4\n    array.set(a, i, i + 1)\nif barstate.islast\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a), size = size.large)\n    array.insert(a, 2, 999)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a), style = label.style_label_up, size = size.large)\n\narray.push()\nadds a new element at the end of an array.\n\nRemoving\n\nThese four functions remove elements from an array. The first three also\nreturn the value of the removed element.\n\narray.remove()\nremoves the element at the specified index and returns that element’s\nvalue.\n\narray.shift()\nremoves the first element from an array and returns its value.\n\narray.pop()\nremoves the last element of an array and returns its value.\n\narray.clear()\nremoves all elements from an array. Note that clearing an array won’t\ndelete any objects its elements referenced. See the example below that\nillustrates how this works:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.clear() example\", overlay = true)\n// Create a label array and add a label to the array on each new bar.\nvar a = array.new<label>()\nlabel lbl = label.new(bar_index, high, \"Text\", color = color.red)\narray.push(a, lbl)\nvar table t = table.new(position.top_right, 1, 1)\n// Clear the array on the last bar. This doesn't remove the labels from the chart.\nif barstate.islast\n    array.clear(a)\n    table.cell(t, 0, 0, \"Array elements count: \" + str.tostring(array.size(a)), bgcolor = color.yellow)\n\nUsing an array as a stack\n\nStacks are LIFO (last in, first out) constructions. They behave somewhat\nlike a vertical pile of books to which books can only be added or\nremoved one at a time, always from the top. Pine Script arrays can be\nused as a stack, in which case we use the\narray.push()\nand\narray.pop()\nfunctions to add and remove elements at the end of the array.\n\narray.push(prices, close) will add a new element to the end of the\nprices array, increasing the array’s size by one.\n\narray.pop(prices) will remove the end element from the prices array,\nreturn its value and decrease the array’s size by one.\n\nSee how the functions are used here to track successive lows in rallies:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Lows from new highs\", \"\", true)\nvar lows = array.new<float>(0)\nflushLows = false\n//@function Removes the last element from the id stack when cond is true.\narray_pop(id, cond) => cond and array.size(id) > 0 ? array.pop(id) : float(na)\nif ta.rising(high, 1)\n    // Rising highs; push a new low on the stack.\n    lows.push(low)\n    // Force the return type of this if block to be the same as that of the next block.\n    bool(na)\nelse if lows.size() >= 4 or low < array.min(lows)\n    // We have at least 4 lows or price has breached the lowest low;\n    // sort lows and set flag indicating we will plot and flush the levels.\n    array.sort(lows, order.ascending)\n    flushLows := true\n// If needed, plot and flush lows.\nlowLevel = array_pop(lows, flushLows)\nplot(lowLevel, \"Low 1\", low > lowLevel ? color.silver : color.purple, 2, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 2\", low > lowLevel ? color.silver : color.purple, 3, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 3\", low > lowLevel ? color.silver : color.purple, 4, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 4\", low > lowLevel ? color.silver : color.purple, 5, plot.style_linebr)\nif flushLows\n    // Clear remaining levels after the last 4 have been plotted.\n    lows.clear()\n\nUsing an array as a queue\n\nQueues are FIFO (first in, first out) constructions. They behave\nsomewhat like cars arriving at a red light. New cars are queued at the\nend of the line, and the first car to leave will be the first one that\narrived to the red light.\n\nIn the following code example, we let users decide through the script’s\ninputs how many labels they want to have on their chart. We use that\nquantity to determine the size of the array of labels we then create,\ninitializing the array’s elements to na.\n\nWhen a new pivot is detected, we create a label for it, saving the\nlabel’s ID in the pLabel variable. We then queue the ID of that label\nby using\narray.push()\nto append the new label’s ID to the end of the array, making our array\nsize one greater than the maximum number of labels to keep on the chart.\n\nLastly, we de-queue the oldest label by removing the array’s first\nelement using\narray.shift()\nand deleting the label referenced by that array element’s value. As we\nhave now de-queued an element from our queue, the array contains\npivotCountInput elements once again. Note that on the dataset’s first\nbars we will be deleting na label IDs until the maximum number of\nlabels has been created, but this does not cause runtime errors. Let’s\nlook at our code:\n\nPine Script®\nCopied\n\n//@version=6\nMAX_LABELS = 100\nindicator(\"Show Last n High Pivots\", \"\", true, max_labels_count = MAX_LABELS)\npivotCountInput = input.int(5, \"How many pivots to show\", minval = 0, maxval = MAX_LABELS)\npivotLegsInput  = input.int(3, \"Pivot legs\", minval = 1, maxval = 5)\n// Create an array containing the user-selected max count of label IDs.\nvar labelIds = array.new<label>(pivotCountInput)\npHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nif not na(pHi)\n    // New pivot found; plot its label pivotLegsInput bars behind the current bar_index.\n    pLabel = label.new(bar_index - pivotLegsInput, pHi, str.tostring(pHi, format.mintick), textcolor = color.white)\n    // Queue the new label's ID by appending it to the end of the array.\n    array.push(labelIds, pLabel)\n    // De-queue the oldest label ID from the queue and delete the corresponding label.\n    label.delete(array.shift(labelIds))\n\nNegative indexing\n\nThe array.get(), array.set(), array.insert(), and array.remove() functions support _negative indexing_, which references elements starting from the end of the array. An index of -1 refers to the last element in the array, an index of -2 refers to the second to last element, and so on.\n\nWhen using a _positive_ index, functions traverse the array _forwards_ from the beginning of the array ( _first to last_ element). The first element’s index is 0, and the last element’s index is array.size() - 1. When using a _negative_ index, functions traverse the array _backwards_ from the end of the array ( _last to first_ element). The last element’s index is -1, and the first element’s index is –array.size():\n\nPine Script®\nCopied\n\narray<string> myArray = array.from(\"first\", \"second\", \"third\", \"fourth\", \"last\")\n// Positive indexing: Indexes forwards from the beginning of the array.\nmyArray.get(0)                        // Returns \"first\" element\nmyArray.get(myArray.size() - 1)       // Returns \"last\" element\nmyArray.get(4)                        // Returns \"last\" element\n// Negative indexing: Indexes backwards from the end of the array.\nmyArray.get(-1)                       // Returns \"last\" element\nmyArray.get(-myArray.size())          // Returns \"first\" element\nmyArray.get(-5)                       // Returns \"first\" element\n\nLike positive indexing, negative indexing is bound by the size of the array. For example, functions operating on an array of 5 elements only accept indices of 0 to 4 (first to last element) or -1 to -5 (last to first element). Any other indices are out of bounds and will raise a runtime error.\n\nWe can use negative indices to retrieve, update, add, and remove array elements. This simple script creates an “int” countingArray and calls the array.get(), array.set(), array.insert(), and array.remove() functions to perform various array operations using negative indices. It displays each array operation and its corresponding result using a table:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Negative indexing demo\", overlay = false)\n//@variable A table that displays various array operations and their results.\nvar table displayTable = table.new(\n     position.middle_center, 2, 15, bgcolor = color.white,\n     frame_color = color.black, frame_width = 1, border_width = 1\n)\n//@function Initializes a displayTable row to output a \"string\" of an arrayOperation and the operationResult.\ndisplayRow(int rowID, string arrayOperation, operationResult) =>\n    //@variable Is white if the rowID is even, light blue otherwise. Used to set alternating table row colors.\n    color rowColor = rowID % 2 == 0 ? color.white : color.rgb(33, 149, 243, 75)\n    // Display the arrayOperation in the row's first cell.\n    displayTable.cell(0, rowID, arrayOperation, text_color = color.black,\n         text_halign = text.align_left, bgcolor = rowColor, text_font_family = font.family_monospace\n     )\n    // Display the operationResult in the row's second cell.\n    displayTable.cell(1, rowID, str.tostring(operationResult), text_color = color.black,\n         text_halign = text.align_right, bgcolor = rowColor\n     )\nif barstate.islastconfirmedhistory\n    //@variable Array of \"int\" numbers. Holds six multiples of 10, counting from 10 to 60.\n    array<int> countingArray = array.from(10, 20, 30, 40, 50, 60)\n    // Initialize the table's header cells.\n    displayTable.cell(0, 0, \"ARRAY OPERATION\")\n    displayTable.cell(1, 0, \"RESULT\")\n    // Display the initial countingArray values.\n    displayTable.cell(0, 1, \"Initial countingArray\",\n         text_color = color.black, text_halign = text.align_center, bgcolor = color.yellow)\n    displayTable.cell(1, 1, str.tostring(countingArray),\n         text_color = color.black, text_halign = text.align_right, bgcolor = color.yellow)\n    // Retrieve array elements using negative indices in array.get().\n    displayRow(2, \"countingArray.get(0)\", countingArray.get(0))\n    displayRow(3, \"countingArray.get(-1)\", countingArray.get(-1))\n    displayRow(4, \"countingArray.get(-countingArray.size())\", countingArray.get(-countingArray.size()))\n    // Update array elements using negative indices in array.set() and array.insert().\n    countingArray.set(-2, 99)\n    displayRow(5, \"countingArray.set(-2, 99)\", countingArray)\n    countingArray.insert(-5, 878)\n    displayRow(6, \"countingArray.insert(-5, 878)\", countingArray)\n    // Remove array elements using negative indices in array.remove().\n    countingArray.remove(-3)\n    displayRow(7, \"countingArray.remove(-3)\", countingArray)\n\nNote that not all array operations can use negative indices. For example, search functions like array.indexof() and array.binary\\_search() return the _positive_ index of an element if it’s found in the array. If the value is not found, the functions return -1. However, this returned value is not a negative index, and using it as one would incorrectly reference the last array element. If a script needs to use a search function’s returned index in subsequent array operations, it must appropriately differentiate between this -1 result and other valid indices.\n\nCalculations on arrays\n\nWhile series variables can be viewed as a horizontal set of values\nstretching back in time, Pine Script’s one-dimensional arrays can be\nviewed as vertical structures residing on each bar. As an array’s set\nof elements is not a\ntime series,\nPine Script’s usual mathematical functions are not allowed on them.\nSpecial-purpose functions must be used to operate on all of an array’s\nvalues. The available functions are:\narray.abs(),\narray.avg(),\narray.covariance(),\narray.min(),\narray.max(),\narray.median(),\narray.mode(),\narray.percentile\\_linear\\_interpolation(),\narray.percentile\\_nearest\\_rank(),\narray.percentrank(),\narray.range(),\narray.standardize(),\narray.stdev(),\narray.sum(),\narray.variance().\n\nNote that contrary to the usual mathematical functions in Pine Script,\nthose used on arrays do not return na when some of the values they\ncalculate on have na values. There are a few exceptions to this rule:\n\n- When all array elements have na value or the array contains no\nelements, na is returned. array.standardize() however, will\nreturn an empty array.\n- array.mode() will return na when no mode is found.\n\nManipulating arrays\n\nConcatenation\n\nTwo arrays can be merged — or concatenated — using\narray.concat().\nWhen arrays are concatenated, the second array is appended to the end of\nthe first, so the first array is modified while the second one remains\nintact. The function returns the array ID of the first array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.concat()\")\na = array.new<float>(0)\nb = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(b, 2)\narray.push(b, 3)\nif barstate.islast\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\n    c = array.concat(a, b)\n    array.push(c, 4)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b) + \"\\nc: \" + str.tostring(c), style = label.style_label_up, size = size.large)\n\nCopying\n\nYou can copy an array using\narray.copy().\nHere we copy the array a to a new array named _b:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.copy()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\nif barstate.islast\n    b = array.copy(a)\n    array.push(b, 2)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\n\nNote that simply using _b = a in the previous example would not have\ncopied the array, but only its ID. From thereon, both variables would\npoint to the same array, so using either one would affect the same\narray.\n\nJoining\n\nThe array.join() function converts an “int”, “float”, or “string” array’s elements into strings, then _joins_ each one to form a single “string” value with a specified separator inserted between each combined value. It provides a convenient alternative to converting values to strings with str.tostring() and performing repeated string concatenation operations.\n\nThe following script demonstrates the array.join() function’s behaviors. It requests tuples of “string”, “int”, and “float” values from three different contexts with request.security() calls, creates separate arrays for each type with array.from(), then creates joined strings with the array.join() function. Lastly, it creates another array from those strings with array.from() and joins them with another array.join() call, using a newline as the separator, and displays the final string in the table:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Joining demo\")\n//@function Returns a tuple containing the ticker ID (\"string\"), bar index (\"int\"), and closing price (\"float\").\ndataRequest() =>\n    [syminfo.tickerid, bar_index, close]\nif barstate.islast\n    //@variable A single-cell table displaying the results of array.join() calls.\n    var table displayTable = table.new(position.middle_center, 1, 1, color.blue)\n    // Request data for three symbols.\n    [ticker1, index1, price1] = request.security(\"SPY\", \"\", dataRequest())\n    [ticker2, index2, price2] = request.security(\"GLD\", \"\", dataRequest())\n    [ticker3, index3, price3] = request.security(\"TLT\", \"\", dataRequest())\n    // Create separate \"string\", \"int\", and \"float\" arrays to hold the requested data.\n    array<string> tickerArray = array.from(ticker1, ticker2, ticker3)\n    array<int> indexArray = array.from(index1, index2, index3)\n    array<float> priceArray = array.from(price1, price2, price3)\n    // Convert each array's data to strings and join them with different separators.\n    string joined1 = array.join(tickerArray, \", \")\n    string joined2 = indexArray.join(\"|\")\n    string joined3 = priceArray.join(\"\\n\")\n    //@variable A joined \"string\" containing the joined1, joined2, and joined3 values.\n    string displayText = array.from(joined1, joined2, joined3).join(\"\\n---\\n\")\n    // Initialize a cell to show the displayText.\n    displayTable.cell(0, 0, displayText, text_color = color.white, text_size = 36)\n\nNote that:\n\n- Each array.join() call inserts the specified separator only between each element string. It does _not_ include the separator at the start or end of the returned value.\n- The array.join() function uses the same numeric format as the default for str.tostring(). See the String conversion and formatting section of the Strings page to learn more.\n- Calls to array.join() cannot directly convert elements of “bool”, “color”, or other types to strings. Scripts must convert data of these types separately.\n\nSorting\n\nScripts can sort arrays containing “int”, “float”, or “string” elements in ascending or descending order using the array.sort() function. The direction in which the function sorts the array’s elements depends on its order parameter, which accepts the order.ascending or order.descending constants. The default argument is order.ascending, meaning the function sorts the elements in ascending order of value.\n\nThe function sorts arrays of “int” and “float” elements based on their _numeric_ values.\n\nThe example below declares two arrays with references assigned to the a and b variables, and it concatenates those arrays to form a combined c array. The script creates Pine Logs showing formatted text representing the unsorted arrays, and the results of using array.sort() to sort all three arrays in ascending and descending order:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Sorting numeric arrays demo\")\nif barstate.isfirst\n    //@variable A formatting string.\n    string formatString = \"\\n{0}:\\n{1}\\n{2}\\n{3}\"\n    // Create two three-element arrays.\n    array<float> a = array.from(2.1, 0.5, 1.2)\n    array<float> b = array.from(0.1, 1.4, 0.6)\n    //@variable A combined array containing the elements from a and b.\n    array<float> c = array.copy(a).concat(b)\n    // Log formatted text showing the unsorted a, b, and c arrays.\n    log.info(formatString, \"Unsorted\", a, b, c)\n    // Sort the a, b, and c arrays in ascending order (default).\n    array.sort(a)\n    array.sort(b)\n    c.sort()\n    // Log formatted text showing the a, b, and c arrays sorted in ascending order.\n    log.info(formatString, \"Ascending\", a, b, c)\n    // Sort the a, b, and c arrays in descending order.\n    a.sort(order.descending)\n    b.sort(order.descending)\n    c.sort(order.descending)\n    // Log formatted text showing the a, b, and c arrays sorted in descending order.\n    log.info(formatString, \"Descending\", a, b, c)\n\nNote that:\n\n- Each array.sort() call directly _modifies_ the order of the elements in the original array. To get sorted elements _without_ reorganizing the original array, use the array.sort\\_indices() function. This function returns a new array of “int” values representing the _indices_ of the elements sorted in ascending or descending order.\n\nThe array.sort() function sorts arrays of “string” values based on the _Unicode values_ of their characters. The sorting algorithm starts with each element’s _first_ character position, then successively uses additional characters if multiple elements have matching characters at the same position.\n\nThis example creates an array of arbitrary strings on the first bar, then sorts the array’s contents in ascending order with an array.sort() call. The script logs formatted representations of the array in the Pine Logs pane before and after calling the array.sort() function:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Sorting string arrays demo\")\nif barstate.isfirst\n    //@variable An array of arbitrary \"string\" values.\n    array<string> stringArray = array.from(\"abC\", \"Abc\", \"ABc\", \"ABC\", \"!\", \"123\", \"12.3\", \" \")\n    // Log the original stringArray.\n    log.info(\"Unsorted: {0}\", stringArray)\n    // Sort the array in ascending order (default) and log the result.\n    stringArray.sort()\n    log.info(\"Ascending: {0}\", stringArray)\n\nNote that:\n\n- Whitespace and control characters have lower Unicode values than other characters, which is why the \" \" element appears first in the sorted array.\n- Some ASCII punctuation marks and symbols have lower Unicode values than digit or letter characters. The \"!\" element comes before the elements with word characters because its Unicode value is U+0021. However, some other ASCII punctuation and symbol characters, such as the Left Curly Bracket { (U+007B), have higher Unicode values than ASCII digits and letters.\n- ASCII digits have lower Unicode values than letter characters. For example, the 1 character’s value is U+0031, and the A character’s value is U+0041.\n- Uppercase ASCII letters come _before_ lowercase characters in the Unicode Standard. For instance, the a character has the Unicode value U+0061, which is larger than the value for A.\n\nReversing\n\nUse\narray.reverse()\nto reverse an array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.reverse()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\nif barstate.islast\n    array.reverse(a)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a))\n\nSlicing\n\nSlicing an array using\narray.slice()\ncreates a shallow copy of a subset of the parent array. You determine\nthe size of the subset to slice using the index_from and index_to\nparameters. The index_to argument must be one greater than the end of\nthe subset you want to slice.\n\nThe shallow copy created by the slice acts like a window on the parent\narray’s content. The indices used for the slice define the window’s\nposition and size over the parent array. If, as in the example below, a\nslice is created from the first three elements of an array (indices 0 to\n2), then regardless of changes made to the parent array, and as long as\nit contains at least three elements, the shallow copy will always\ncontain the parent array’s first three elements.\n\nAdditionally, once the shallow copy is created, operations on the copy\nare mirrored on the parent array. Adding an element to the end of the\nshallow copy, as is done in the following example, will widen the window\nby one element and also insert that element in the parent array at index\n3\\. In this example, to slice the subset from index 0 to index 2 of array\na, we must use sliceOfA = array.slice(a, 0, 3):\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"array.slice()\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 3)\nif barstate.islast\n    // Create a shadow of elements at index 1 and 2 from array a.\n    sliceOfA = array.slice(a, 0, 3)\n    label.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA))\n    // Remove first element of parent array a.\n    array.remove(a, 0)\n    // Add a new element at the end of the shallow copy, thus also affecting the original array a.\n    array.push(sliceOfA, 4)\n    label.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA), style = label.style_label_up)\n\nSearching arrays\n\nWe can test if a value is part of an array with the\narray.includes()\nfunction, which returns true if the element is found. We can find the\nfirst occurrence of a value in an array by using the\narray.indexof()\nfunction. The first occurence is the one with the lowest index. We can\nalso find the last occurrence of a value with\narray.lastindexof():\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Searching in arrays\")\nvalueInput = input.int(1)\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.push(a, 1)\nif barstate.islast\n    valueFound      = array.includes(a, valueInput)\n    firstIndexFound = array.indexof(a, valueInput)\n    lastIndexFound  = array.lastindexof(a, valueInput)\n    label.new(bar_index, 0, \"a: \" + str.tostring(a) +\n      \"\\nFirst \" + str.tostring(valueInput) + (firstIndexFound != -1 ? \" value was found at index: \" + str.tostring(firstIndexFound) : \" value was not found.\") +\n      \"\\nLast \" + str.tostring(valueInput)  + (lastIndexFound  != -1 ? \" value was found at index: \" + str.tostring(lastIndexFound) : \" value was not found.\"))\n\nWe can also perform a binary search on an array but note that performing\na binary search on an array means that the array will first need to be\nsorted in ascending order only. The\narray.binary\\_search()\nfunction will return the value’s index if it was found or -1 if it\nwasn’t. If we want to always return an existing index from the array\neven if our chosen value wasn’t found, then we can use one of the other\nbinary search functions available. The\narray.binary\\_search\\_leftmost()\nfunction, which returns an index if the value was found or the first\nindex to the left where the value would be found. The\narray.binary\\_search\\_rightmost()\nfunction is almost identical and returns an index if the value was found\nor the first index to the right where the value would be found.\n\nError handling\n\nMalformed array.*() call syntax in Pine scripts will cause the usual\ncompiler error messages to appear in Pine Editor’s console, at the\nbottom of the window, when you save a script. Refer to the Pine Script\nv6 Reference\\\\\nManual when in\ndoubt regarding the exact syntax of function calls.\n\nScripts using arrays can also throw runtime errors, which appear as\nan exclamation mark next to the indicator’s name on the chart. We\ndiscuss those runtime errors in this section.\n\nIndex xx is out of bounds. Array size is yy\n\nThis error is the most frequent one programmers encounter when using arrays. The error occurs when the script references a _nonexistent_ array index. The “xx”\nvalue represents the out-of-bounds index the function tried to use, and “yy” represents the array’s size. Recall that array indices start at zero — not one — and end at the array’s size, minus one. For instance, the last valid index in a three-element array is 2.\n\nTo avoid this error, you must make provisions in your code logic to prevent using an index value outside the array’s boundaries. This code example generates the error because the last i value in the loop’s iterations is beyond the valid index range for the a array:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Out of bounds index\")\na = array.new<float>(3)\nfor i = 1 to 3\n    array.set(a, i, i)\nplot(array.pop(a))\n\nTo resolve the error, last i value in the loop statement should be less than or equal to 2:\n\nPine Script®\nCopied\n\nfor i = 0 to 2\n\nTo iterate over all elements in an array of _unknown_ size with a for loop, set the loop counter’s final value to one less than the array.size() value:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected for loop\")\nsizeInput = input.int(0, \"Array size\", minval = 0, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\n    array.set(a, i, i)\nplot(array.pop(a))\n\nWhen sizing arrays dynamically using a field in the script’s\n_Settings/Inputs_ tab, protect the boundaries of that value using\ninput.int()‘s\nminval and maxval parameters:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Protected array size\")\nsizeInput = input.int(10, \"Array size\", minval = 1, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to sizeInput - 1\n    array.set(a, i, i)\nplot(array.size(a))\n\nSee the Looping through array elements\nsection of this page for more information.\n\nCannot call array methods when ID of array is ‘na’\n\nWhen an array ID is initialized to na, operations on it are not\nallowed, since no array exists. All that exists at that point is an\narray variable containing the na value rather than a valid array ID\npointing to an existing array. Note that an array created with no\nelements in it, as you do when you use a = array.new_int(0), has a\nvalid ID nonetheless. This code will throw the error we are discussing:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Array methods on na array\")\narray<int> a = na\narray.push(a, 111)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a))\n\nTo avoid it, create an array with size zero using:\n\nPine Script®\nCopied\n\narray<int> a = array.new_int(0)\n\nor:\n\nPine Script®\nCopied\n\na = array.new_int(0)\n\nArray is too large. Maximum size is 100000\n\nThis error will appear if your code attempts to declare an array with a\nsize greater than 100,000. It will also occur if, while dynamically\nappending elements to an array, a new element would increase the\narray’s size past the maximum.\n\nCannot create an array with a negative size\n\nWe haven’t found any use for arrays of negative size yet, but if you\never do, we may allow them :)\n\nCannot use shift() if array is empty.\n\nThis error will occur if\narray.shift()\nis called to remove the first element of an empty array.\n\nCannot use pop() if array is empty.\n\nThis error will occur if\narray.pop()\nis called to remove the last element of an empty array.\n\nIndex ‘from’ should be less than index ‘to’\n\nWhen two indices are used in functions such as\narray.slice(),\nthe first index must always be smaller than the second one.\n\nSlice is out of bounds of the parent array\n\nThis message occurs whenever the parent array’s size is modified in\nsuch a way that it makes the shallow copy created by a slice point\noutside the boundaries of the parent array. This code will reproduce it\nbecause after creating a slice from index 3 to 4 (the last two elements\nof our five-element parent array), we remove the parent’s first\nelement, making its size four and its last index 3. From that moment on,\nthe shallow copy which is still pointing to the “window” at the parent\narray’s indices 3 to 4, is pointing out of the parent array’s\nboundaries:\n\nPine Script®\nCopied\n\n//@version=6\nindicator(\"Slice out of bounds\")\na = array.new<float>(5, 0)\nb = array.slice(a, 3, 5)\narray.remove(a, 0)\nc = array.indexof(b, 2)\nplot(c)\n`\n\nPrevious\\\\\nMethods Next\\\\\nMatrices",
    "examples": [
      "[var/varip ][array<type>/<type[]> ]<identifier> = <expression>"
    ],
    "type": "language_concept"
  },
  "matrices": {
    "content": "ADVANCED\n\nMatrices\n\nIntroduction\n\nPine Script Matrices are collections that store value references in a\nrectangular format. They are the equivalent of two-dimensional array objects with functions and methods for inspection, modification, and specialized calculations. As with arrays, all matrix elements must be of the same type, user-defined type, or enum type.\n\nMatrices reference their elements using _two_ indices: one index for their\n_rows_ and the other for their _columns_. Each index starts at 0 and extends\nto the number of rows/columns in the matrix minus one. Matrices in Pine\ncan have dynamic numbers of rows and columns that vary across bars. The total number of elements\nwithin a matrix is the _product_ of the number of rows and columns it contains\n(e.g., a 5x5 matrix contains 25 elements). Like\narrays, the total number of\nelements in a matrix cannot exceed 100,000.\n\nDeclaring a matrix\n\nPine Script uses the following syntax for matrix declaration:\n\n``\n\n[var/varip ][matrix<type> ]<identifier> = <expression>\n`\n\nWhere <type> is a\ntype template for the matrix that declares the type of values or references it\ncontains, and the <expression> returns either the reference of a matrix instance or na.\n\nWhen initializing a matrix variable with na, users must specify that the\nidentifier will reference matrices of a specific type by including the\nmatrix\nkeyword followed by a\ntype template.\n\nThis line declares a new myMatrix variable with an initial reference of na. It\nexplicitly declares the variable as matrix<float>, which tells the\ncompiler that the variable can accept only\nmatrix\nobjects containing\nfloat\nvalues:\n\nmatrix<float> myMatrix = na\n\nWhen a matrix variable is not initialized with na, the\nmatrix\nkeyword and its type template are optional, as the compiler will use the\ntype information from the matrix instance that the variable references.\n\nHere, we declare a myMatrix variable referencing a new matrix<float>\ninstance with two rows, two columns, and an initial_value of 0. The\nvariable gets its type information from the new object in this case, so\nit doesn’t require an explicit type declaration:\n\nmyMatrix = matrix.new<float>(2, 2, 0.0)\n\nUsing ​ var ​ and ​ varip ​ keywords\n\nAs with other variables, users can include the\nvar or\nvarip\nkeywords to instruct a script to declare a matrix variable only once\nrather than on every bar. A matrix variable declared with this keyword\nwill point to the same instance throughout the span of the chart unless\nthe script explicitly assigns another matrix to it, allowing a matrix\nand its element references to persist between script iterations.\n\nThis script declares an m variable to reference a matrix that holds a\nsingle row of two\nint\nelements using the\nvar\nkeyword. On every 20th bar, the script adds 1 to the first element on\nthe first row of the m matrix. The\nplot()\ncall displays this element’s value on the chart. As we see from the plot, the\nvalue of the matrix.get() method call\npersists across bars, never returning to the initial value of 0:\n\n//@version=6\nindicator(\"var matrix demo\")\n\n//@variable A 1x2 rectangular matrix declared only at \\bar\\_index == 0\\, i.e., the first bar.\nvar m = matrix.new<int>(1, 2, 0)\n\n//@variable Is \\true\\ on every 20th bar.\nbool update = bar\\_index % 20 == 0\n\nif update\nint currentValue = m.get(0, 0) // Get the current value of the first row and column.\nm.set(0, 0, currentValue + 1) // Set the first row and column element value to \\currentValue + 1\\.\n\nplot(m.get(0, 0), linewidth = 3) // Plot the value from the first row and column.\n\nReading and writing matrix elements\n\n​ matrix.get() ​ and ​ matrix.set() ​\n\nTo retrieve the value from a matrix at a specified row and column\nindex, use\nmatrix.get().\nThis function locates the specified matrix element and returns its\nvalue. Similarly, to overwrite a specific element’s value, use\nmatrix.set()\nto assign the element at the specified row and column to a new\nvalue.\n\nThe example below defines a square matrix m with two rows and columns\nand an initial_value of 0 for all elements on the first bar. The\nscript adds 1 to each element’s value on different bars using matrix.get()\nand\nmatrix.set()\nmethod calls. It updates the first row’s first value once every 11 bars, the\nfirst row’s second value once every seven bars, the second row’s first\nvalue once every five bars, and the second row’s second value once\nevery three bars. The script plots each element’s value on the chart:\n\n//@version=6\nindicator(\"Reading and writing elements demo\")\n\n//@variable A 2x2 square matrix of \\float\\ values.\nvar m = matrix.new<float>(2, 2, 0.0)\n\nswitch\nbar\\_index % 11 == 0 => m.set(0, 0, m.get(0, 0) + 1.0) // Adds 1 to the value at row 0, column 0 every 11th bar.\nbar\\_index % 7 == 0 => m.set(0, 1, m.get(0, 1) + 1.0) // Adds 1 to the value at row 0, column 1 every 7th bar.\nbar\\_index % 5 == 0 => m.set(1, 0, m.get(1, 0) + 1.0) // Adds 1 to the value at row 1, column 0 every 5th bar.\nbar\\_index % 3 == 0 => m.set(1, 1, m.get(1, 1) + 1.0) // Adds 1 to the value at row 1, column 1 every 3rd bar.\n\nplot(m.get(0, 0), \"Row 0, Column 0 Value\", color.red, 2)\nplot(m.get(0, 1), \"Row 0, Column 1 Value\", color.orange, 2)\nplot(m.get(1, 0), \"Row 1, Column 0 Value\", color.green, 2)\nplot(m.get(1, 1), \"Row 1, Column 1 Value\", color.blue, 2)\n\n​ matrix.fill() ​\n\nTo overwrite all matrix elements with a specific value, use\nmatrix.fill().\nThis function points all items in the entire matrix or within the\nfrom_row/column and to_row/column index range to the value\nspecified in the call. For example, this snippet declares a 4x4 square\nmatrix, then fills its elements with the result of a\nmath.random()\ncall:\n\nmyMatrix = matrix.new<float>(4, 4)\nmyMatrix.fill(math.random())\n\nNote when using\nmatrix.fill()\nwith matrices of _reference types_\n( line,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point)\nor UDTs, all replaced elements will point to the same object passed\nin the function call.\n\nThis script declares a matrix with four rows and columns of\nlabel\nreferences, which it fills with a new\nlabel\nreference on the first bar. On each bar, the script sets the x property\nof the label referenced at row 0, column 0 to\nbar\\_index,\nand the text property of the one referenced at row 3, column 3 to the\nnumber of labels on the chart. Although the matrix can reference 16\n(4x4) labels, each element refers to the _same_ label object, resulting in\nonly one label on the chart with coordinates and displayed text that update on each bar:\n\n//@version=6\nindicator(\"Object matrix fill demo\")\n\n//@variable A 4x4 label matrix.\nvar matrix<label> m = matrix.new<label>(4, 4)\n\n// Fill \\m\\ with a new label object on the first bar.\nif bar\\_index == 0\nm.fill(label.new(0, 0, textcolor = color.white, size = size.huge))\n\n//@variable The number of label objects on the chart.\nint numLabels = label.all.size()\n\n// Set the \\x\\ of the label from the first row and column to \\bar\\_index\\.\nm.get(0, 0).set\\_x(bar\\_index)\n// Set the \\text\\ of the label at the last row and column to the number of labels.\nm.get(3, 3).set\\_text(str.format(\"Total labels on the chart: {0}\", numLabels))\n\nRows and columns\n\nRetrieving\n\nScripts can retrieve all the data from a specific row or\ncolumn in a matrix via the\nmatrix.row()\nand\nmatrix.col()\nfunctions. These functions return the row or column contents as an\narray sized according to the other dimension of the matrix. The\nsize of a\nmatrix.row()\narray equals the number of columns ( matrix.columns()), and the size of a matrix.col() array equals the number of rows matrix.rows().\n\nThe script below populates a 3x2 m matrix with the values 1 - 6 on the\nfirst chart bar. It uses\nmatrix.row()\nand\nmatrix.col()\nmethod calls to access the first row and column arrays from the matrix and\ndisplays them on the chart in a label along with the array sizes:\n\n//@version=6\nindicator(\"Retrieving rows and columns demo\")\n\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\n\nif bar\\_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 2, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 2, column 1 value to 6.\n\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, 0, color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set\\_x(bar\\_index)\ndebugLabel.set\\_text(str.format(\"Row 0: {0}, Size: {1}\\\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\n\nNote that:\n\n- To get the sizes of the arrays displayed in the label, we used\nthe\nmatrix.rows()\nand\nmatrix.columns()\nmethods rather than\narray.size()\nto demonstrate that the size of the row0 array equals the\nnumber of matrix columns and the size of the column0 array equals the\nnumber of matrix rows.\n\nThe matrix.row()\nand\nmatrix.col() functions\ncopy the contents of a row/column to a new\narray.\nModifications to the arrays\nreturned by these functions do not directly affect the elements or the\nshape of a matrix.\n\nHere, we’ve modified the previous script to set the first element of\nrow0 to 10 via the\narray.set()\nmethod before displaying the label. This script also plots the value\nfrom row 0, column 0. As we see, the label shows that the first element\nof the row0 array is 10. However, the plot\nshows that the corresponding matrix element still has a value of 1:\n\n//@version=6\nindicator(\"Retrieving rows and columns demo\")\n\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\n\nif bar\\_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 1, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 1, column 1 value to 6.\n\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n\n// Set the first \\row\\ element to 10.\nrow0.set(0, 10)\n\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, m.get(0, 0), color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set\\_x(bar\\_index)\ndebugLabel.set\\_text(str.format(\"Row 0: {0}, Size: {1}\\\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\n\n// Plot the first element of \\m\\.\nplot(m.get(0, 0), linewidth = 3)\n\nAlthough changes to an\narray\nconstructed from\nmatrix.row()\nor\nmatrix.col()\ndo not directly affect a parent matrix, it’s important to note the\nresulting array from a matrix containing\nUDTs\nor special types, including\nline,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point,\nbehaves as a _shallow copy_ of a row/column, i.e., the elements within\nan array returned from these functions reference the same objects as the\ncorresponding matrix elements.\n\nThis script contains a custom myUDT type containing a value field\nwith an initial value of 0. It declares a 1x1 m matrix to hold a\nsingle myUDT instance on the first bar, then calls m.row(0) to copy\nthe first row of the matrix as an\narray.\nOn every chart bar, the script adds 1 to the value field of the first\nrow array element. In this case, the value field of the matrix\nelement increases on every bar as well, because both elements refer to the\nsame object:\n\n//@version=6\nindicator(\"Row with reference types demo\")\n\n//@type A custom type that holds a float value.\ntype myUDT\nfloat value = 0.0\n\n//@variable A 1x1 matrix of \\myUDT\\ type.\nvar matrix<myUDT> m = matrix.new<myUDT>(1, 1, myUDT.new())\n//@variable A shallow copy of the first row of \\m\\.\narray<myUDT> row = m.row(0)\n//@variable The first element of the \\row\\.\nmyUDT firstElement = row.get(0)\n\nfirstElement.value += 1.0 // Add 1 to the \\value\\ field of \\firstElement\\. Also affects the element in the matrix.\n\nplot(m.get(0, 0).value, linewidth = 3) // Plot the \\value\\ of the \\myUDT\\ object from the first row and column of \\m\\.\n\nInserting\n\nScripts can add new rows and columns to a matrix via\nmatrix.add\\_row()\nand\nmatrix.add\\_col().\nThese functions insert the values or references from an\narray\ninto a matrix at the specified row/column index. If the id matrix is\nempty (has no rows or columns), the array referenced by array_id in the call can be of any\nsize. If a row/column exists at the specified index, the matrix\nincreases the index value for the existing row/column and all after it\nby one.\n\nThe script below declares an empty m matrix and inserts rows and\ncolumns by calling\nmatrix.add\\_row()\nand\nmatrix.add\\_col() as\nmethods. It first inserts an array with three elements at row 0, turning\nm into a 1x3 matrix, then another at row 1, changing the shape to 2x3.\nAfter that, the script inserts another array at row 0, which changes the\nshape of m to 3x3 and shifts the index of all rows previously at index\n0 and higher. It inserts another array at the last column index,\nchanging the shape to 3x4. Finally, it adds an array with four values at\nthe end row index.\n\nThe resulting matrix has four rows and columns and contains values 1-16\nin ascending order. The script displays the rows of the matrix after each\nrow/column insertion with a user-defined debugLabel() function to\nvisualize the process:\n\n//@version=6\nindicator(\"Rows and columns demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//Create an empty matrix.\nvar m = matrix.new<float>()\n\nif bar\\_index == last\\_bar\\_index - 1\ndebugLabel(m, bar\\_index - 30, note = \"Empty matrix\")\n\n// Insert an array at row 0. \\m\\ will now have 1 row and 3 columns.\nm.add\\_row(0, array.from(5, 6, 7))\ndebugLabel(m, bar\\_index - 20, note = \"New row at\\\\nindex 0\")\n\n// Insert an array at row 1. \\m\\ will now have 2 rows and 3 columns.\nm.add\\_row(1, array.from(9, 10, 11))\ndebugLabel(m, bar\\_index - 10, note = \"New row at\\\\nindex 1\")\n\n// Insert another array at row 0. \\m\\ will now have 3 rows and 3 columns.\n// The values previously on row 0 will now be on row 1, and the values from row 1 will be on row 2.\nm.add\\_row(0, array.from(1, 2, 3))\ndebugLabel(m, bar\\_index, note = \"New row at\\\\nindex 0\")\n\n// Insert an array at column 3. \\m\\ will now have 3 rows and 4 columns.\nm.add\\_col(3, array.from(4, 8, 12))\ndebugLabel(m, bar\\_index + 10, note = \"New column at\\\\nindex 3\")\n\n// Insert an array at row 3. \\m\\ will now have 4 rows and 4 columns.\nm.add\\_row(3, array.from(13, 14, 15, 16))\ndebugLabel(m, bar\\_index + 20, note = \"New row at\\\\nindex 3\")\n\nRemoving\n\nTo remove a specific row or column from a matrix, use\nmatrix.remove\\_row()\nand\nmatrix.remove\\_col().\nThese functions remove the specified row/column and decrease the index\nvalues of all rows/columns after it by one.\n\nFor this example, we’ve added these lines of code to our “Rows and\ncolumns demo” script from the\nInserting section above:\n\n// Removing example\n\n// Remove the first row and last column from the matrix. \\m\\ will now have 3 rows and 3 columns.\nm.remove\\_row(0)\nm.remove\\_col(3)\ndebugLabel(m, bar\\_index + 30, color.red, note = \"Removed row 0\\\\nand column 3\")\n\nThis code removes the first row and the last column of the m matrix\nusing\nmatrix.remove\\_row()\nand\nmatrix.remove\\_col()\nmethod calls, then displays the rows in a label at bar_index + 30. As we can\nsee, the matrix has a 3x3 shape after the script executes this block, and the index\nvalues for all existing rows are reduced by 1:\n\nSwapping\n\nTo swap the rows and columns of a matrix without altering its\ndimensions, use\nmatrix.swap\\_rows()\nand\nmatrix.swap\\_columns().\nThese functions swap the positions of the elements at the row1/column1\nand row2/column2 indices.\n\nLet’s add another set of code lines to the example from the\nremoving section. The following lines swap the first and last rows of the m matrix and display the\nchanges in a label at bar_index + 40:\n\n// Swapping example\n\n// Swap the first and last row. \\m\\ retains the same dimensions.\nm.swap\\_rows(0, 2)\ndebugLabel(m, bar\\_index + 40, color.purple, note = \"Swapped rows 0\\\\nand 2\")\n\nIn the new label, we see the matrix has the same number of rows as\nbefore, and the first and last rows have traded places:\n\nReplacing\n\nIt may be desirable in some cases to completely _replace_ a row or\ncolumn in a matrix. To do so,\ninsert another array’s elements at the desired row/column and\nremove the old elements previously at that index.\n\nIn the following code, we’ve defined a replaceRow() method that uses\nthe\nmatrix.add\\_row()\nfunction to insert the new values at the row index, and the\nmatrix.remove\\_row()\nmethod to remove the old row that moved to the row + 1 index. This\nscript uses the replaceRow() method to fill the rows of a 3x3 matrix\nwith the numbers 1-9. It draws a label on the chart before and after\nreplacing the rows using the custom debugLabel() method:\n\n//@version=6\nindicator(\"Replacing rows demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@function Replaces the \\row\\ of \\this\\ matrix with a new array of \\values\\.\n//@param row The row index to replace.\n//@param values The array of values to insert.\nmethod replaceRow(matrix<float> this, int row, array<float> values) =>\nthis.add\\_row(row, values) // Inserts a copy of the \\values\\ array at the \\row\\.\nthis.remove\\_row(row + 1) // Removes the old elements previously at the \\row\\.\n\n//@variable A 3x3 matrix.\nvar matrix<float> m = matrix.new<float>(3, 3, 0.0)\n\nif bar\\_index == last\\_bar\\_index - 1\nm.debugLabel(note = \"Original\")\n// Replace each row of \\m\\.\nm.replaceRow(0, array.from(1.0, 2.0, 3.0))\nm.replaceRow(1, array.from(4.0, 5.0, 6.0))\nm.replaceRow(2, array.from(7.0, 8.0, 9.0))\nm.debugLabel(bar\\_index + 10, note = \"Replaced rows\")\n\nLooping through a matrix\n\n​ for ​\n\nWhen a script only needs to iterate over the row/column indices in a\nmatrix, the most common method is to use\nfor\nloops. For example, this line creates a loop with a row value that\nstarts at 0 and increases by one until it reaches one less than the\nnumber of rows in the m matrix (i.e., the last row index):\n\nfor row = 0 to m.rows() - 1\n\nTo iterate over all index values in the m matrix, we can create a\n_nested_ loop that iterates over each column index on each row\nvalue:\n\nfor row = 0 to m.rows() - 1\nfor column = 0 to m.columns() - 1\n\nLet’s use this nested structure to create a\nmethod that visualizes\nmatrix elements. In the script below, we’ve defined a toTable()\nmethod that displays the elements of a matrix within a\ntable\nobject. It iterates over each row index and over each column index\non every row. Within the loop, it converts each element to a\nstring\nto display in the corresponding table cell.\n\nOn the first bar, the script creates an empty m matrix, populates it\nwith rows, and calls m.toTable() to display its elements:\n\n//@version=6\nindicator(\"for loop demo\", \"Matrix to table\")\n\n//@function Displays the elements of \\this\\ matrix in a table.\n//@param this The matrix to display.\n//@param position The position of the table on the chart.\n//@param bgColor The background color of the table.\n//@param textColor The color of the text in each cell.\n//@param note A note string to display on the bottom row of the table.\n//@returns A new \\table\\ object with cells corresponding to each element of \\this\\ matrix.\nmethod toTable(\nmatrix<float> this, string position = position.middle\\_center,\ncolor bgColor = color.blue, color textColor = color.white,\nstring note = na\n) =>\n//@variable The number of rows in \\this\\ matrix.\nint rows = this.rows()\n//@variable The number of columns in \\this\\ matrix.\nint columns = this.columns()\n//@variable A table that displays the elements of \\this\\ matrix with an optional \\note\\ cell.\ntable result = table.new(position, columns, rows + 1, bgColor)\n\n// Iterate over each row index of \\this\\ matrix.\nfor row = 0 to rows - 1\n// Iterate over each column index of \\this\\ matrix on each \\row\\.\nfor col = 0 to columns - 1\n//@variable The element from \\this\\ matrix at the \\row\\ and \\col\\ index.\nfloat element = this.get(row, col)\n// Initialize the corresponding \\result\\ cell with the \\element\\ value.\nresult.cell(col, row, str.tostring(element), text\\_color = textColor, text\\_size = size.huge)\n\n// Initialize a merged cell on the bottom row if a \\note\\ is provided.\nif not na(note)\nresult.cell(0, rows, note, text\\_color = textColor, text\\_size = size.huge)\nresult.merge\\_cells(0, rows, columns - 1, rows)\n\nresult // Return the \\result\\ table.\n\n//@variable A 3x4 matrix of values.\nvar m = matrix.new<float>()\n\nif bar\\_index == 0\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(1, 2, 3))\nm.add\\_row(1, array.from(5, 6, 7))\nm.add\\_row(2, array.from(9, 10, 11))\n// Add a column to \\m\\.\nm.add\\_col(3, array.from(4, 8, 12))\n// Display the elements of \\m\\ in a table.\nm.toTable()\n\n​ for...in ​\n\nWhen a script needs to iterate over and retrieve the rows of a matrix,\nusing the\nfor…in\nstructure is often preferred over the standard for loop. This\nstructure directly references the row\narrays in a matrix, making\nit a more convenient option for such use cases. For example, this line\ncreates a loop that returns the reference of an array representing a row in the m\nmatrix on each iteration:\n\nfor row in m\n\nThe following indicator calculates the moving average of OHLC data with\nan input length and displays the values on the chart. The custom\nrowWiseAvg() method loops through the rows of a matrix using a\nfor…in structure to produce an array containing the\narray.avg() value\nfor each row array.\n\nOn the first chart bar, the script creates a new m matrix with four\nrows and length columns, which it queues a new column of OHLC data\ninto by calling\nmatrix.add\\_col()\nand\nmatrix.remove\\_col()\nas methods on each subsequent bar. It uses m.rowWiseAvg() to calculate\nthe array of row-wise averages, then it plots the value of each array element on\nthe chart:\n\n//@version=6\nindicator(\"for...in loop demo\", \"Average OHLC\", overlay = true)\n\n//@variable The number of terms in the average.\nint length = input.int(20, \"Length\", minval = 1)\n\n//@function Calculates the average of each matrix row.\nmethod rowWiseAvg(matrix<float> this) =>\n//@variable An array with elements corresponding to each row's average.\narray<float> result = array.new<float>()\n// Iterate over each \\row\\ of \\this\\ matrix.\nfor row in this\n// Push the average of each \\row\\ into the \\result\\.\nresult.push(row.avg())\nresult // Return the resulting array.\n\n//@variable A 4x\\length\\ matrix of values.\nvar matrix<float> m = matrix.new<float>(4, length)\n\n// Add a new column containing OHLC values to the matrix.\nm.add\\_col(m.columns(), array.from(open, high, low, close))\n// Remove the first column.\nm.remove\\_col(0)\n\n//@variable An array containing averages of \\open\\, \\high\\, \\low\\, and \\close\\ over \\length\\ bars.\narray<float> averages = m.rowWiseAvg()\n\nplot(averages.get(0), \"Average Open\", color.blue, 2)\nplot(averages.get(1), \"Average High\", color.green, 2)\nplot(averages.get(2), \"Average Low\", color.red, 2)\nplot(averages.get(3), \"Average Close\", color.orange, 2)\n\nNote that:\n\n- The for…in loop structure can also access the _index_ value of each row.\nFor example, for [i, row] in m creates a tuple containing the\ni row index and the reference of the corresponding row array from the m\nmatrix on each loop iteration.\n\nCopying a matrix\n\nShallow copies\n\nPine scripts can copy matrices via\nmatrix.copy().\nThis function returns a _shallow copy_ of a matrix that does not affect\nthe shape of the original matrix or its contents.\n\nFor example, this script assigns a new matrix reference to the myMatrix variable\nand adds two columns. It creates a new myCopy matrix from that matrix\nby calling\nmatrix.copy()\nas a method, then adds a new row to the resulting copy. It displays the rows of both matrices in\nlabels via the user-defined debugLabel() function:\n\n//@version=6\nindicator(\"Shallow copy demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x2 \\float\\ matrix.\nmatrix<float> myMatrix = matrix.new<float>()\nmyMatrix.add\\_col(0, array.from(1.0, 3.0))\nmyMatrix.add\\_col(1, array.from(2.0, 4.0))\n\n//@variable A shallow copy of \\myMatrix\\.\nmatrix<float> myCopy = myMatrix.copy()\n// Add a row to the last index of \\myCopy\\.\nmyCopy.add\\_row(myCopy.rows(), array.from(5.0, 6.0))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the rows of both matrices in separate labels.\nmyMatrix.debugLabel(note = \"Original\")\nmyCopy.debugLabel(bar\\_index + 10, color.green, note = \"Shallow Copy\")\n\nIt’s important to note that the elements within shallow copies of a\nmatrix have the same values or references as the original matrix. When matrices\ncontain references to special types\n( line,\nlinefill,\nbox,\npolyline,\nlabel,\ntable,\nor\nchart.point)\nor\nuser-defined types, the elements of a shallow copy reference the same objects\nas the original matrix.\n\nThis script declares a myMatrix variable with a newLabel as the\ninitial value. It then copies myMatrix to a myCopy variable via\nmyMatrix.copy()\nand plots the number of labels. As we see below, there’s only one\nlabel\non the chart, as the element in myCopy references the same object as\nthe element in myMatrix. Consequently, changes to the object referenced in the copied matrix affects the object referenced in the original matrix:\n\n//@version=6\nindicator(\"Shallow copy demo\")\n\n//@variable Initial value of the original matrix elements.\nvar label newLabel = label.new(\nbar\\_index, 1, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n)\n\n//@variable A 1x1 matrix containing a new \\label\\ instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A shallow copy of \\myMatrix\\.\nvar matrix<label> myCopy = myMatrix.copy()\n\n//@variable The first label from the \\myCopy\\ matrix.\nlabel testLabel = myCopy.get(0, 0)\n\n// Change the \\text\\, \\style\\, and \\x\\ values of \\testLabel\\. Also affects the \\newLabel\\.\ntestLabel.set\\_text(\"Copy\")\ntestLabel.set\\_style(label.style\\_label\\_up)\ntestLabel.set\\_x(bar\\_index)\n\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\n\nDeep copies\n\nOne can produce a _deep copy_ of a matrix (i.e., a matrix whose elements refer to copies of the objects referenced by the original matrix) by explicitly copying each element in the matrix.\n\nHere, we’ve added a deepCopy() user-defined method to our previous\nscript. The method creates a new matrix and uses nested\n\\for\\ loops to assign all elements to copies of the originals. When the\nscript calls this method instead of\nmatrix.copy(),\nwe see that there are now two labels on the chart, and any changes to\nthe label referenced by the copied matrix do not affect the one referenced by the original matrix:\n\n//@version=6\nindicator(\"Deep copy demo\")\n\n//@function Returns a deep copy of a label matrix.\nmethod deepCopy(matrix<label> this) =>\n//@variable A deep copy of \\this\\ matrix.\nmatrix<label> that = this.copy()\nfor row = 0 to that.rows() - 1\nfor column = 0 to that.columns() - 1\n// Assign the element at each \\row\\ and \\column\\ of \\that\\ matrix to a copy of the retrieved label.\nthat.set(row, column, that.get(row, column).copy())\nthat\n\n//@variable Initial value of the original matrix.\nvar label newLabel = label.new(\nbar\\_index, 2, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n)\n\n//@variable A 1x1 matrix containing a new \\label\\ instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A deep copy of \\myMatrix\\.\nvar matrix<label> myCopy = myMatrix.deepCopy()\n\n//@variable The first label from the \\myCopy\\ matrix.\nlabel testLabel = myCopy.get(0, 0)\n\n// Change the \\text\\, \\style\\, and \\x\\ values of \\testLabel\\. Does not affect the \\newLabel\\.\ntestLabel.set\\_text(\"Copy\")\ntestLabel.set\\_style(label.style\\_label\\_up)\ntestLabel.set\\_x(bar\\_index)\n\n// Change the \\x\\ value of \\newLabel\\.\nnewLabel.set\\_x(bar\\_index)\n\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\n\nSubmatrices\n\nIn Pine, a _submatrix_ is a\nshallow copy of an existing matrix that only includes the rows and\ncolumns specified by the from_row/column and to_row/column\nparameters. In essence, it is a sliced copy of a matrix.\n\nFor example, the script below creates an mSub matrix from the m\nmatrix via the\nmatrix.submatrix()\nmethod, then calls our user-defined debugLabel() function to display\nthe rows of both matrices in labels:\n\n//@version=6\nindicator(\"Submatrix demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix of values.\nvar m = matrix.new<float>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add columns to \\m\\.\nm.add\\_col(0, array.from(9, 6, 3))\nm.add\\_col(1, array.from(8, 5, 2))\nm.add\\_col(2, array.from(7, 4, 1))\n// Display the rows of \\m\\.\nm.debugLabel(note = \"Original Matrix\")\n\n//@variable A 2x2 submatrix of \\m\\ containing the first two rows and columns.\nmatrix<float> mSub = m.submatrix(from\\_row = 0, to\\_row = 2, from\\_column = 0, to\\_column = 2)\n// Display the rows of \\mSub\\\ndebugLabel(mSub, bar\\_index + 10, bgColor = color.green, note = \"Submatrix\")\n\nScope and history\n\nMatrix variables leave historical trails on each bar, allowing scripts\nto use the history-referencing operator\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\nto interact with past matrix instances previously assigned to a\nvariable. Additionally, scripts can modify matrices assigned to global\nvariables from within the scopes of\nuser-defined functions,\nmethods, and\nconditional structures.\n\nThis script calculates the average ratios of body and wick distances\nrelative to the bar range over length bars. It displays the data along\nwith values from length bars ago in a table. The user-defined\naddData() function adds columns of current and historical ratios to\nthe a matrix created in the global scope, and the calcAvg() function references previous\nmatrices assigned to the globalMatrix variable using the\n[\\[\\]](https://www.tradingview.com/pine-script-reference/v6/op_%5B%5D)\noperator to calculate a matrix of averages:\n\n//@version=6\nindicator(\"Scope and history demo\", \"Bar ratio comparison\")\n\nint length = input.int(10, \"Length\", 1)\n\n//@variable A global matrix.\nmatrix<float> globalMatrix = matrix.new<float>()\n\n//@function Calculates the ratio of body range to candle range.\nbodyRatio() =>\nmath.abs(close - open) / (high - low)\n\n//@function Calculates the ratio of upper wick range to candle range.\nupperWickRatio() =>\n(high - math.max(open, close)) / (high - low)\n\n//@function Calculates the ratio of lower wick range to candle range.\nlowerWickRatio() =>\n(math.min(open, close) - low) / (high - low)\n\n//@function Adds data to the \\globalMatrix\\.\naddData() =>\n// Add a new column of data at \\column\\ 0.\nglobalMatrix.add\\_col(0, array.from(bodyRatio(), upperWickRatio(), lowerWickRatio()))\n//@variable The column of \\globalMatrix\\ from index 0 \\length\\ bars ago.\narray<float> pastValues = globalMatrix.col(0)\\[length\\]\n// Add \\pastValues\\ to the \\globalMatrix\\, or an array of \\na\\ if \\pastValues\\ is \\na\\.\nif na(pastValues)\nglobalMatrix.add\\_col(1, array.new<float>(3))\nelse\nglobalMatrix.add\\_col(1, pastValues)\n\n//@function Returns the \\length\\-bar average of matrices assigned to \\globalMatrix\\ on historical bars.\ncalcAvg() =>\n//@variable The sum historical \\globalMatrix\\ matrices.\nmatrix<float> sums = matrix.new<float>(globalMatrix.rows(), globalMatrix.columns(), 0.0)\nfor i = 0 to length - 1\n//@variable The \\globalMatrix\\ matrix \\i\\ bars before the current bar.\nmatrix<float> previous = globalMatrix\\[i\\]\n// Break the loop if \\previous\\ is \\na\\.\nif na(previous)\nsums.fill(na)\nbreak\n// Assign the sum of \\sums\\ and \\previous\\ to \\sums\\.\nsums := matrix.sum(sums, previous)\n// Divide the \\sums\\ matrix by the \\length\\.\nresult = sums.mult(1.0 / length)\n\n// Add data to the \\globalMatrix\\.\naddData()\n\n//@variable The historical average of the \\globalMatrix\\ matrices.\nglobalAvg = calcAvg()\n\n//@variable A \\table\\ displaying information from the \\globalMatrix\\.\nvar table infoTable = table.new(\nposition.middle\\_center, globalMatrix.columns() + 1, globalMatrix.rows() + 1, bgcolor = color.navy\n)\n\n// Define value cells.\nfor \\[i, row\\] in globalAvg\nfor \\[j, value\\] in row\ncolor textColor = value > 0.333 ? color.orange : color.gray\ninfoTable.cell(j + 1, i + 1, str.tostring(value), text\\_color = textColor, text\\_size = size.huge)\n\n// Define header cells.\ninfoTable.cell(0, 1, \"Body ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(0, 2, \"Upper wick ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(0, 3, \"Lower wick ratio\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(1, 0, \"Current average\", text\\_color = color.white, text\\_size = size.huge)\ninfoTable.cell(2, 0, str.format(\"{0} bars ago\", length), text\\_color = color.white, text\\_size = size.huge)\n\nNote that:\n\n- The addData() and calcAvg() functions have no parameters, as\nthey directly interact with the globalMatrix and length\nvariables declared in the outer scope.\n- The calcAvg() functions calculates the averages by adding previous matrices\nusing\nmatrix.sum()\nand multiplying all elements by 1 / length using\nmatrix.mult().\nWe discuss these and other specialized functions in the\nMatrix calculations section below.\n\nInspecting a matrix\n\nThe ability to inspect the shape of a matrix and patterns within its\nelements is crucial, as it helps reveal important information about a\nmatrix and its compatibility with various calculations and\ntransformations. Pine Script includes several built-ins for matrix\ninspection, including\nmatrix.is\\_square(),\nmatrix.is\\_identity(),\nmatrix.is\\_diagonal(),\nmatrix.is\\_antidiagonal(),\nmatrix.is\\_symmetric(),\nmatrix.is\\_antisymmetric(),\nmatrix.is\\_triangular(),\nmatrix.is\\_stochastic(),\nmatrix.is\\_binary(),\nand\nmatrix.is\\_zero().\n\nTo demonstrate these features, this example contains a custom\ninspect() method that uses conditional blocks with matrix.is_*()\nfunctions to return information about a matrix. It displays a string\nrepresentation of an m matrix and the description returned from\nm.inspect() in labels on the chart:\n\n//@version=6\nindicator(\"Matrix inspection demo\")\n\n//@function Inspects a matrix using \\matrix.is\\_\\*()\\ functions and returns a \\string\\ describing some of its features.\nmethod inspect(matrix<int> this)=>\n//@variable A string describing \\this\\ matrix.\nstring result = \"This matrix:\\\\n\"\nif this.is\\_square()\nresult += \"- Has an equal number of rows and columns.\\\\n\"\nif this.is\\_binary()\nresult += \"- Contains only 1s and 0s.\\\\n\"\nif this.is\\_zero()\nresult += \"- Is filled with 0s.\\\\n\"\nif this.is\\_triangular()\nresult += \"- Contains only 0s above and/or below its main diagonal.\\\\n\"\nif this.is\\_diagonal()\nresult += \"- Only has nonzero values in its main diagonal.\\\\n\"\nif this.is\\_antidiagonal()\nresult += \"- Only has nonzero values in its main antidiagonal.\\\\n\"\nif this.is\\_symmetric()\nresult += \"- Equals its transpose.\\\\n\"\nif this.is\\_antisymmetric()\nresult += \"- Equals the negative of its transpose.\\\\n\"\nif this.is\\_identity()\nresult += \"- Is the identity matrix.\\\\n\"\nresult\n\n//@variable A 4x4 identity matrix.\nmatrix<int> m = matrix.new<int>()\n\n// Add rows to the matrix.\nm.add\\_row(0, array.from(1, 0, 0, 0))\nm.add\\_row(1, array.from(0, 1, 0, 0))\nm.add\\_row(2, array.from(0, 0, 1, 0))\nm.add\\_row(3, array.from(0, 0, 0, 1))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the \\m\\ matrix in a blue label.\nlabel.new(\nbar\\_index, 0, str.tostring(m), color = color.blue, style = label.style\\_label\\_right,\ntextcolor = color.white, size = size.huge\n)\n// Display the result of \\m.inspect()\\ in a purple label.\nlabel.new(\nbar\\_index, 0, m.inspect(), color = color.purple, style = label.style\\_label\\_left,\ntextcolor = color.white, size = size.huge\n)\n\nManipulating a matrix\n\nReshaping\n\nThe shape of a matrix can determine its compatibility with various\nmatrix operations. In some cases, it is necessary to change the\ndimensions of a matrix without affecting the number of elements or the\nvalues they reference, otherwise known as _reshaping_. To reshape a\nmatrix in Pine, use the\nmatrix.reshape()\nfunction.\n\nThis example demonstrates the results of multiple reshaping operations\non a matrix. The initial m matrix has a 1x8 shape (one row and eight\ncolumns). Through successive calls to the\nmatrix.reshape()\nmethod, the script changes the shape of m to 2x4, 4x2, and 8x1. It\ndisplays each reshaped matrix in a label on the chart using the custom\ndebugLabel() method:\n\n//@version=6\nindicator(\"Reshaping example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A matrix containing the values 1-8.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add the initial vector of values.\nm.add\\_row(0, array.from(1, 2, 3, 4, 5, 6, 7, 8))\nm.debugLabel(note = \"Initial 1x8 matrix\")\n\n// Reshape. \\m\\ now has 2 rows and 4 columns.\nm.reshape(2, 4)\nm.debugLabel(bar\\_index + 10, note = \"Reshaped to 2x4\")\n\n// Reshape. \\m\\ now has 4 rows and 2 columns.\nm.reshape(4, 2)\nm.debugLabel(bar\\_index + 20, note = \"Reshaped to 4x2\")\n\n// Reshape. \\m\\ now has 8 rows and 1 column.\nm.reshape(8, 1)\nm.debugLabel(bar\\_index + 30, note = \"Reshaped to 8x1\")\n\nNote that:\n\n- The order of elements in m does not change with each\nm.reshape() call.\n- When reshaping a matrix, the product of the rows and columns\narguments must equal the\nmatrix.elements\\_count()\nvalue, as\nmatrix.reshape()\ncannot change the number of elements in a matrix.\n\nReversing\n\nOne can reverse the order of all elements in a matrix using\nmatrix.reverse().\nThis function moves the references of an m-by-n matrix id at the i-th\nrow and j-th column to the m - 1 - i row and n - 1 - j column.\n\nFor example, this script creates a 3x3 matrix containing the values 1-9\nin ascending order, then uses the\nmatrix.reverse()\nmethod to reverse its contents. It displays the original and modified\nversions of the matrix in labels on the chart via m.debugLabel():\n\n//@version=6\nindicator(\"Reversing demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nmatrix<float> m = matrix.new<float>()\n\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(1, 2, 3))\nm.add\\_row(1, array.from(4, 5, 6))\nm.add\\_row(2, array.from(7, 8, 9))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the contents of \\m\\.\nm.debugLabel(note = \"Original\")\n// Reverse \\m\\, then display its contents.\nm.reverse()\nm.debugLabel(bar\\_index + 10, color.red, note = \"Reversed\")\n\nTransposing\n\nTransposing a matrix is a fundamental operation that flips all rows and\ncolumns in a matrix about its _main diagonal_ (the diagonal vector of\nall values in which the row index equals the column index). This process\nproduces a new matrix with reversed row and column dimensions, known as\nthe _transpose_. Scripts can calculate the transpose of a matrix using\nmatrix.transpose().\n\nFor any m-row, n-column matrix, the matrix returned from\nmatrix.transpose()\nwill have n rows and m columns. All elements in a matrix at the i-th row\nand j-th column correspond to the elements in its transpose at the j-th\nrow and i-th column.\n\nThis example declares a 2x4 m matrix, calculates its transpose by calling\nmatrix.transpose() as a\nmethod, then displays strings representing both matrices on the chart using our custom\ndebugLabel() method. As we can see below, the transposed matrix has a\n4x2 shape, and the rows of the transpose match the columns of the\noriginal matrix:\n\n//@version=6\nindicator(\"Transpose example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x4 matrix.\nmatrix<int> m = matrix.new<int>()\n\n// Add columns to \\m\\.\nm.add\\_col(0, array.from(1, 5))\nm.add\\_col(1, array.from(2, 6))\nm.add\\_col(2, array.from(3, 7))\nm.add\\_col(3, array.from(4, 8))\n\n//@variable The transpose of \\m\\. Has a 4x2 shape.\nmatrix<int> mt = m.transpose()\n\nif bar\\_index == last\\_bar\\_index - 1\nm.debugLabel(note = \"Original\")\nmt.debugLabel(bar\\_index + 10, note = \"Transpose\")\n\nSorting\n\nScripts can sort the contents of a matrix via\nmatrix.sort().\nUnlike\narray.sort(),\nwhich sorts _elements_, this function organizes all _rows_ in a matrix\nin a specified order\n( order.ascending\nby default) based on the values in a specified column.\n\nThis script declares a 3x3 m matrix, sorts the rows of the m1 copy\nin ascending order based on the first column, then sorts the rows of the\nm2 copy in descending order based on the second column. It displays\nthe original matrix and sorted copies in labels using our debugLabel()\nmethod:\n\n//@version=6\nindicator(\"Sorting rows example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(3, 2, 4))\nm.add\\_row(1, array.from(1, 9, 6))\nm.add\\_row(2, array.from(7, 8, 9))\nm.debugLabel(note = \"Original\")\n\n// Copy \\m\\ and sort rows in ascending order based on the first column (default).\nmatrix<int> m1 = m.copy()\nm1.sort()\nm1.debugLabel(bar\\_index + 10, color.green, note = \"Sorted using col 0\\\\n(Ascending)\")\n\n// Copy \\m\\ and sort rows in descending order based on the second column.\nmatrix<int> m2 = m.copy()\nm2.sort(1, order.descending)\nm2.debugLabel(bar\\_index + 20, color.red, note = \"Sorted using col 1\\\\n(Descending)\")\n\nIt’s important to note that\nmatrix.sort()\ndoes not sort the columns of a matrix. However, one _can_ use this\nfunction to sort matrix columns with the help of\nmatrix.transpose().\n\nAs an example, this script contains a sortColumns() method that uses\nthe\nmatrix.sort()\nmethod to sort the\ntranspose\nof a matrix using the column corresponding to the row of the original\nmatrix. The script uses this method to sort the m matrix based on the\ncontents of its first row:\n\n//@version=6\nindicator(\"Sorting columns example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@function Sorts the columns of \\this\\ matrix based on the values in the specified \\row\\.\nmethod sortColumns(matrix<int> this, int row = 0, bool ascending = true) =>\n//@variable The transpose of \\this\\ matrix.\nmatrix<int> thisT = this.transpose()\n//@variable Is \\order.ascending\\ when \\ascending\\ is \\true\\, \\order.descending\\ otherwise.\norder = ascending ? order.ascending : order.descending\n// Sort the rows of \\thisT\\ using the \\row\\ column.\nthisT.sort(row, order)\n//@variable A copy of \\this\\ matrix with sorted columns.\nresult = thisT.transpose()\n\n//@variable A 3x3 matrix.\nmatrix<int> m = matrix.new<int>()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(3, 2, 4))\nm.add\\_row(1, array.from(1, 9, 6))\nm.add\\_row(2, array.from(7, 8, 9))\nm.debugLabel(note = \"Original\")\n\n// Sort the columns of \\m\\ based on the first row and display the result.\nm.sortColumns(0).debugLabel(bar\\_index + 10, note = \"Sorted using row 0\\\\n(Ascending)\")\n\nConcatenating\n\nScripts can _concatenate_ two matrices using\nmatrix.concat().\nThis function appends the rows of an id2 matrix to the end of an id1\nmatrix with the same number of columns.\n\nTo create a matrix with elements representing the _columns_ of a matrix\nappended to another,\ntranspose both matrices, use\nmatrix.concat()\non the transposed matrices, then\ntranspose()\nthe result.\n\nFor example, this script appends the rows of the m2 matrix to the m1\nmatrix and appends their columns using _transposed copies_ of the\nmatrices. It displays the m1 and m2 matrices and the results after\nconcatenating their rows and columns in labels using the custom\ndebugLabel() method:\n\n//@version=6\nindicator(\"Concatenation demo\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x3 matrix filled with 1s.\nmatrix<int> m1 = matrix.new<int>(2, 3, 1)\n//@variable A 2x3 matrix filled with 2s.\nmatrix<int> m2 = matrix.new<int>(2, 3, 2)\n\n//@variable The transpose of \\m1\\.\nt1 = m1.transpose()\n//@variable The transpose of \\m2\\.\nt2 = m2.transpose()\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display the original matrices.\nm1.debugLabel(note = \"Matrix 1\")\nm2.debugLabel(bar\\_index + 10, note = \"Matrix 2\")\n// Append the rows of \\m2\\ to the end of \\m1\\ and display \\m1\\.\nm1.concat(m2)\nm1.debugLabel(bar\\_index + 20, color.blue, note = \"Appended rows\")\n// Append the rows of \\t2\\ to the end of \\t1\\, then display the transpose of \\t1\\.\nt1.concat(t2)\nt1.transpose().debugLabel(bar\\_index + 30, color.purple, note = \"Appended columns\")\n\nMatrix calculations\n\nElement-wise calculations\n\nPine scripts can calculate the _average_, _minimum_, _maximum_, and\n_mode_ of all elements within a matrix via\nmatrix.avg(),\nmatrix.min(),\nmatrix.max(),\nand\nmatrix.mode().\nThese functions operate the same as their array.* equivalents,\nallowing users to run element-wise calculations on a matrix, its\nsubmatrices, and its\nrows and columns using the same syntax. For example, the built-in *.avg()\nfunctions called on a 3x3 matrix with values 1-9 and an\narray\nwith the same nine elements will both return a value of 5.\n\nThe script below uses .avg(), .max(), and *.min() methods to\ncalculate developing averages and extremes of OHLC data in a period. It\nadds a new column of\nopen,\nhigh,\nlow,\nand\nclose\nvalues to the end of the ohlcData matrix whenever queueColumn is\ntrue. When false, the script uses the\nmatrix.get()\nand\nmatrix.set() methods to adjust the elements in the last column for developing\nHLC values in the current period. It uses the ohlcData matrix, a submatrix, and row and column\narrays to calculate the developing OHLC4 and HL2 averages over length\nperiods, the maximum high and minimum low over length periods, and the\ncurrent period’s developing OHLC4 price:\n\n//@version=6\nindicator(\"Element-wise calculations example\", \"Developing values\", overlay = true)\n\n//@variable The number of data points in the averages.\nint length = input.int(3, \"Length\", 1)\n//@variable The timeframe of each reset period.\nstring timeframe = input.timeframe(\"D\", \"Reset Timeframe\")\n\n//@variable A 4x\\length\\ matrix of OHLC values.\nvar matrix<float> ohlcData = matrix.new<float>(4, length)\n\n//@variable Is \\true\\ at the start of a new bar at the \\timeframe\\.\nbool queueColumn = timeframe.change(timeframe)\n\nif queueColumn\n// Add new values to the end column of \\ohlcData\\.\nohlcData.add\\_col(length, array.from(open, high, low, close))\n// Remove the oldest column from \\ohlcData\\.\nohlcData.remove\\_col(0)\nelse\n// Adjust the last element of column 1 for new highs.\nif high > ohlcData.get(1, length - 1)\nohlcData.set(1, length - 1, high)\n// Adjust the last element of column 2 for new lows.\nif low < ohlcData.get(2, length - 1)\nohlcData.set(2, length - 1, low)\n// Adjust the last element of column 3 for the new closing price.\nohlcData.set(3, length - 1, close)\n\n//@variable The \\matrix.avg()\\ of all elements in \\ohlcData\\.\navgOHLC4 = ohlcData.avg()\n//@variable The \\matrix.avg()\\ of all elements in rows 1 and 2, i.e., the average of all \\high\\ and \\low\\ values.\navgHL2 = ohlcData.submatrix(from\\_row = 1, to\\_row = 3).avg()\n//@variable The \\matrix.max()\\ of all values in \\ohlcData\\. Equivalent to \\ohlcData.row(1).max()\\.\nmaxHigh = ohlcData.max()\n//@variable The \\array.min()\\ of all \\low\\ values in \\ohlcData\\. Equivalent to \\ohlcData.min()\\.\nminLow = ohlcData.row(2).min()\n//@variable The \\array.avg()\\ of the last column in \\ohlcData\\, i.e., the current OHLC4.\nohlc4Value = ohlcData.col(length - 1).avg()\n\nplot(avgOHLC4, \"Average OHLC4\", color.purple, 2)\nplot(avgHL2, \"Average HL2\", color.navy, 2)\nplot(maxHigh, \"Max High\", color.green)\nplot(minLow, \"Min Low\", color.red)\nplot(ohlc4Value, \"Current OHLC4\", color.blue)\n\nNote that:\n\n- In this example, we used\narray.() and matrix.() methods interchangeably to demonstrate their similarities in syntax and behavior.\n- Users can calculate the matrix equivalent of\narray.sum()\nby multiplying the values of matrix.avg() and matrix.elements\\_count().\n\nSpecial calculations\n\nPine Script features several built-in functions for performing\nessential matrix arithmetic and linear algebra operations, including\nmatrix.sum(),\nmatrix.diff(),\nmatrix.mult(),\nmatrix.pow(),\nmatrix.det(),\nmatrix.inv(),\nmatrix.pinv(),\nmatrix.rank(),\nmatrix.trace(),\nmatrix.eigenvalues(),\nmatrix.eigenvectors(),\nand\nmatrix.kron().\nThese functions are advanced features that facilitate a variety of\nmatrix calculations and transformations.\n\nBelow, we explain a few fundamental functions with some basic examples.\n\n​ matrix.sum() ​ and ​ matrix.diff() ​\n\nScripts can perform addition and subtraction of two matrices with the\nsame shape or a matrix and a scalar value using the\nmatrix.sum()\nand\nmatrix.diff()\nfunctions. These functions use the values from the id2 matrix or\nscalar to add to or subtract from the elements in id1.\n\nThis script demonstrates a simple example of matrix addition and\nsubtraction in Pine. It creates a 3x3 matrix, calculates its\ntranspose, then calculates the\nmatrix.sum()\nand\nmatrix.diff()\nresults using the two matrices. This example displays the original matrix, its\ntranspose,\nand the resulting sum and difference matrices in labels on the chart:\n\n//@version=6\nindicator(\"Matrix sum and diff example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 3x3 matrix.\nm = matrix.new<float>()\n\n// Add rows to \\m\\.\nm.add\\_row(0, array.from(0.5, 1.0, 1.5))\nm.add\\_row(1, array.from(2.0, 2.5, 3.0))\nm.add\\_row(2, array.from(3.5, 4.0, 4.5))\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display \\m\\.\nm.debugLabel(note = \"A\")\n// Get and display the transpose of \\m\\.\nmatrix<float> t = m.transpose()\nt.debugLabel(bar\\_index + 10, note = \"Aᵀ\")\n// Calculate the sum of the two matrices. The resulting matrix is symmetric.\nmatrix.sum(m, t).debugLabel(bar\\_index + 20, color.green, note = \"A + Aᵀ\")\n// Calculate the difference between the two matrices. The resulting matrix is antisymmetric.\nmatrix.diff(m, t).debugLabel(bar\\_index + 30, color.red, note = \"A - Aᵀ\")\n\nNote that:\n\n- In this example, we’ve labeled the original matrix as “A” and\nthe transpose as “Aᵀ”.\n- Adding “A” and “Aᵀ” produces a _symmetric_ matrix, and subtracting them produces an _antisymmetric_ matrix. The functions matrix.is\\_symmetric() and matrix.is\\_antisymmetric() test a matrix for these conditions.\n\n​ matrix.mult() ​\n\nScripts can multiply two matrices via the\nmatrix.mult()\nfunction. This function can also multiply a matrix by an\narray\nor a scalar value.\n\nIn the case of multiplying two matrices, unlike addition and\nsubtraction, matrix multiplication does not require two matrices to\nshare the same shape. However, the number of columns in the first matrix\nmust equal the number of rows in the second one. The resulting matrix\nreturned by\nmatrix.mult()\nwill contain the same number of rows as the id1 matrix and the same number of\ncolumns as the id2 matrix. For instance, a 2x3 matrix multiplied by a 3x4 matrix\nwill produce a matrix with two rows and four columns, as shown below.\nEach value within the resulting matrix is the dot\\\\\nproduct of the corresponding\nrow in the id1 maxtrix and column in the id2 matrix:\n\n//@version=6\nindicator(\"Matrix mult example\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x3 matrix.\na = matrix.new<float>()\n//@variable A 3x4 matrix.\nb = matrix.new<float>()\n\n// Add rows to \\a\\.\na.add\\_row(0, array.from(1, 2, 3))\na.add\\_row(1, array.from(4, 5, 6))\n\n// Add rows to \\b\\.\nb.add\\_row(0, array.from(0.5, 1.0, 1.5, 2.0))\nb.add\\_row(1, array.from(2.5, 3.0, 3.5, 4.0))\nb.add\\_row(0, array.from(4.5, 5.0, 5.5, 6.0))\n\nif bar\\_index == last\\_bar\\_index - 1\n//@variable The result of \\a\\ \\* \\b\\.\nmatrix<float> ab = a.mult(b)\n// Display \\a\\, \\b\\, and \\ab\\ matrices.\ndebugLabel(a, note = \"A\")\ndebugLabel(b, bar\\_index + 10, note = \"B\")\ndebugLabel(ab, bar\\_index + 20, color.green, note = \"A \\* B\")\n\nNote that:\n\n- In contrast to the multiplication of scalars, matrix\nmultiplication is _non-commutative_, i.e., matrix.mult(a, b)\ndoes not necessarily produce the same result as\nmatrix.mult(b, a). In the context of our example, the latter\nwill raise a runtime error because the number of columns in b\ndoesn’t equal the number of rows in a.\n\nWhen multiplying a matrix and an\narray,\nthis function treats the operation the same as multiplying the id1 matrix by a\nsingle-column matrix, but it returns an\narray\nwith the same number of elements as the number of matrix rows. When\nmatrix.mult()\npasses a scalar as its id2 value, the function returns a new matrix\nwhose elements are the elements in the id1 matrix multiplied by the id2 value.\n\n​ matrix.det() ​\n\nA _determinant_ is a scalar value associated with a square\nmatrix that describes some of its characteristics, namely its\ninvertibility. If a matrix has an\ninverse,\nits determinant is nonzero. Otherwise, the matrix is _singular_\n(non-invertible). Scripts can calculate the determinant of a matrix via\nmatrix.det().\n\nProgrammers can use determinants to detect similarities between\nmatrices, identify _full-rank_ and _rank-deficient_ matrices, and solve\nsystems of linear equations, among other applications.\n\nFor example, this script uses determinants to solve a system of\nlinear equations with a matching number of unknown values using\nCramer’s rule. The\nuser-defined solve() function returns the reference of an\narray\ncontaining solutions for each unknown value in the system, where the\nn-th element of the array is the determinant of the coefficient matrix\nwith the n-th column replaced by the column of constants divided by the\ndeterminant of the original coefficients.\n\nIn this script, we’ve defined the matrix m that holds coefficients\nand constants for these three equations:\n\n`\n\n3  x0 + 4  x1 - 1 * x2 = 8\n\n5  x0 - 2  x1 + 1 * x2 = 4\n\n2  x0 - 2  x1 + 1 * x2 = 1\n`\n\nThe solution to this system is (x0 = 1, x1 = 2, x2 = 3). The script\ncalculates these values from m via m.solve() and plots them on the\nchart:\n\n//@version=6\nindicator(\"Determinants example\", \"Cramer's Rule\")\n\n//@function Solves a system of linear equations with a matching number of unknowns using Cramer's rule.\n//@param this An augmented matrix containing the coefficients for each unknown and the results of\n// the equations. For example, a row containing the values 2, -1, and 3 represents the equation\n// \\2 \\ x0 + (-1) \\ x1 = 3\\, where \\x0\\ and \\x1\\ are the unknown values in the system.\n//@returns An array containing solutions for each variable in the system.\nsolve(matrix<float> this) =>\n//@variable The coefficient matrix for the system of equations.\nmatrix<float> coefficients = this.submatrix(from\\_column = 0, to\\_column = this.columns() - 1)\n//@variable The array of resulting constants for each equation.\narray<float> constants = this.col(this.columns() - 1)\n//@variable An array containing solutions for each unknown in the system.\narray<float> result = array.new<float>()\n\n//@variable The determinant value of the coefficient matrix.\nfloat baseDet = coefficients.det()\nmatrix<float> modified = na\nfor col = 0 to coefficients.columns() - 1\nmodified := coefficients.copy()\nmodified.add\\_col(col, constants)\nmodified.remove\\_col(col + 1)\n\n// Calculate the solution for the column's unknown by dividing the determinant of \\modified\\ by the \\baseDet\\.\nresult.push(modified.det() / baseDet)\n\nresult\n\n//@variable A 3x4 matrix containing coefficients and results for a system of three equations.\nm = matrix.new<float>()\n\n// Add rows for the following equations:\n// Equation 1: 3 \\ x0 + 4 \\ x1 - 1 \\* x2 = 8\n// Equation 2: 5 \\ x0 - 2 \\ x1 + 1 \\* x2 = 4\n// Equation 3: 2 \\ x0 - 2 \\ x1 + 1 \\* x2 = 1\nm.add\\_row(0, array.from(3.0, 4.0, -1.0, 8.0))\nm.add\\_row(1, array.from(5.0, -2.0, 1.0, 4.0))\nm.add\\_row(2, array.from(2.0, -2.0, 1.0, 1.0))\n\n//@variable An array of solutions to the unknowns in the system of equations represented by \\m\\.\nsolutions = solve(m)\n\nplot(solutions.get(0), \"x0\", color.red, 3) // Plots 1.\nplot(solutions.get(1), \"x1\", color.green, 3) // Plots 2.\nplot(solutions.get(2), \"x2\", color.blue, 3) // Plots 3.\n\nNote that:\n\n- Solving systems of equations is particularly useful for\n_regression analysis_, e.g., linear and polynomial regression.\n- Cramer’s rule works fine for small systems of equations.\nHowever, it’s computationally inefficient on larger systems.\nOther methods, such as Gaussian\\\\\nelimination,\nare often preferred for such use cases.\n\n​ matrix.inv() ​ and ​ matrix.pinv() ​\n\nFor any non-singular square\nmatrix, there is an inverse matrix that yields the identity\nmatrix when\nmultiplied by the original. Inverses have use in various matrix\ntransformations and solving systems of equations. Scripts can calculate\nthe inverse of a matrix when one exists via the\nmatrix.inv()\nfunction.\n\nFor singular (non-invertible) matrices, one can calculate a generalized\ninverse\n( pseudoinverse),\nregardless of whether the matrix is square or has a nonzero determinant, via the\nmatrix.pinv()\nfunction. Keep in mind that unlike a true inverse, the product of a\npseudoinverse and the original matrix does not necessarily equal the\nidentity matrix unless the original matrix _is invertible_.\n\nThe following example forms a 2x2 m matrix from user inputs, then calls\nmatrix.inv()\nand\nmatrix.pinv() as methods to calculate the inverse or pseudoinverse of m. The script\ndisplays strings representing the original matrix, its inverse or pseudoinverse, and their\nproduct in labels on the chart:\n\n//@version=6\nindicator(\"Inverse example\")\n\n// Element inputs for the 2x2 matrix.\nfloat r0c0 = input.float(4.0, \"Row 0, Col 0\")\nfloat r0c1 = input.float(3.0, \"Row 0, Col 1\")\nfloat r1c0 = input.float(2.0, \"Row 1, Col 0\")\nfloat r1c1 = input.float(1.0, \"Row 1, Col 1\")\n\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The \\bar\\_index\\ to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar\\_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\\\n\" + str.tostring(this)\nif barstate.ishistory\nlabel.new(\nbarIndex, 0, labelText, color = bgColor, style = label.style\\_label\\_center,\ntextcolor = textColor, size = size.huge\n)\n\n//@variable A 2x2 matrix of input values.\nm = matrix.new<float>()\n\n// Add input values to \\m\\.\nm.add\\_row(0, array.from(r0c0, r0c1))\nm.add\\_row(1, array.from(r1c0, r1c1))\n\n//@variable Is \\true\\ if \\m\\ is square with a nonzero determinant, indicating invertibility.\nbool isInvertible = m.is\\_square() and m.det() != 0\n\n//@variable The inverse or pseudoinverse of \\m\\.\nmInverse = isInvertible ? m.inv() : m.pinv()\n\n//@variable The product of \\m\\ and \\mInverse\\. Returns the identity matrix when \\isInvertible\\ is \\true\\.\nmatrix<float> product = m.mult(mInverse)\n\nif bar\\_index == last\\_bar\\_index - 1\n// Display \\m\\, \\mInverse\\, and their \\product\\.\nm.debugLabel(note = \"Original\")\nmInverse.debugLabel(bar\\_index + 10, color.purple, note = isInvertible ? \"Inverse\" : \"Pseudoinverse\")\nproduct.debugLabel(bar\\_index + 20, color.green, note = \"Product\")\n\nNote that:\n\n- This script calls m.inv() only when isInvertible is true, i.e., when m is square and has a nonzero determinant. Otherwise, it uses m.pinv() to calculate the generalized inverse.\n\n​ matrix.rank() ​\n\nThe _rank_ of a matrix represents the number of linearly independent\nvectors (rows or columns) it contains. In essence, matrix rank measures\nthe number of vectors one cannot express as a linear combination of\nothers, or in other words, the number of vectors that contain unique\ninformation. Scripts can calculate the rank of a matrix via\nmatrix.rank().\n\nThis script identifies the number of linearly independent vectors in two\n3x3 matrices ( m1 and m2) using matrix.rank() and plots the values in a separate pane. As\nwe see on the chart, the m1.rank() value is 3 because each vector is unique. The m2.rank() value, on the other hand, is 1 because it has just one unique vector:\n\n//@version=6\nindicator(\"Matrix rank example\")\n\n//@variable A 3x3 full-rank matrix.\nm1 = matrix.new<float>()\n//@variable A 3x3 rank-deficient matrix.\nm2 = matrix.new<float>()\n\n// Add linearly independent vectors to \\m1\\.\nm1.add\\_row(0, array.from(3, 2, 3))\nm1.add\\_row(1, array.from(4, 6, 6))\nm1.add\\_row(2, array.from(7, 4, 9))\n\n// Add linearly dependent vectors to \\m2\\.\nm2.add\\_row(0, array.from(1, 2, 3))\nm2.add\\_row(1, array.from(2, 4, 6))\nm2.add\\_row(2, array.from(3, 6, 9))\n\n// Plot \\matrix.rank()\\ values.\nplot(m1.rank(), color = color.green, linewidth = 3)\nplot(m2.rank(), color = color.red, linewidth = 3)\n\nNote that:\n\n- The highest rank value a matrix can have is the minimum of its\nnumber of rows and columns. A matrix with the maximum possible\nrank is known as a _full-rank_ matrix, and any matrix without\nfull rank is known as a _rank-deficient_ matrix.\n- The\ndeterminants of full-rank square matrices are nonzero, and such\nmatrices have\ninverses. Conversely, the\ndeterminant\nof a rank-deficient matrix is always 0.\n- For any matrix that contains nothing but the same value in each\nof its elements (e.g., a matrix filled with 0), the rank is\nalways 0 since none of the vectors hold unique information. For\nany other matrix with distinct values, the minimum possible rank\nis 1.\n\nError handling\n\nIn addition to usual compiler errors, which occur during a script’s\ncompilation due to improper syntax, scripts using matrices can raise\nspecific runtime errors during their execution. When a script raises\na runtime error, it displays a red exclamation point next to the script\ntitle. Users can view the error message by clicking this icon.\n\nIn this section, we discuss runtime errors that users may encounter\nwhile utilizing matrices in their scripts.\n\nThe row/column index (xx) is out of bounds, row/column size is (yy).\n\nThis runtime error occurs when trying to access indices outside the\nmatrix dimensions with functions including\nmatrix.get(),\nmatrix.set(),\nmatrix.fill(),\nand\nmatrix.submatrix(),\nas well as some of the functions relating to the\nrows and columns of a matrix.\n\nFor example, this code contains two lines that will produce this runtime\nerror. The\nm.set()\nmethod references a row index that doesn’t exist (2). The\nm.submatrix()\nmethod references all column indices up to to_column - 1. A\nto_column value of 4 results in a runtime error because the last\ncolumn index referenced (3) does not exist in m:\n\n//@version=6\nindicator(\"Out of bounds demo\")\n\n//@variable A 2x3 matrix with a max row index of 1 and max column index of 2.\nmatrix<float> m = matrix.new<float>(2, 3, 0.0)\n\nm.set(row = 2, column = 0, value = 1.0) // The \\row\\ index is out of bounds on this line. The max value is 1.\nm.submatrix(from\\_column = 1, to\\_column = 4) // The \\to\\_column\\ index is invalid on this line. The max value is 3.\n\nif bar\\_index == last\\_bar\\_index - 1\nlabel.new(bar\\_index, 0, str.tostring(m), color = color.navy, textcolor = color.white, size = size.huge)\n\nUsers can avoid this error in their scripts by ensuring their function\ncalls do not reference indices greater than or equal to the number of\nrows/columns.\n\nThe array size does not match the number of rows/columns in the matrix.\n\nWhen using\nmatrix.add\\_row()\nand\nmatrix.add\\_col()\nfunctions to\ninsert rows and columns into a non-empty matrix, the size of the\ninserted array must align with the matrix dimensions. The size of an\ninserted row must match the number of columns, and the size of an\ninserted column must match the number of rows. Otherwise, the script\nwill raise this runtime error. For example:\n\n//@version=6\nindicator(\"Invalid array size demo\")\n\n// Declare an empty matrix.\nm = matrix.new<float>()\n\nm.add\\_col(0, array.from(1, 2)) // Add a column. Changes the shape of \\m\\ to 2x1.\nm.add\\_col(1, array.from(1, 2, 3)) // Raises a runtime error because \\m\\ has 2 rows, not 3.\n\nplot(m.col(0).get(1))\n\nNote that:\n\n- When m is empty, one can insert a row or column array of _any_\nsize, as shown in the first m.add_col() line.\n\nCannot call matrix methods when the ID of matrix is ‘na’.\n\nWhen a matrix variable is assigned to na, it means that the variable\ndoesn’t reference an existing object. Consequently, one cannot use\nbuilt-in matrix.*() functions and methods with it. For example:\n\n//@version=6\nindicator(\"na matrix methods demo\")\n\n//@variable A \\matrix\\ variable assigned to \\na\\.\nmatrix<float> m = na\n\nmCopy = m.copy() // Raises a runtime error. You can't copy a matrix that doesn't exist.\n\nif bar\\_index == last\\_bar\\_index - 1\nlabel.new(bar\\_index, 0, str.tostring(mCopy), color = color.navy, textcolor = color.white, size = size.huge)\n\nTo resolve this error, assign m to a valid matrix instance before\nusing matrix.*() functions.\n\nMatrix is too large. Maximum size of the matrix is 100,000 elements.\n\nThe total number of elements in a matrix\n( matrix.elements\\_count())\ncannot exceed 100,000, regardless of its shape. For example, this\nscript will raise an error because it\ninserts 1000 rows with 101 elements into the m matrix:\n\n//@version=6\nindicator(\"Matrix too large demo\")\n\nvar matrix<float> m = matrix.new<float>()\n\nif bar\\_index == 0\nfor i = 1 to 1000\n// This raises an error because the script adds 101 elements on each iteration.\n// 1000 rows \\* 101 elements per row = 101000 total elements. This is too large.\nm.add\\_row(m.rows(), array.new<float>(101, i))\n\nplot(m.get(0, 0))\n\nThe row/column index must be 0 <= from\\_row/column < to\\_row/column.\n\nWhen using matrix.*() functions with from_row/column and\nto_row/column indices, the from_* values must be less than the\ncorresponding to_* values, with the minimum possible value being 0.\nOtherwise, the script will raise a runtime error.\n\nFor example, this script shows an attempt to declare a\nsubmatrix from a 4x4 m matrix with a from_row value of 2 and a\nto_row value of 2, which will result in an error:\n\n//@version=6\nindicator(\"Invalid from\\_row, to\\_row demo\")\n\n//@variable A 4x4 matrix filled with a random value.\nmatrix<float> m = matrix.new<float>(4, 4, math.random())\n\nmatrix<float> mSub = m.submatrix(from\\_row = 2, to\\_row = 2) // Raises an error. \\from\\_row\\ can't equal \\to\\_row\\.\n\nplot(mSub.get(0, 0))\n\nMatrices ‘id1’ and ‘id2’ must have an equal number of rows and columns to be added.\n\nWhen using\nmatrix.sum() and matrix.diff() functions, the id1 and id2 matrices must have the same\nnumber of rows and the same number of columns. Attempting to add or\nsubtract two matrices with mismatched dimensions will raise an error, as\ndemonstrated by this code:\n\n//@version=6\nindicator(\"Invalid sum dimensions demo\")\n\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 3x4 matrix.\nmatrix<float> m2 = matrix.new<float>(3, 4, 2)\n\nmSum = matrix.sum(m1, m2) // Raises an error. \\m1\\ and \\m2\\ don't have matching dimensions.\n\nplot(mSum.get(0, 0))\n\nThe number of columns in the ‘id1’ matrix must equal the number of rows in the matrix (or the number of elements in the array) ‘id2’.\n\nWhen using\nmatrix.mult() to multiply an id1 matrix by an id2 matrix or array, the\nmatrix.rows()\nor\narray.size()\nof id2 must equal the\nmatrix.columns()\nin id1. If they don’t align, the script will raise this error.\n\nFor example, this script tries to multiply two 2x3 matrices. While\n_adding_ these matrices is possible, _multiplying_ them is not:\n\n//@version=6\nindicator(\"Invalid mult dimensions demo\")\n\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 2x3 matrix.\nmatrix<float> m2 = matrix.new<float>(2, 3, 2)\n\nmSum = matrix.mult(m1, m2) // Raises an error. The number of columns in \\m1\\ and rows in \\m2\\ aren't equal.\n\nplot(mSum.get(0, 0))\n\nOperation not available for non-square matrices.\n\nSome matrix operations, including\nmatrix.inv(),\nmatrix.det(),\nmatrix.eigenvalues(),\nand\nmatrix.eigenvectors()\nonly work with square matrices, i.e., matrices with the same number\nof rows and columns. When attempting to execute such functions on\nnon-square matrices, the script will raise an error stating the\noperation isn’t available or that it cannot calculate the result for\nthe matrix id`. For example:\n\n//@version=6\nindicator(\"Non-square demo\")\n\n//@variable A 3x5 matrix.\nmatrix<float> m = matrix.new<float>(3, 5, 1)\n\nplot(m.det()) // Raises a runtime error. You can't calculate the determinant of a 3x5 matrix.\n\nPrevious\\\\\nArrays Next\\\\\nMaps",
    "examples": [
      "[var/varip ][matrix<type> ]<identifier> = <expression>",
      "3 * x0 + 4 * x1 - 1 * x2 = 8\n\n5 * x0 - 2 * x1 + 1 * x2 = 4\n\n2 * x0 - 2 * x1 + 1 * x2 = 1"
    ],
    "type": "language_concept"
  }
}